<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<static.StaticResult>
  <summary>
    <prjName>ggg11</prjName>
    <toolName>static.StaticResult</toolName>
    <toolVersion/>
    <numberOfCodeViolation>52</numberOfCodeViolation>
    <numberOfRteViolation>0</numberOfRteViolation>
  </summary>
  <source>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/.STATICDATA/PREINCLUDE/RECENT_PREINCLUDE_C.H</fileName>
    <crc32>dae7ffb3</crc32>
    <isExcluded>true</isExcluded>
  </source>
  <source>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <crc32>1086f1ae</crc32>
    <isExcluded>false</isExcluded>
  </source>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Access_Using_Incompatible_Type</rule>
    <ruleTitle><![CDATA[호환되지 않는 타입을 사용하여 자원 접근 금지]]></ruleTitle>
    <ruleDesc/>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Addition_of_Data_Structure_Sentinel</rule>
    <ruleTitle><![CDATA[자료 구조 sentinel 추가 검사 ]]></ruleTitle>
    <ruleDesc/>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Assign_Public_Data_To_Private_Field</rule>
    <ruleTitle><![CDATA[변경할 수 있는 private 필드에 public 데이터 할당 금지]]></ruleTitle>
    <ruleDesc><![CDATA[public 데이터를 private 멤버 배열에 할당하면 직접 접근하는 것과 같다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Assign_of_Fixed_Address_to_pointer</rule>
    <ruleTitle><![CDATA[포인터에 고정 주소 할당 금지]]></ruleTitle>
    <ruleDesc/>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Assigning_instead_of_Comparing</rule>
    <ruleTitle><![CDATA[condition에 assign 연산자 사용금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[condition에 assign 연산자 사용금지 ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Buffer_Overrun</rule>
    <ruleTitle><![CDATA[배열의 최대 범위를 벗어나는 참조 금지]]></ruleTitle>
    <ruleDesc><![CDATA[배열의 경계 외부를 참조하면 데이터를 손상시키거나, 프로그램이 중단될 수 있다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Buffer_Underrun</rule>
    <ruleTitle><![CDATA[배열의 최소 범위를 벗어나는 참조 금지]]></ruleTitle>
    <ruleDesc><![CDATA[배열의 경계 외부를 참조하면 데이터를 손상시키거나, 프로그램이 중단될 수 있다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Cloneable_Class</rule>
    <ruleTitle><![CDATA[생성자를 호출하지 않는 클래스 복사 금지]]></ruleTitle>
    <ruleDesc><![CDATA[클래스를 복사하면 외부에서 클래스에 담긴 민감한 정보에 접근할 수 있다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Comparing_instead_of_Assigning</rule>
    <ruleTitle><![CDATA[할당문 대신 비교문 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[여러 프로그래밍 언어에서 비교문과 할당문은 매우 유사하기 때문에, 두 명령문의 사용을 혼동할 수 있다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Dead Code</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Compiler_Removal_of_Code</rule>
    <ruleTitle><![CDATA[컴파일러가 최적화 가능한 code 사용금지]]></ruleTitle>
    <ruleDesc/>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Creation_chroot_Without_Changing</rule>
    <ruleTitle><![CDATA[작업 디렉토리 변경없이 chroot 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[작업 디렉토리 변경없이 chroot 사용 금지]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Dangerous_Function_Cast</rule>
    <ruleTitle><![CDATA[함수 포인터를 반환 타입이 일치하지 않는 함수 포인터로 변환 금지]]></ruleTitle>
    <ruleDesc><![CDATA[함수 포인터를 반환 타입이 일치하지 않는 함수 포인터로 변환하는 것은 정의하지 않은 행동이다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Divide_By_Zero</rule>
    <ruleTitle><![CDATA[0 으로 나누기 금지]]></ruleTitle>
    <ruleDesc><![CDATA[프로그램에서 나누기 연산의 제수로 사용하는 표현식의 계산 값이 0 이면 프로그램이 의도하지 않은 동작을 일으킨다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Double_Free</rule>
    <ruleTitle><![CDATA[메모리 중복 해제 금지]]></ruleTitle>
    <ruleDesc><![CDATA[해제된 포인터 변수를 다시 해제하면 예상하지 못한 메모리 위치를 변경시킬 수 있다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Duplicate_Key_in_Associative_List</rule>
    <ruleTitle><![CDATA[Associative List에서 중복 키 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[Associative List에서 중복 키 사용 금지]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Format_String</rule>
    <ruleTitle><![CDATA[부적절한 포맷 스트링 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[프로그램 함수에서 부적절한 포맷 스트링을 사용하면, 버퍼 오버 플로우나 자원 노출 같은 결함이 발생할 수 있다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_FunctionCall_With_Incorrect_Argument</rule>
    <ruleTitle><![CDATA[부적절한 인자로 함수 호출 금지]]></ruleTitle>
    <ruleDesc/>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Generic_Exception_Catch</rule>
    <ruleTitle><![CDATA[모든 형식의 예외를 처리하는 catch문 금지]]></ruleTitle>
    <ruleDesc><![CDATA[ 모든 형식의 예외를 처리하는 catch문을 사용하면 안 된다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Improper_Address_Validation</rule>
    <ruleTitle><![CDATA[IOCTL 장치 제어 코드가 METHOD_NEITHER일때 버퍼 주소 유효성 검사]]></ruleTitle>
    <ruleDesc/>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Improper_Cleanup_on_Thrown_Exception</rule>
    <ruleTitle><![CDATA[예외처리 시 관련된 자원이나 상태가 정리되어야 함]]></ruleTitle>
    <ruleDesc/>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Improper_Clearing_of_Heap_Memory</rule>
    <ruleTitle><![CDATA[부적절한 Heap 메모리 해제 금지]]></ruleTitle>
    <ruleDesc/>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Improper_Handling_of_Length_Param</rule>
    <ruleTitle><![CDATA[조건식으로 검증한 index를 관련 없는 필드 참조에 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[조건식으로 검증한 index를 관련 없는 필드 참조에 사용하면 Buffer Overrun이 발생할 수 있다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Improper_Synchronization</rule>
    <ruleTitle><![CDATA[부적정한 동기화로 공유 자원 동기 실행 금지]]></ruleTitle>
    <ruleDesc><![CDATA[부적정한 동기화로 공유 자원 동기 실행 금지]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Improper_Validation_of_Array_Index</rule>
    <ruleTitle><![CDATA[배열 참조 시 index 변수의 범위를 확인하는지 검사]]></ruleTitle>
    <ruleDesc/>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Incorrect_Block_Delimitation</rule>
    <ruleTitle><![CDATA[잘못된 블록 구분 금지]]></ruleTitle>
    <ruleDesc/>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Incorrect_Number_of_Arguments</rule>
    <ruleTitle><![CDATA[함수 호출 시 인자와 타입이 함수 정의와 일치해야 함]]></ruleTitle>
    <ruleDesc/>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Incorrect_Numeric_Casting</rule>
    <ruleTitle><![CDATA[부적절한 숫자 타입 사이의 캐스팅 금지]]></ruleTitle>
    <ruleDesc><![CDATA[서론 다른 숫자 타입끼리 캐스팅을 하면 예상하지 못한 값으로 변할 수 있다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Incorrect_Pointer_Scaling</rule>
    <ruleTitle><![CDATA[잘못된 포인터 크기 조정 금지]]></ruleTitle>
    <ruleDesc/>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Infinite_Call</rule>
    <ruleTitle><![CDATA[함수 재귀 호출 금지]]></ruleTitle>
    <ruleDesc><![CDATA[함수를를 재귀 호출을 하면 프로그램이 종료되지 않을 수 있다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Infinite_Loop</rule>
    <ruleTitle><![CDATA[종료되지 않는 루프 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[종료되지 않는 루프를 사용하면 안 된다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Invalid_Malloc_Argument</rule>
    <ruleTitle><![CDATA[malloc 으로 메모리 할당 시 유효하지 않은 길이 금지]]></ruleTitle>
    <ruleDesc><![CDATA[malloc 으로 메모리 할당 시 길이는 할당 받은 메모리 내에 있어야 한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Memcpy_Length_Unreasonable</rule>
    <ruleTitle><![CDATA[memcpy 에 잘못된 크기의 인자 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[memcpy 에 잘못된 크기의 인자를 사용하면 버퍼 밖의 경계에 접근하여 오류를 일으킨다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Memory_Free_On_Stack_Variable</rule>
    <ruleTitle><![CDATA[정적 메모리를 가리키는 포인터 해제 금지]]></ruleTitle>
    <ruleDesc><![CDATA[명시적으로 스택 메모리를 해제하면 프로그램이 의도하지 않은 동작을 일으킨다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Memory_Leak</rule>
    <ruleTitle><![CDATA[프로그램 흐름에서 메모리 누수 금지]]></ruleTitle>
    <ruleDesc><![CDATA[프로그램에서 메모리를 할당하고 해제하지 않으면 메모리 누수가 발생한다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Mismatched_Memory_Management</rule>
    <ruleTitle><![CDATA[서로 맞지 않는 동적 메모리 할당과 해제 금지]]></ruleTitle>
    <ruleDesc><![CDATA[동적 메모리는 C/C++ 언어의 다른 구성요소보다 더 확실하게 확인하여 할당하거나 해제해야 한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Missing_Default_Case_in_Switch_State</rule>
    <ruleTitle><![CDATA[Switch문에는 Default case문이 있어야 함]]></ruleTitle>
    <ruleDesc/>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Missing_Return_Statement</rule>
    <ruleTitle><![CDATA[void 타입이 아닌 함수는 값을 반환해야 함]]></ruleTitle>
    <ruleDesc><![CDATA[ void 가 아닌 함수에는 적어도 하나의 리턴문은 있어야 한다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Negative_Shift_Amount</rule>
    <ruleTitle><![CDATA[shift 연산에 음수 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[shift 연산의 피연산자에 음수를 사용하면 프로그램 오류가 발생할 수 있다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Dead Code</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Null_Check_After_Dereference</rule>
    <ruleTitle><![CDATA[포인터 참조 후 null 검사 금지]]></ruleTitle>
    <ruleDesc><![CDATA[포인터를 참조 한 후에 널 검사를 하면 널 포인터 참조를 예방할 수 없다. 프로그램 논리 흐름을 확인하고 널 검사 후 참조로 변경되어야 한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Null_Pointer_Dereference</rule>
    <ruleTitle><![CDATA[Null 을 가리키는 포인터 참조 금지]]></ruleTitle>
    <ruleDesc><![CDATA[Null 을 가리키는 포인터를 참조하는 것은 정의하지 않은 행동이다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Null_Pointer_Free</rule>
    <ruleTitle><![CDATA[Null 포인터에 대한 메모리 해제 금지]]></ruleTitle>
    <ruleDesc><![CDATA[이미 Null 을 가리키고 있는 포인터를 해제할 수 없다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Numeric_Operation_On_Address_Of_Var</rule>
    <ruleTitle><![CDATA[변수의 주소값에 산술 연산 금지]]></ruleTitle>
    <ruleDesc><![CDATA[ 변수의 주소값에 산술 연산을 하면 정의하지 않은 결과를 발생시킬 수 있다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Often_Misused_String_Management</rule>
    <ruleTitle><![CDATA[buffer overflow가 발생할 수 있는 문자열 조작 함수 사용 금지]]></ruleTitle>
    <ruleDesc/>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Omitted_Break-Statement_in_Switch</rule>
    <ruleTitle><![CDATA[Switch문에서 Break문 생략 금지]]></ruleTitle>
    <ruleDesc/>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Operator_Precedence_Logic_Error</rule>
    <ruleTitle><![CDATA[연산자 우선순위를 명확히 하기 위해 괄호를 사용해야 함]]></ruleTitle>
    <ruleDesc/>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Pass_Field_To_Untrusted_Method</rule>
    <ruleTitle><![CDATA[변경할 수 있는 private 필드를 외부 클래스의 메서드 인자로 전달 금지]]></ruleTitle>
    <ruleDesc><![CDATA[ public 메서드에서 private 배열이나 포인터를 외부 클래스의 메소드 인자로 사용하면 예상하지 못한 방식으로 변경할 수 있다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Public_Field</rule>
    <ruleTitle><![CDATA[public 필드 선언 금지]]></ruleTitle>
    <ruleDesc><![CDATA[ public으로 선언한 필드는 외부에서 예상하지 못한 값으로 변경할 수 있다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Public_Static_Field</rule>
    <ruleTitle><![CDATA[public static 필드 선언 금지]]></ruleTitle>
    <ruleDesc><![CDATA[ public static 필드는 const로 선언해야 한다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Race_Condition_During_Resource_Copy</rule>
    <ruleTitle><![CDATA[자원복사 도중 경쟁상태 허용 금지]]></ruleTitle>
    <ruleDesc/>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Race_Condition_in_Switch</rule>
    <ruleTitle><![CDATA[switch 문 내에서 경쟁상태가 발생하지 않아야 함]]></ruleTitle>
    <ruleDesc/>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Redundant_Condition</rule>
    <ruleTitle><![CDATA[항상 결과가 같은 조건식 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[프로그램에 항상 참이거나 거짓인 조건식이 있을 수 있다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Return_Freed_Pointer</rule>
    <ruleTitle><![CDATA[함수에서 해제한 메모리 반환 금지]]></ruleTitle>
    <ruleDesc><![CDATA[이미 해제한 메모리를 반환하면 여러 메모리 오류의 원인이 된다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Return_Mutable_Private_Field</rule>
    <ruleTitle><![CDATA[public 메서드에서 변경할 수 있는 private 필드 반환 금지]]></ruleTitle>
    <ruleDesc><![CDATA[public 메서드에서 private 배열이나 포인터를 반환하면 예상하지 못한 방식으로 외부에서 변경할 수 있다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Return_Pointer_To_Local</rule>
    <ruleTitle><![CDATA[지역 변수의 포인터 반환 금지]]></ruleTitle>
    <ruleDesc><![CDATA[함수에서 반환한 지역 변수의 포인터는 함수가 끝나면 유효하지 않다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Shift_More_Bit_Than_Width</rule>
    <ruleTitle><![CDATA[피연산자의 bit 길이를 넘는 shift 연산 금지]]></ruleTitle>
    <ruleDesc><![CDATA[연산자의 bit 길이를 넘는 shift 연산을 하면 프로그램 오류가 발생할 수 있다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Signal_Handler</rule>
    <ruleTitle><![CDATA[시그널 핸들러 에러]]></ruleTitle>
    <ruleDesc><![CDATA[ 시그널 핸들러에서 특정 함수를 사용하면 경쟁조건이 발생할 수 있다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Singleton_Without_Synchronization</rule>
    <ruleTitle><![CDATA[멀티쓰레드 환경에서 동기화 없이 싱글톤 패턴 사용 금지]]></ruleTitle>
    <ruleDesc/>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Square_Root_Of_Negative_Numbers</rule>
    <ruleTitle><![CDATA[음수의 제곱근을 구하는 연산 금지]]></ruleTitle>
    <ruleDesc><![CDATA[음수의 제곱근을 구하는 것은 정의하지 않은 행동이다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Throw_Generic_Exception</rule>
    <ruleTitle><![CDATA[모든 형식의 예외를 발생시키는 함수 선언 금지]]></ruleTitle>
    <ruleDesc><![CDATA[ 모든 형식의 예외를 발생시키는 함수를 선언하면 안 된다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Type_Overrun</rule>
    <ruleTitle><![CDATA[타입 범위를 벗어나는 값 사용 금지(Overrun)]]></ruleTitle>
    <ruleDesc><![CDATA[타입이 표현할 수 있는 최대 값보다 큰 값을 사용하는 경우 정의되지 않은 동작을 유발한다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Type_Underrun</rule>
    <ruleTitle><![CDATA[타입 범위를 벗어나는 값 사용 금지(Underrun)]]></ruleTitle>
    <ruleDesc><![CDATA[타입이 표현할 수 있는 최소 값보다 작은 값을 사용하는 경우 정의되지 않은 동작을 유발한다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Uncaught_Exception</rule>
    <ruleTitle><![CDATA[처리하지 않은 예외]]></ruleTitle>
    <ruleDesc><![CDATA[ 특정 함수는 예외는 반드시 처리해야 한다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Uninitialized_Variable</rule>
    <ruleTitle><![CDATA[초기화되지 않은 변수 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[C/C++ 에서 static 으로 선언되지 않은 변수는 기본적으로 초기화 하지 않는다. 따라서 변수를 초기화하지 않고 바로 사용하는 것은 위험하다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Unreachable_Code</rule>
    <ruleTitle><![CDATA[프로그램에 도달 불가능한 지점이 없어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[코딩 오류로 프로그램에 도달할 수 없는 지점이 있을 수 있다. 이런 코드는 컴파일러가 최적화로 제거하기도 하지만, 개발자가 확실하게 식별하고 제거해야 예상하지 않은 동작을 방지할 수 있다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Unused_Return_Value</rule>
    <ruleTitle><![CDATA[함수 반환 값은 사용해야 함]]></ruleTitle>
    <ruleDesc><![CDATA[함수의 반환 값을 확인하면, 예상하지 못한 상태나 오류를 확인할 수 있다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Unused_Value</rule>
    <ruleTitle><![CDATA[프로그램 흐름에서 만들어진 값은 사용해야 함]]></ruleTitle>
    <ruleDesc><![CDATA[사용하지 않는 값을 계산하는 것은 성능상에 문제가 있을 수 있으며, 개발자가 의도하지 않았을 가능성이 있다. 대부분의 경우 프로그램의 논리 흐름에 문제가 있다.]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Use_After_Free</rule>
    <ruleTitle><![CDATA[해제한 메모리 오브젝트 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[해제한 메모리를 사용하는 것은 위험하다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Use_Inconsistent_Function</rule>
    <ruleTitle><![CDATA[특정 운영체제만 지원하는 함수 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[ 다른 운영체제나 운영체제의 버전을 고려하지 않고 구현된 함수를 사용하면 안된다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Use_Of_Expired_File_Descriptor</rule>
    <ruleTitle><![CDATA[만료된 파일 서술자 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[이미 닫힌 파일 서술자를 사용하면 안 된다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Use_Of_External_Format_String</rule>
    <ruleTitle><![CDATA[검증하지 않은 외부 형식 문자열 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[ 검증하지 않음 외부 형식 문자열을 사용하면 버퍼 오버플로우를 유발할 수 있다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Use_Of_getlogin_In_Multithread</rule>
    <ruleTitle><![CDATA[멀티쓰레드 환경에서 getlogin() 함수 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[ 멀티쓰레드 환경에서 getlogin() 함수를 사용하면 잘못된 값을 반환할 수 있다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Use_Of_sizeof_On_Pointer</rule>
    <ruleTitle><![CDATA[포인터 변수에 sizeof()의 연산자 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[  포인터 변수를 sizeof() 연산자의 인자로 사용하면 항상 포인터의 크기를 반환한다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Dead Code</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Use_Of_umask_With_chmod_Argument</rule>
    <ruleTitle><![CDATA[umask 함수에 chmod 인자 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[ umask 함수에 chmod 함수의 인자와 같은 형태의 인자를 사용하면 안 된다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Useless_Assignment</rule>
    <ruleTitle><![CDATA[필요없는 할당 금지]]></ruleTitle>
    <ruleDesc><![CDATA[이미 사용한 변수에 값을 할당하기만 하는 것은 불필요한 코드일 수 있다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Variable_Arguments_Function_Cast</rule>
    <ruleTitle><![CDATA[가변 인자 함수 포인터를 인자나 리턴 타입이 일치하지 않는 함수 포인터로 변환 금지]]></ruleTitle>
    <ruleDesc><![CDATA[가변 인자 함수 포인터를 인자나 반환 타입이 일치하지 않는 함수 포인터로 변환하는 것은 정의하지 않은 행동이다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISSION_CRITICAL_ERRORS</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for Mission Critical Software by CODESCROLL
]]></ruleSetDesc>
    <rule>RTE_Write-what-where_Condition</rule>
    <ruleTitle><![CDATA[임의의 값을 임의의 위치에 쓸 수 있는 상황이 발생하면 안됨]]></ruleTitle>
    <ruleDesc/>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_01_01</rule>
    <ruleTitle><![CDATA[프로그램은 C 표준과 사용하는 컴파일러의 번역 제한을 준수해야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
프로그램은 C90 또는 C99 표준에서 명시된 특성과 라이브러리만 사용해야 한다. 표준에서는 컴파일러마다 확장 요소를 제공할 수 있도록 허용하기 때문에, 이 규칙에서는 이러한 확장 요소들을 사용하는 것 역시 허용된다. 임베디드 컴파일러 대부분은 하드웨어 의존적인 코드를 더 효율적으로 작성하기 위해 확장 요소들을 제공한다. 이런 확장 요소들은 C 표준에서 명시하고 있지 않은 추가적인 특성들을 위한 경우가 많으므로 대부분 이 규칙에서 허용된다.<br/><br/>
C 표준에서는 문장 블록 중첩 수, #include 중첩 수 등 번역 제한(translation limits)을 명시하고 있다. 컴파일러에 따라 제한 수치는 더 클 수도 있다. 모든 프로그램은 컴파일러에서 제공하는 번역 제한 수치에 맞춰서 작성되어야 한다.<br/>
C99 표준에서 명시하는 번역 제한은 다음과 같다.<br/>
- 문장 블록 중첩 수: 127<br/>
- #if...#else 중첩 수: 63<br/>
- 하나의 선언에서 포인터, 배열, 함수 선언 조합 수: 12<br/>
- 하나의 선언에서 괄호 선언 중첩 수: 63<br/>
- 하나의 수식에서 괄호 수식 중첩 수: 63<br/>
- 내부 식별자 혹은 매크로 이름의 중요 캐릭터(significant character) 수: 63<br/>
- 외부 식별자의 중요 캐릭터(significant character) 수: 31<br/>
- 하나의 번역 단위에서 외부 식별자 수: 4095<br/>
- 하나의 문장 블록에서 선언되는 식별자 수: 511<br/>
- 하나의 번역 단위에서 정의되는 매크로 식별자 수: 4095<br/>
- 하나의 함수 정의에서 파라미터 수: 127<br/>
- 하나의 함수 호출에서 인자 수: 127<br/>
- 하나의 매크로 정의에서 파라미터 수: 127<br/>
- 하나의 매크로 호출에서 인자 수: 127<br/>
- 하나의 논리적 소스 라인에 캐릭터 수: 4095<br/>
- 하나의 문자열 상수에 캐릭터 수: 4095<br/>
- 객체 바이트 크기(호스트 환경에서만 유효): 65,535<br/>
- #include 중첩 수: 15<br/>
- 하나의 switch에서 case 수: 1023<br/>
- 하나의 struct, union에서 멤버 필드 수: 1023<br/>
- 하나의 enum에서 enumerator 수: 1023<br/>
- 하나의 구조체 선언에서 struct, unit 정의 중첩 수: 63<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Dir 2.1, Rule 1.2<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_01_02</rule>
    <ruleTitle><![CDATA[언어 확장을 사용하면 안 됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
컴파일러의 확장 요소들에 의존적인 코드는 이식성이 낮다. 표준에서는 확장 요소들에 대한 설명 문서를 요구하지만, 이런 문서들이 모든 환경에서 모든 동작들을 다 설명하지 못한다는 위험 요소도 존재한다.<br/><br/>
임베디드 시스템에서 컴파일러에서 제공하는 언어 확장 요소를 사용하는 것은 필요한 일이다. 단, 표준에서 정의한 동작을 변경시키는 확장 요소는 사용하지 말아야 한다. 예를 들어, 표준에서는 &&, ||의 우변은 좌변의 결과에 따라 계산되지 않을 수도 있다. 만일 어떤 컴파일러에서 좌변의 결과와 무관하게 우변이 항상 계산된다면, 이런 확장 요소는 이 규칙에 위배된다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 1.1<br/>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_01_03</rule>
    <ruleTitle><![CDATA[정의되지 않거나 명시되지 않은 행동이 발생하면 안 됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
프로그램이 예상한 방식으로 동작하지 않으면 정의되지 않은 행동(Undefined behaviour)이거나 명시되지 않은 행동(Unspecified behaviour)이다. 단순히 이식성의 문제일 수도 있으나, 더 심각한 문제가 발생할 수도 있다. 예를 들면, 정의되지 않은 행동은 계산 결과를 다르게 할 수 있다. 소프트웨어의 동작이 이 계산에 달려있다면 시스템의 안전도 보장할 수 없다. 문제는 이런 정의되지 않은 행동이 아주 드문 상황에만 나타나기 때문에 찾기가 매우 어렵다는 것이다.<br/><br/>
MISRA C:2012의 많은 규칙들이 이 문제를 피하기 위해 설계되었다. 예를 들어 Rule 11.4, Rule 11.8, Rule 19.2는 C90의 [Undefined 39], C99의 [Undefined 61]을 피하기 위해 정의되었다. 그 외 항목들에 대해서는 특정 규칙으로 정의하지 않았는데 그 이유는 거의 일어날 가능성이 없거나, 아니면 현실적인 가이드라인을 정의할 수 없기 때문이다. 그러나 구체적인 가이드라인을 제공하지 못하더라도 이 항목들을 매우 중요하게 취급되도록 하기 위해 별도의 규칙으로 정의한다.<br/><br/>
기존 MISRA C:2004의 Rule 1.2, Rule 18.1, Rule 19.8, Rule 19.14, Rule 20.6이 이 규칙으로 병합되었다(MISRA C:2012 Addendum 1 — Rule Mappings 참조).<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Dir 4.1<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_02_01</rule>
    <ruleTitle><![CDATA[도달할 수 없는 코드(unreachable code)가 있으면 안 됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
프로그램에서 undefined behaviour가 발생하지 않는 한, 도달할 수 없는 코드는 실행될 수 없고, 프로그램의 결과에 어떤 영향도 줄 수 없다. 따라서 도달할 수 없는 코드가 존재한다는 것은 프로그램 로직에 오류가 존재할 가능성이 있음을 의미하므로 삭제하는 것을 권장한다.<br/><br/>
컴파일러들은 도달할 수 없는 코드들을 삭제할 수 있다. 단, 다음과 같이 컴파일러가 바이너리를 생성하는 동작에 영향을 주는 코드는 삭제하지 않는다. 이 규칙에서도 이런 의도가 포함된 코드는 위배로 보지 않는다.<br/>
- 타겟 머신의 메모리를 차지한다.<br/>
- 컴파일러가 도달할 수 없는 코드 주위의 소스코드를 번역할 때, 더 길고 느린 점프 명령어를 선택하도록 한다.<br/>
- 루프 내에서, 도달할 수 없는 코드는 전체 루프가 캐쉬 내에 상주하는 것을 방해한다.<br/><br/>
또한 예외 상황을 처리하기 위한 방어 코드가 도달할 수 없는 코드가 되는 경우가 있다. 예를 들어, Rule 16.4를 준수하기 위해 switch에는 항상 default가 존재해야 한다. 모든 도달 가능한 값들을 처리할 수 있는 case가 존재하더라도 default를 넣는 이유는, 프로그램 내의 undefined behaviour 혹은 하드웨어 고장으로 인해 발생할 수 있는 예외적인 값들을 처리하기 위해서이다. 이런 방어 코드는 이 규칙에서 위배로 검출하지 않는다.<br/>
어떤 컴파일러는 default가 도달 불가능한지를 분석하여 삭제하기도 한다. 그러나 반드시 default 방어 코드가 필요한 경우, volatile을 이용하여 컴파일러가 삭제하지 않도록 할 수 있다. switch (*(volatile uint16_t*)&x)와 같이 작성하면 컴파일러는 이 조건식에는 어떤 값도 들어올 수 있다고 가정하므로, default가 삭제되지 않는다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 14.3, Rule 16.4<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_02_02</rule>
    <ruleTitle><![CDATA[죽은 코드(dead code)는 없어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
실행 가능하지만 제거하더라도 프로그램의 동작에 영향을 주지 않는 모든 연산을 죽은 코드(dead code)라고 한다. 언어 확장에 의한 연산은 항상 프로그램 동작에 영향이 있다고 가정해서 죽은 코드로 보지 않는다.<br/>
참고로 Rule 2.1에서 언급한 도달할 수 없는 코드는 실행될 수 없기 때문에 죽은 코드는 아니다.<br/>
죽은 코드가 있다는 것은 프로그램 로직에 오류가 존재할 가능성을 암시한다. 이런 코드들은 컴파일러에 의해 삭제될 수 있으므로, 남겨 두면 혼란을 야기할 수 있으므로 삭제를 권장한다.<br/>
단, void로의 변환은 의도적으로 사용되지 않는 값을 가리킨다. 그러므로 void로의 변환 자체는 죽은 코드가 아니며, 그 피연산자를 사용하도록 하는 것 또한 죽은 코드가 아니다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 17.7<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_02_03</rule>
    <ruleTitle><![CDATA[사용되지 않은 타입 선언은 없어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
선언된 타입이 사용되지 않으면, 타입이 쓸모가 있는지 아니면 실수로 남겨졌는지 명확하지 않다. 따라서, 사용되지 않은 타입은 삭제하는 것이 좋다.<br/>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_02_04</rule>
    <ruleTitle><![CDATA[사용되지 않은 tag(struct, union, enum) 선언은 없어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
C 표준에서 struct, union, enum을 tag라고 부른다.<br/>
tag가 선언되었지만 사용되지 않는다면, 이는 여분으로 남겨둔 건지 아니면 실수로 사용되지 않는 채로 남아 있는 것인지 리뷰어에게 명확하지 않으므로 삭제하는 것을 권장한다.<br/>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_02_05</rule>
    <ruleTitle><![CDATA[사용되지 않은 매크로 선언은 없어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
매크로가 선언되었지만 사용되지 않는다면, 이는 여분으로 남겨둔건지 아니면 실수로 사용되지 않은 채로 남아있는 것인지 리뷰어에게 명확하지 않으므로 삭제하는 것을 권장한다.<br/>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_02_06</rule>
    <ruleTitle><![CDATA[함수 내에 사용되지 않은 레이블(label) 선언은 없어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
레이블이 선언되었지만 사용되지 않는다면, 이는 여분으로 남겨둔건지 아니면 실수로 사용되지 않은 채로 남아있는 것인지 리뷰어에게 명확하지 않으므로 삭제하는 것을 권장한다.<br/>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_02_07</rule>
    <ruleTitle><![CDATA[함수에서 사용되지 않은 파라미터는 없어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
만일 함수 파라미터가 사용되지 않으면, 함수의 구현과 그 명세 내용이 맞지 않을 가능성이 있다. 이 규칙은 이러한 잠재적인 불일치를 방지하기 위한 가이드라인이다.<br/>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_03_01</rule>
    <ruleTitle><![CDATA[문자열 /*와 //는 주석 안에서 사용하지 말아야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
주석 시작 문자열인 /*, //가 C 스타일 주석인 /* */ 안에서 사용되면, 주석 끝 문자열인 */를 사용하지 않고 지나칠 수 있다.<br/>
또한, 주석 시작 문자열이 // 주석 안에서 사용되면, 코드 영역이 주석처리 될 수 있다.<br/>
단, 문자열 "//"를 // 주석 안에서 사용하는 것은 허용한다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Dir 4.4<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_03_02</rule>
    <ruleTitle><![CDATA[행 접합(Line-splicing)은 // 주석 내에서 사용하면 안 됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C99<br/><br/>
Line-splicing은 newline 문자 뒤에 \ 문자가 붙어서 나올 때 발생한다.<br/>
만일 // 주석을 포함하는 소스 라인이 \ 문자로 끝난다면, 다음 라인도 주석의 일부로 포함된다. 이로 인해, 의도하지 않게 코드가 삭제될 수 있다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Dir 4.4<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_04_01</rule>
    <ruleTitle><![CDATA[8진수, 16진수 escape 시퀀스에 다른 escape 시퀀스 외에는 붙이면 안 됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
8진수 또는 16진수 escape 시퀀스 뒤에 다른 문자열이 붙으면 혼동이 올 수 있다. 따라서 escape 시퀀스끼리만 붙여 사용하는 것이 좋다.<br/>
예를 들어, 문자 상수 '\x1f'는 하나의 문자로 구성되어 있지만, 문자 상수 '\x1g'는 두 문자 'x1' 과 'g'로 구성되어 있다.<br/>
모든 8진수 또는 16진수 escape 시퀀스들을 "\x41g" 대신 "\x41" "g"처럼 별도의 문자열 상수로 끊어서 기록하면 혼동의 가능성은 줄어든다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;C90: Section 6.1.3.4, C99: Section 6.4.4.4<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_04_02</rule>
    <ruleTitle><![CDATA[Trigraph는 사용하면 안 됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
Trigraph는 두 개의 물음표 뒤에 문자가 하나 더 붙어서 만들어진다. 예를 들어, '??- '는 '~' 를, '??)'는 ']'를 나타낸다.<br/>
이들은 다른 의미로 두 개의 물음표를 사용했을 때 의도치 않게 혼동을 가져온다.<br/>
예를 들어,<br/>
"(Date should be in the form ??-??-??)"<br/>
이 문자열을 trigraph로 처리하면,<br/>
"(Date should be in the form ~~]"<br/>
이렇게 처리된다.<br/>
대부분의 컴파일러들은 trigraph를 옵션 처리하여 위의 ??-??-?? 문자열을 trigraph로 처리하지 않고 있는 그대로 해석할 수 있다. 컴파일러에 따라 기본 동작이 차이가 날 수 있으므로, 가능한 trigraph로 해석될 수 있는 문자열은 사용하지 않는 것이 좋다.<br/><br/>
참고로 다음을 digraph라고 한다:<br/>
<: &nbsp;:> &nbsp;<%&nbsp; %>&nbsp; %: &nbsp; %:%:</br>
위와 같은 digraph는 token이기 때문에 허용한다.<br/>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_05_01</rule>
    <ruleTitle><![CDATA[외부 식별자는 구별되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
이 규칙은 컴파일러 자체 번역 제한(translation limits) 내에서 외부 식별자가 구별되어야 함을 말한다.<br/>
"구별됨"의 정의는 컴파일러마다, 그리고 언어 표준 버전에 따라 다를 수 있다. 대부분의 컴파일러들은 외부 식별자를 최소 31자 이상, 대소문자 구분하여 비교했을 때 구별되어야 한다고 정의한다.<br/>
만약 두 식별자가 중요 문자 안에서 차이가 없으면, 정의하지 않은 행동을 일으킬 수 있다.<br/>
이식성이 중요하다면, 현재 사용 중인 컴파일러보다 표준에서 정의한 최소한의 제한을 따르는 것이 안전하다.<br/>
너무 긴 식별자는 가독성을 저하시킨다. 자동으로 생성한 코드는 긴 식별자를 가지기 쉬운데, 가능하면 식별자 길이를 표준에서 정의하는 제한하는 것이 좋다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Dir 1.1, Rule 5.2, Rule 5.5<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_05_02</rule>
    <ruleTitle><![CDATA[같은 scope 혹은 namespace에 선언된 식별자는 구별되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
이 규칙은 외부 식별자끼리 비교하는 것은 Rule 5.1에서 검사하므로 제외한다.<br/>
그리고 둘 중 하나가 매크로 식별자인 경우에도 Rule 5.4와 Rule 5.5에서 검사하므로 제외한다.<br/>
"구별됨"의 정의는 컴파일러마다, 그리고 언어 표준 버전에 따라 다를 수 있다. 대부분의 컴파일러들은 외부 식별자를 최소 31자이상, 대소문자 구분하여 비교했을 때 구별되어야 한다고 정의한다.<br/>
만약 두 식별자가 중요 문자 안에서 차이가 없으면, 정의하지 않은 행동을 일으킬 수 있다.<br/>
이식성이 중요하다면, 현재 사용 중인 컴파일러보다 표준에서 정의한 최소한의 제한을 따르는 것이 안전하다.<br/>
너무 긴 식별자는 가독성을 저하시킨다. 자동으로 생성한 코드는 긴 식별자를 가지기 쉬운데, 가능하면 식별자 길이를 표준에서 정의하는 제한하는 것이 좋다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Dir 1.1, Rule 5.1, Rule 5.3, Rule 5.4, Rule 5.5<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_05_03</rule>
    <ruleTitle><![CDATA[내부 영역(inner scope)의 식별자를 외부 영역(outer scope)의 식별자가 가리면 안 됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
내부 영역의 식별자는 어떤 외부 영역의 식별자와도 구별할 수 있어야 한다.<br/>
"구별됨"의 정의는 컴파일러마다, 그리고 언어 표준 버전에 따라 다를 수 있다. 대부분의 컴파일러들은 외부 식별자를 최소 31자이상, 대소문자 구분하여 비교했을 때 구별되어야 한다고 정의한다.<br/>
안쪽 scope에 선언된 식별자가 바깥 scope에 선언된 식별자와 구별되지 않으면, 가장 안쪽의 식별자 선언은 가려지게(hide) 된다. 이는 개발자에게 혼란을 준다.<br/>
참고록 서로 다른 name space 에 있는 식별자 끼리는 서로 가리지 않는다.<br/>
안쪽(inner)와 바깥(outer) scope는 다음과 같이 설명할 수 있다.<br/>
- file scope 는 가장 바깥이다.<br/>
- 블록 scope가 더 안쪽이다.<br/>
- 연속, 중첩된 블록들은 더 안쪽이다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 5.2, Rule 5.8<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_05_04</rule>
    <ruleTitle><![CDATA[매크로의 식별자는 구별되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
전처리 전에 존재하는 매크로 이름들과 전처리 후 남아 있는 식별자들은 구별되어야 한다. scope나 namespace에 무관하게 모든 매크로 이름들과 식별자들에 적용된다.<br/>
"구별됨"의 정의는 컴파일러마다, 그리고 언어 표준 버전에 따라 다를 수 있다. C90에서는 처음 31자, C99에서는 처음 63자를 중요(significant)하다고 정의하지만, 실제로 많은 컴파일러들이 더 긴 중요 문자로 구별한다.<br/>
매크로 이름과 식별자를 구별하는 것은 개발자의 혼란을 막을 수 있다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 5.1, Rule 5.2, Rule 5.4<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_05_05</rule>
    <ruleTitle><![CDATA[식별자는 매크로 이름과 구별되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
매크로가 정의될 때 그 이름이 다른 정의된 매크로 이름들과 자기 자신의 파라미터 이름들과 구별되어야 한다. 또한 하나의 함수형 매크로에서 파라미터 이름들 끼리도 구별되어야 한다. 서로 다른 매크로들 간에 파라미터 이름은 구별되지 않아도 된다.<br/>
"구별됨"의 정의는 컴파일러마다, 그리고 언어 표준 버전에 따라 다를 수 있다. C90에서는 처음 31자, C99에서는 처음 63자를 중요(significant)하다고 정의하지만, 실제로 많은 컴파일러들이 더 긴 중요 문자로 구별한다.<br/>
만약 두 매크로 식별자가 중요 문자 안에서 차이가 없으면, 정의하지 않은 행동을 일으킬 수 있다. 매크로 파라미터는 그 매크로가 확장될 때만 유효하므로 다른 매크로의 파라미터들과 혼동될 가능성은 없다.<br/>
이식성이 중요하다면, 현재 사용 중인 컴파일러보다 표준에서 정의한 최소한의 제한을 따르는 것이 안전하다.<br/>
너무 긴 매크로 식별자는 가독성을 저하시킨다. 자동으로 생성한 코드는 긴 식별자를 가지기 쉬운데, 가능하면 식별자 길이를 표준에서 정의하는 제한하는 것이 좋다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 5.1, Rule 5.2, Rule 5.5<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_05_06</rule>
    <ruleTitle><![CDATA[typedef 이름은 유일한 식별자여야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
typedef 이름은 모든 namespace와 translation unit들에서 유일해야 한다. 헤더 파일에서 한 typedef 이름으로 타입을 정의하고 그 헤더 파일을 여러 파일에서 include 해서 사용할 때만 중복해서 선언하는 것을 허용한다.<br/>
typedef 이름을 다른 typedef 이름이나 함수 이름, 변수 이름, enum 상수 이름으로 사용하면 개발자에게 혼란을 줄 수있다.<br/>
단, typedef struct list { ... } list; 처럼 struct, union, enum을 선언할 때 동일한 이름으로 typedef하는 것은 허용된다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 5.7<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_05_07</rule>
    <ruleTitle><![CDATA[tag(struct, union, enum) 이름은 유일한 식별자여야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
tag는 모든 namespace와 translation unit에서 유일해야 하며, 모든 같은 이름의 tag 선언은 동일한 타입이어야 한다. 헤더 파일에 tag 를 선언하고 그 헤더 파일을 여러 파일에서 포함하여 사용할 때만 tag 를 중복선언하는 것을 허용한다.<br/>
tag 이름을 재사용하면 개발자에게 혼란을 줄 수 있다.<br/>
또한 tag 이름을 재사용하는 것은 정의하지 않은 행동이기도 하다. 이 제약은 C90에서는 식별되지 않았으나 C99에는 포함되어 있다(Section 6.7.2.3).<br/>
단, typedef struct list { ... } list; 처럼 struct, union, enum을 선언할 때 동일한 이름으로 typedef하는 것은 허용된다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 5.6<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_05_08</rule>
    <ruleTitle><![CDATA[외부 연결을 갖는 변수나 함수 식별자는 유일해야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
외부 연결을 갖는 식별자는 어떤 namespace나 translation unit에서도 다른 목적으로 사용되면 안 된다. 이런 식으로 식별자 이름의 유일성을 강조하면 개발자의 혼란을 막을 수 있다.<br/>
연결(linkage) 정보가 없는 지역 변수 식별자는 이런 혼란의 위험 요소가 적으므로 유일하지 않아도 된다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 5.3<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_05_09</rule>
    <ruleTitle><![CDATA[내부 연결을 갖는 변수나 함수 식별자는 유일해야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
식별자 이름은 모든 name space와 translation unit에서 유일해야 한다. 연결(linkage) 정보가 없는 지역 변수 식별자들도 유일해야 한다. 이런 식으로 식별자 이름의 유일성을 강조하면 개발자의 혼란을 막을 수 있다.<br/>
단, 내부 연결을 갖는 inline 함수를 하나의 헤더 파일에서 정의해서 여러 translation unit에서 include해서 사용하는 것은 허용된다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 8.10<br/>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_06_01</rule>
    <ruleTitle><![CDATA[bit-field는 올바른 타입으로 선언되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
올바른 bit-field 타입은 다음과 같다: <br/>
- C90 : unsigned int 또는 singed int<br/>
- C99 : 다음 중 하나:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* unsigned int 또는 signed int<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* 컴파일러가 제공하는 다른 명시적인 부호가 있는 integer 타입<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* _Bool<br/><br/>
int는 컴파일러에 따라 signed일 수도 있고 unsigned일 수도 있기 때문에 int를 사용하는 것은 컴파일러에 따라 다르다.<br/>
enum, short, char 나 다른 타입의 bit-field 는 C90에서 정의하지 않은 행동이므로 허용되지 않는다.<br/>
C99에서는 bit-field 선언에서 다른 integer 타입을 사용하는 것을 허용한다.<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_06_02</rule>
    <ruleTitle><![CDATA[single-bit로 표현된 이름있는 bit-field는 signed면 안 됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
C99 표준 Section 6.2.6.2에 따르면, single-bit signed bit-field는 부호 bit만 있고 값을 표현하는 bit이 없다. 이는 어떤 정수 값 표현에서도 의미있는 값이 아니다.<br/>
따라서 single-bit signed bit-field는 유용하게 사용될 가능성이 낮고, 개발자의 혼란을 야기시킨다.<br/>
C90 표준에서는 자세한 언급이 없으나, C99와 동일하게 적용 가능하다.<br/>
참고로 이름 없는 bit-field는 그 값에 접근할 수 없으므로 위배로 검출하지 않는다.<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_07_01</rule>
    <ruleTitle><![CDATA[8진수 상수는 사용하면 안 됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
개발자들이 0으로 시작하는 상수를 기록할 때는 일반적으로 10진수를 의도한 경우가 많다. 그러나 0으로 시작하는 상수는 8진수이므로 개발자의 의도와 다른 값이 사용될 수 있다.<br/>
따라서 0으로 시작하는 8진수 상수를 사용하지 않는 것이 안전하다. escape 시퀀스로 기록하는 것은 10진수와 혼동할 가능성이 낮으므로 허용된다.<br/>
상수 0은 엄밀히 말하면 8진수 상수이다. 그러나 여기서는 위배로 검출하지 않는다.<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_07_02</rule>
    <ruleTitle><![CDATA[unsigned integer 상수에는 접미사 "u"나 "U"를 붙여야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
이 규칙은 전처리 지시자 중 #if, #elif에 사용된 integer 상수와 전처리 후 존재하는 모든 integer 상수에 적용된다.<br/>
다음과 같은 복잡한 원인 때문에 정수형 상수의 타입을 혼동하기 쉽다.<br/>
- 상수의 자릿수(magnitude)<br/>
- 컴파일러에서 정의한 integer 타입 크기<br/>
- 접미사의 존재<br/>
- 진수(10진수, 8진수, 16진수)<br/>
예를 들면, 40000은 32 비트 환경에서는 signed int 이지만 16 비트 환경에서는 signed long 이다. 0x8000은 16비트 환경에서는 unsigned int 이지만 32비트 환경에서는 signed int 이다.<br/>
- 접미사 "U" 가 붙은 상수는 unsigned 타입이다.<br/>
- 2<sup>31</sup> 보다 작고 접미사가 없는 10진수 값은 signed 타입이다.</br>
- 2<sup>15</sup> 보다 크고 접미사가 없는 16진수 값은 signed 혹은 unsigned 타입이다.</br>
- C90에서 2<sup>31</sup> 보다 크거나 같고 접미사가 없는 10진수 값은 signed 혹은 unsigned 타입이다.<br/><br/>

상수의 부호는 명확해야 한다. 만일 unsigned 타입 상수에 접미사 "U"를 붙이면 그 상수는 unsigned 타입이라는 것을 분명하게 알 수 있다.<br/>
이 규칙은 상수가 사용되는 문맥과 무관하다. integer promotion이나 다른 어떤 변환이 발생하더라도 이 규칙을 검사하는 것과는 무관하다.<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_07_03</rule>
    <ruleTitle><![CDATA[소문자 접미사 "l" 은 사용하면 안 됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
접미사 대문자 "L"을 써야 "1(숫자 1)" 이나 "ㅣ(문자 "el")"과 구분하기 쉽다.<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_07_04</rule>
    <ruleTitle><![CDATA[문자열을 const char * 타입이 아닌 객체에 할당하면 안 됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
문자열 상수를 변경하는 것은 정의되지 않은 동작을 일으킬 수 있다. 예를 들어 어떤 컴파일러는 문자열 상수를 read-only 메모리에 저장하는데, 이런 경우 런타임에 예외나 crash가 발생할 수 있다.<br/>
따라서 const char *로 선언한 변수에 할당해서, 값을 변경하지 못하도록 하는 것이 안전하다. 또한 & 연산의 결과는 const char(*)[] 타입 변수에 할당해야 안전하다.<br/>
wide 문자열도 마찬가지이다. wide 문자열을 const wchar_t * 타입이 아닌 변수에 할당하면 안 된다.<br/>
C99 표준에 문자열 저장 위치에 대해 명시되어 있지 않으므로 문자열을 성공적으로 바꾼 것 같아도 다른 문자열이 의도하지 않게 수정될 수도 있다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 11.4, Rule 11.8<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_08_01</rule>
    <ruleTitle><![CDATA[타입은 명시적으로 입력해야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90<br><br>

 C90 표준은 상황에 따라 타입을 명시하지 않아도 int 타입으로 인식한다. 이러한 상황의 예로는 다음이 있다.</br></br>
- 객체 선언</br>
- 파라미터 선언</br>
- 멤버 선언</br>
- typedef 선언</br>
- 함수 반환 타입</br></br>
명시적으로 타입을 입력하지 않으면 혼란을 줄 수 있다. 예를 들어, 다음의 선언</br></br>
extern void g ( char c, <b>const k</b> );</br></br>
에서 <b>k</b>의 타입은 <b>const char</b>를 기대하는 것과는 달리 <b>const int</b> 이다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 8.2<br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_08_02</rule>
    <ruleTitle><![CDATA[함수는 이름 있는 파라미터로 구성된 프로토타입 형태여야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

인자(argument)와 매개변수(parameter) 간의 타입, 그리고 함수의 리턴 타입과 실제 리턴 타입의 불일치는 정의되지 않은 결과를 발생시킨다. <br/><br/>

이 규칙과 [MISRA_C_2012_08_01], [MISRA_C_2012_08_04] 의 목적은 매개변수 타입과 함수 리턴 타입을 명시적으로 입력해서 이러한 미정의된 특성을 피하는 것이다.</br></br>

또한, 이 규칙은 선언 시에 모든 매개변수의 이름을 명시하도록 요구한다. 매개변수의 이름은 함수 인터페이스에 관한 정보를 제공할 수 있고, 컴파일러가 선언과 정의간의 불일치와 관련된 경고를 출력할때, 더 자세한 정보를 제공할 수 있게 한다.</br></br>

참고: 함수의 파라미터가 없는 경우에 void 를 명시해야한다. C90/99 에서 <b>int f();</b> 의 의미는 함수 인자의 개수와 타입을 모르는 경우에 사용하고, <b>int f(void);</b> 는 인자가 없음을 의미한다. C++ 에서는 <b>int f();</b> 와 <b>int f(void);</b> 동일한 의미를 갖는다.<br/><br/>

관련 링크: <a href="http://david.tribble.com/text/cdiffs.htm#C99-empty-parm">http://david.tribble.com/text/cdiffs.htm#C99-empty-parm</a>

<br/><span style="color:#B73232">See also</span>&nbsp;Rule 8.1, Rule 8.4, Rule 17.3<br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_08_03</rule>
    <ruleTitle><![CDATA[동일한 객체 또는 함수의 모든 선언은 같은 이름과 타입 한정자를 사용해야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

객체 또는 함수를 선언하거나 정의할 때, 타입과 한정자(const, volatile등)는 모든 선언과 정의에서 같아야 한다.</br></br>

함수 선언시에 파라미터 이름을 명시하면, 컴파일러에 의해 함수 정의와 함수 선언간의 인터페이스의 동일성을 검사할 수 있는 기회를 줄 수 있다.</br></br>

<b> 예외 : 같은 기본 타입이 호환 가능하면 아래 처럼 사용할 수 있다.</b>
<textarea id="ex1" >
    extern void f(signed int);
           void f(       int);   /* 타입 호환되므로 예외 */
    extern void g(int * const);
           void g(int *      );  /* 위배: 한정자 불일치  */           

</textarea>
<script>CodeMirror.fromTextArea(document.getElementById('ex1'));</script>
<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 8.4<br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_08_04</rule>
    <ruleTitle><![CDATA[객체나 함수의 정의 또는 호출 이전에 호환가능한 선언이 존재해야함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

함수나 객체가 정의되었을 때 그 객체나 함수에 대한 선언이 있다면 컴파일러는 반드시 그 선언과 정의가 호환가능한지 확인한다. <br/><br/>

함수의 프로토타입은 [MISRA_C_2012_08_02] 의 요구에 따라 존재해야 하며, 컴파일러는 함수 파라메터의 타입과 파라메터의 개수까지 일치하는지 확대 적용된다.</br></br>

추천하는 방법은 external 연결을 갖는 객체나 함수선언들은 헤더파일 내에 위치 시킨 후, 해당 함수나 객체가 필요한 모든 코드파일(.c) 내에 해당 헤더파일(.h)을 포함(include)시켜 사용하도록 한다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 8.2, Rule 8.3, Rule 8.5, Rule 17.3<br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_08_05</rule>
    <ruleTitle><![CDATA[외부연결(external linkage)을 갖는 객체나 함수는 오직 하나의 파일에서만 선언되어야함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

이 규칙은 정의가 아닌 선언에만 적용된다.<br/><br/>

일반적으로 선언은 헤더파일에 있고, 이 헤더 파일을 각 코드파일(.c) 에서 포함하여 사용할 것이다. 이것은 다음의 일관성을 보장한다:<br/>
 - 선언과 정의<br/>
 - 다른 번역단위(translation unit)들 안에서의 선언<br/><br/>

참조: 프로젝트 내에 많은 헤더파일이 있지만 각각의 external 객체나 함수는 하나의 헤더파일에만 선언되어야 한다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 8.4<br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_08_06</rule>
    <ruleTitle><![CDATA[외부연결 식별자는 하나의 외부정의(external definition)를 가져야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

여러 개의 정의를 가졌거나(각각 다른 파일 내에서) 정의가 존재하지 않으면 일반적으로 링킹시에 오류가 발생하며, 오류가 발생하지 않더라도 정의되지 않은 결과가 발생한다.<br/><br/>

각각 다른 파일 내에서의 동일한 식별자로 정의된 객체나 함수는 내용이 똑같다고 하더라도 허용되지 않는다(one definition rule 위반). 선언이 다르거나 초기화가 다르더라도 이는 정의되지 않은 결과를 발생시킨다.<br/><br/>

<b><font color="red">주의:</font></b> 이 결함은 하나의 인스펙터 프로젝트에 서로 다른 링크단위의 프로젝트를 같은 모듈 구성에 포함하는 경우에 발생할 수 있으며, 이 경우 잘못된 탐지가 발생 될 수 있다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_08_07</rule>
    <ruleTitle><![CDATA[함수나 객체가 하나의 번역단위에서 참조된다면 외부참조(external linkage)로 정의되면 안됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

객체를 내부연결(internal linkage)로 정의하여 가시성을 제한하는 것은 실수로 접근될 가능성을 줄여준다.
유사하게 함수를 내부연결로 정의하여 가시성을 제한하는 것 또한 실수로 호출되는 가능성을 줄여준다.</br></br>
이 규칙을 준수하는 것은 다른 Translation Unit이나 라이브러리에서의 동일한 식별자 사이에 혼동의 가능성을 줄여준다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_08_08</rule>
    <ruleTitle><![CDATA[내부 연결(internal linkage)을 갖는 모든 객체 또는 함수는 static 을 이용해야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

객체나 함수가 extern으로 선언되어있지만, 이전에 그 객체나 함수의 static 선언이 이미 있다면, 이 경우 extern 지정자가 외부연결을 생성하기때문에 혼란을 일으킬 수 있다. 그러므로 static 지정자는 내부연결을 가지는 함수와 객체에 일관성있게 적용되어야 한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_08_09</rule>
    <ruleTitle><![CDATA[단일 함수에만 쓰이는 객체는 해당 블록범위에서 정의되어야 한다.]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

함수 내에서 객체가 블록 밖에 정의되느냐 내부에 정의되느냐 하는 것은 코딩 스타일의 문제로, 블록 범위에 객체를 정의하는 것은 실수로 접근되는 것은 줄여주고 그 객체가 다른 곳에서 접근되지 말아야 한다는 의도를 명백히 한다.<br/><br/>

하지만, 이 규칙을 준수하는 것이 불가능한 상황이 있을수 있다. 예를들어, 블록 내부에 static 으로 선언된 객체는 외부에서 직접 접근할 수 없다. 이 경우 객체를 포인터를 이용하여 접근하는 방법을 사용할 수 있을텐데. 효과적이지 못하다. 이러한 상황에서는 이 규칙을 적용하지 않는 것을 더 좋을 수 있다.<br/><br/>

<b>이러한 경우,</b> "위배 무시하기" 기능이나 규칙모음에서 해당 규칙을 제외할 수 있다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_08_10</rule>
    <ruleTitle><![CDATA[인라인 함수는 static으로 선언되어야 한다.]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C99<br><br>

인라인 함수가 외부 연결로 선언되었지만 같은 컴파일단위(translation unit)내에 정의되어있지 않다면 결과는 정의되지 않은 행동을 유발한다.<br/><br/>

외부 연결로 선언된 인라인 함수 호출시, 내부 인라인 함수정의를 사용하거나, 외부함수를 호출할 수도 있다. 비록  이것이 함수호출 자체에는 영향이 없다고 하더라도,
리얼타임 프로그램을 실행할때 미묘한 타이밍에 영향을 미칠것이다.<br/><br/>

<b>참고</b> 인라인 함수가 여러 컴파일 단위에서 사용된다면, 정의를 헤더파일에 위치시킬 수 있다.
<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 5.9<br>
]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_08_11</rule>
    <ruleTitle><![CDATA[배열에 대한 외부연결(external linkage) 선언 시, 그 크기를 명시적으로 해야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

비록 불완전한 타입으로 배열을 선언하고 요소들에 접근하는 것이 가능하다고 하더라도, 배열의 크기가 명시적으로 기술되어 있을 때 더 안전하다.
각 선언마다 크기를 명시적으로 지정하는 것은 그 배열들이 바르게 사용되고 있는지를 일관성있게 확인할 수 있도록 해준다. 또한 정적분석기가 한 개 이상의 컴파일 단위(translation unit)을 분석할 필요 없이 배열범위 분석을 할 수 있게 해준다.<br/><br/>

<b>이 규칙은 전역변수 배열 선언에만 적용된다.</b>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_08_12</rule>
    <ruleTitle><![CDATA[열거자 리스트 내에서 묵시적으로 지정된 열거형 상수의 값은 유일해야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

묵시적으로 지정된 열거형 상수는 바로 직전 열거형 상수보다 1만큼 큰 값을 가진다. 만약 첫번째 열거형 상수의 값이 묵시적으로 지정되었다면 그 값은 0이다.</br></br>
명시적으로 지정된 열거형 상수는 지정된 값을 그대로 가진다. 만약, 묵시적인 열겨형 상수와 명시적인 열거형 상수가 섞여있다면 그 값이 중복되는 것이 가능하다. 보통의 경우 이러한 중복은 코드 수정에 따른 의도하지 않은 것일 수 있고, 이로 인해 프로그램이 기대하지 않은 행동을 발생시킬수 있다.</br></br>
이 규칙은 열거형 상수값의 복제가 명시적으로 이루어 지는 것을 요구하며 이로 인해 그 의도를 명백히 하려 함에 목적이 있다.
]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_08_13</rule>
    <ruleTitle><![CDATA[가능하다면 포인터는 const 로 한정된 타입을 가리켜야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

이 규칙을 준수하는 것은 프로그램 실수로 인해 포인터를 통해 객체의 상태를 변형하지 못하도록 보증하는 최선의 방법이다.</br></br>

다음과 같은 상황은 제외한다.</br></br>
 - 객체를 변형하기 위해 사용</br>
 - 아래에 해당하는 것을 이용하여 const 가 아닌 타입을 가리키는 또 다른 포인터를 복사할때</br>
&nbsp;&nbsp;&nbsp;&nbsp;+ 할당</br>
&nbsp;&nbsp;&nbsp;&nbsp;+ 메모리 이동 또는 함수 복사</br></br>

이 규칙은 포인터와 포인터가 가리키는 타입에 관하여 설명하나, 배열과 배열이 포함하는 요소의 타입에 대해서 동일하게 적용된다.
다음의 경우를 제외하면 배열은 const 인 요소들을 가져야 한다.</br></br>
 - 배열의 요소를 변형</br>
 - 위에 해당하는 것을 이용하여  const 가 아닌 타입을 가리키는 또 다른 포인터를 복사할때</br></br>

]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_08_14</rule>
    <ruleTitle><![CDATA[restrict 사용금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C99<br><br>

restrict 한정자는 포인터에 쓸 수 있으며, restrict가 붙은 포인터가 참조하는 데이터는 이 포인터로만 접근이 가능하고 다른 포인터는 접근이 불가능하다.
이 키워드는 컴파일러로 하여금 이 포인터는 다른 포인터를 통해 변경되지 않는다는 걸 전제로하여 최적화를 수행할 수 있게 해준다.
하지만 restrict타입을 사용하기 위해 개발자는 메모리 영역에서 두개 이상의 포인터가 중복되지 않음을 반드시 보장하여야 한다.</br></br>
만약, 개발자가 restrict에 대한 의미를 정확하게 보장하지 않는다면, 컴파일러는 임의로 최적화를 시도할 것이고, 이로인해 기대하지 않는 코드(코드의 순서를 임의로 변경 등)를 생성할 수 있다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_09_01</rule>
    <ruleTitle><![CDATA[모든 변수는 읽기 전에 할당되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

표준에 따르면, static 변수의 저장 공간은 초기화 해주지 않으면 자동으로 0으로 초기화가 된다. 하지만 일반 변수는 자동으로 초기화 되지 않는다. </br></br>
참조 : 변수에 대한 명시적 초기화가 무시되는 경우가 있을 수 있다. goto문이나 switch문의 사용으로 객체의 선언문을 통과하는 경우에 발생할 것이다.</br></br>

<b>이 규칙의 목적을 위해서, 배열이나 구조체의 멤버 또한 하나의 분리된 객체로 고려해야 한다.</b>
<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 15.1, Rule 15.3<br>]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_09_02</rule>
    <ruleTitle><![CDATA[배열, 구조체, 유니온 타입의 초기화는 중괄호('{ }') 로 둘러쌓여야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<b>이 규칙은 객체와 하위객체에 모두 적용된다.</b> { 0 } 형태의 초기화는 대상의 모든 객체를 0으로 설정하는데 사용되며, 이 경우 하위 객체를 초기화 하기 위해 중괄호를 사용하지 않아도 된다.<br/><br/>
<b>참고</b> 이 규칙은 객체나 하위 객체의 명시적 초기화를 요구하지 않으며, 초기화가 아예 없는 코드에는 적용되지 않는다.<br/><br/>

하위 객체의 초기화를 위해 중괄호를 사용하는 것은 코드의 명확성을 향상시키고 개발자가 다차원 배열이나 구조체의 배열과 같은 복잡한 자료구조에서의 초기화를 고려하도록 해준다.</br></br>

<b>예외사항</b></br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 문자열 상수을 사용하여 배열을 초기화 하는 경우</br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 호환되는 구조체나 유니온 표현식을 이용해서 구조체나 유니온을 초기화하는 경우</br>
&nbsp;&nbsp;&nbsp;&nbsp;3. <b>지정 초기화(designated initializer)</b> 를 이용하여 객체의 일부를 초기화하는 경우</br>
<br/>
<br/>
<b>예제</b><br/>
<textarea id="ex1">
int16_t y[3][2] = { 1,2,0,0,5,6 };       /* 위배 */
int16_t y[3][2] = { {1,2},{0,0},{5,6} }; /* 옳음 */
int16_t y[3][2] = { {1,2,0},{0,5,6} };   /* 옳음 */

struct s1 {
  uint16_t len;
  char buf[8];
} s[3] = {
   { 5u, {'a','b','c','d','e','\0','\0','\0'} },
   { 2u, {0} },                          /* 옳음 */
   { .len = 0u }                         /* 옳음 - 예외 3*/
};
</textarea>

<script>CodeMirror.fromTextArea(document.getElementById('ex1'));</script>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_09_03</rule>
    <ruleTitle><![CDATA[배열은 일부분만 초기화 되면 안됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

배열이나 객체의 일부 요소가 명시적으로 초기화 되면 안된다. 반드시 전체 요소가 명시적으로 초기화 되어야 한다.</br></br>

배열의 모든 요소를 명시적 초기화 하는 것은 모든 요소가 고려되었다는 것을 명확히 할 수 있다.</br></br>

<b>예외사항</b></br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 배열의 모든 하위 요소를 명시적으로 초기화 하기위해 사용된 { 0 } 형태의 초기화문</br>
&nbsp;&nbsp;&nbsp;&nbsp;2. <b>지정 초기화(designated initalizer)</b>로만 배열의 일부가 초기화된 경우</br>
&nbsp;&nbsp;&nbsp;&nbsp;3. 문자열 리터럴을 사용하여 초기화 된 배열</br></br>


<b>예제</b></br>
<textarea id="ex1">
int32_t x[3] = {0, 1};                        /* 위배 */
float32_t z[50] = { [1] = 1.0f, [25] = 2.0f } /* 옳음 - 예외 2 */
float32_t z[50] = { [1] = 1.0f, 2.0f }        /* 위배 - 예외 2 에 맞지 않음 */
</textarea>
<script>CodeMirror.fromTextArea(document.getElementById('ex1'));</script>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_09_04</rule>
    <ruleTitle><![CDATA[객체의 요소 두 번 이상 초기화 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C99<br><br>

<b>이 규칙은 객체와 하위 객체 모두에 대하여 적용한다.</b></br>

C99 표준의 지정 초기화(designated initializers) 규정에서는 집합체(배열 또는 구조체)의 요소에 대한 구조체 필드의 이름을 사용하는 것을 허용하고, 배열의 특정 인덱스를 지정하여 초기화하는 것을 허용한다.</br><br/>

지정 초기화를 사용할 때는 요소의 초기화가 이전의 초기화로 인하여 실수로 덮어씌워질 수 있기 때문에 주의해야한다. C99표준에서는 중복된 초기화문에 대한 부작용을 기술하지 않음으로 컴파일러마다 다른 특성을 가지게 된다(앞선 지정 초기화가 우선일지, 뒤에 나온 지정 초기화가 우선인지 미정의됨). </br>
]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_09_05</rule>
    <ruleTitle><![CDATA[지정 초기화(designated initializer)가 사용된 배열은 그 크기가 명시적이어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C99<br><br>

배열의 크기가 묵시적이면, 지정 초기화로 명시된 요소중 가장 높은 인덱스로 그 크기가 결정되는데, 지정 초기화문을 사용 할때 항상 가장 높은 인덱스의 초기화문을 필수로 기술하지 않는다. 이 때문에, 이후 이 배열을 사용할때, Buffer Overflow 같은 문제를 발생시킬 수 있다.
배열의 크기와 관련된 명확한 정보 제공을 위해서, 이런 경우 배열의 크기는 명시적으로 선언되어야 한다.

]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_10_01</rule>
    <ruleTitle><![CDATA[부적절한 essential 타입의 피연산자를 사용하지 않아야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>


아래 표는 연산자와 피연산자의 essential 타입에 대한 위배 내용을 나타낸다.<br/><br/>

<center>
<table align="center" border="1" cellpadding="6">
<tr align="center" >
<td rowspan="2">Operator</td><td rowspan="2">Operand</td><td colspan="6">Essential type category of arithmentic operand</td>
</tr>

<tr align="center" >
<td>Boolean</td><td>character</td><td>enum</td><td>signed</td><td>unsigned</td><td>floating</td>
</tr>

<tr align="center">
<td>[ ] </td><td>integer</td><td>3</td><td>4</td><td></td><td></td><td></td><td>1</td>
</tr>

<tr align="center">
<td>+ (unary)</td><td></td><td>3</td><td>4</td><td>5</td><td></td><td></td><td></td>
</tr>

<tr align="center">
<td>- (unary)</td><td></td><td>3</td><td>4</td><td>5</td><td></td><td>8</td><td></td>
</tr>

<tr align="center">
<td>+ -</td><td>either</td>
<td>3</td>
<td></td>
<td>5</td>
<td></td>
<td></td>
<td></td>
</tr>

<tr align="center">
<td>* /</td><td>either</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td></td>
<td></td>
<td></td>
</tr>

<tr align="center">
<td>%</td>
<td>either</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td></td>
<td></td>
<td>1</td>
</tr>

<tr align="center">
<td>< > <= >=</td><td>either</td>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr align="center">
<td>== !=</td><td>either</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr align="center">
<td>! && ||</td><td>any</td>
<td></td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>

<tr align="center">
<td><< >></td><td>left</td>
<td>3</td>
<td>4</td>
<td>5,6</td>
<td>6</td>
<td></td>
<td>1</td>
</tr>

<tr align="center">
<td><< >></td><td>right</td>
<td>3</td>
<td>4</td>
<td>7</td>
<td>7</td>
<td></td>
<td>1</td>
</tr>

<tr align="center">
<td>~ & | ^</td><td>any</td>
<td>3</td>
<td>4</td>
<td>5,6</td>
<td>6</td>
<td></td>
<td>1</td>
</tr>

<tr align="center">
<td>?:</td><td>1st</td>
<td></td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>

<tr align="center">
<td>?:</td><td>2nd and 3rd</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>


</table>
</center>
<br/>
<p>
<b>각 숫자의 위배 내용</b><br/><br/>
1. essential 타입이 floating인 표현을 []의 내부, %, <<, >>에 사용하는 것은 constraint 위반이다</br>
2. !, &&, ||, 그리고 ?: 연산자의 첫번 째 피연산자는 피연산자가 Boolean value로 처리되기 때문에 essential 타입이 Boolean인 표현만 사용되어야 한다.</br>
3. essential 타입이 Boolean인 표현은 산술 값으로 변환되는 연산자인 [], unary +, unary -, +, -, *, /, %, <, >, <=, >=, <<, >>, ~, &, |, ^에  사용되지 않아야 한다.</br>
4. 어떤 피연산자가 산술 값으로 변환된다면 essential 타입이 character 인 피연산자를 사용하면 안된다. 문자열 데이터를 저장하는 방법은 구현체마다 다르기 때문이다.</br>
5. enum 객체는 implementation-defined 정수 타입으로 저장되기 때문에 essential 타입이 enum인 피연산자는 산술 연산에 사용되지 않아야 한다. enum객체를 사용한 연산은 예상치 못한 타입의 결과값을 생성할 수 있다.</br>
6. Shift 및 bitwise 연산들은 essential 타입이 unsigned인 객체에 대해서만 수행되어야 한다. Essential 타입이 signed인 객체들을 대상으로 한 해당 동작은 구현체마다 다르다.</br>
7. Shift연산의 우측 피연산자는 essential 타입이 unsigned이어야만 음수 값으로 shifting을 시도함으로 발생하는 undefined behavior를 예방할 수 있다.</br>
8. 단항 minus연산의 피연산자로 essential 타입이 unsigned를 사용하지 말아야 한다. 각 구현체마다 int 크기가 다르기 때문에 해당 연산 결과의 부호 여부를 정확히 알 수 없기 때문이다.
<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.2<br>
</p>

]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_10_02</rule>
    <ruleTitle><![CDATA[Essential 타입이 character인 표현식은 가감연산자에 부적합하게 사용되지 않아야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

적합한 사용의 예는 다음과 같다.</br></br>
1. +연산자의 경우 피연산자 중 하나의 essential 타입이 character라면 다른 하나는 essential  타입이 signed거나 unsigned여야 한다. 이 연산 결과의 essential 타입은 character가 된다.</br></br>
2. -연산자의 경우 첫 번째 피연산자의 essential 타입이 character이라면 두 번째 연산자의 essential 타입이 signed거나 unsigned여야 한다. 만약 두 연산자의 essential 타입이 모두 character이라면 이 연산의 결과는 기본 타입(standard type; 보통 int)이고, 그렇지 않을 경우 character이다.</br></br>
essential 타입이 character인 수식은 데이터가 산술 값을 표현하지 않으므로 산술적으로 사용되지 않아야 한다.
위에 제시된 사용은 character 데이터의 수정을 허용한다.</br></br>
예를 들어:</br></br>
- essential 타입이 character인 두 개의 피연산자의 차는 '0'에서 '9'사이 값이 할당되어 있는 객체의 값을 변경할 수 있다.</br>
- essential 타입이 character인 피연산자와 essential 타입이 unsigned인 피연산자의 합은 '0'에서 '9'사이 값이 할당되어 있는 객체의 값을 변경할 수 있다.</br>
- essential 타입이 character인 피연산자로부터 essential 타입이 unsigned인 피연산자를 빼는 연산은 소문자를 대문자로 변경할 수 있다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.1<br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_10_03</rule>
    <ruleTitle><![CDATA[표현식의 값은 더 작은 essential 타입이나 다른 essential 타입 분류에 타입를 갖는 객체에 할당되지 않아야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

C언어는 프로그래머에게 상당한 자유를 주고, 다른 산술 타입간의 할당이 자동적으로 처리되도록 한다. 그러나 이러한 묵시적 변환을 사용하는 것은 값, 부호, 정확도의 손실과 같은 의도치 않은 결과를 발생시킬 수 있다.

Misra의 essential 타입 모델에서 제안하는 더 강한 타입 제한을 사용하는 것은 이러한 문제 발생 가능성을 줄여준다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.4, Rule 10.5, Rule 10.6<br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_10_04</rule>
    <ruleTitle><![CDATA[일반 산술 변환이 수행되는 연산자의 두 피연산자들은 필히 같은 essential 타입 분류에 속하는 타입이어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<b>이 규칙은 일반 산술 변환에 기술되어 있는 연산자들에 적용된다.</b><br/>
이 연산자들은 shift, 논리 &&, ++, 콤마 연산자를 제외한 이항 연산자들이다. 추가적으로 삼항 연산자의 둘째와 셋째 피연산자도 이 규칙에 의해 처리된다. 증감연산자는 이 규칙의 검사 대상이 아닌다.<br/><br/>

C언어는 프로그래머에게 상당한 자유를 주고 또한 다른 산술 타입간의 형 변환이 자동으로 수행되도록 한다. 그러나 이러한 묵시적 변환의 사용은 값, 부호, 정확도의 손실과 같은 의도치 않은 결과를 발생시킬 수 있다. 

MISRA essential 타입 모델에서 강제하는것과 같은 더 강한 타입 제약을 사용하는 것은 개발자가 정확히 의도한 답을 생산하도록 묵시적 변환을 제한한다.
<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.3, Rule 10.7<br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_10_05</rule>
    <ruleTitle><![CDATA[수식의 값은 적절하지 않은 essential type으로 변환되지 않아야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

명시적 형변환은 특정 상황에서 사용될 수 있다. 이에 대한 예는 다음과 같다.</br></br>

- 타입 변경을 통해 특정 산술 연산자가 수행되게 하기 위해</br>
- 의도적으로 값을 잘라내기 위해</br>
- 형 변환의 명확성을 높이기 위해</br></br>
명시적 형변환은 적합하지 않다:
</br></br>
- C99에서 _Bool로의 형변환 또는 할당은 항상 0 또는 1이다. 그러나 Essential 타입이 Boolean인 타입을 다른 타입으로 변환할 때는 그렇지 않다.</br>
- Enum essential 타입으로 변환하는 것은 해당 타입의 enumeration에 속하지 않는 값이 될 수 있다.</br>
- Essential 타입이 boolean인 객체를 다른 타입으로 변환하는 것은 의미가 없을 확률이 높다.</br>
- floating 타입과 character 타입간의 변환은 두 타입간
<br/><br/>
다음은 형변환이 허용되지 않는 경우를 표로 나타낸 결과이다.
<br/><br/>
<center>
<table border="1" cellpadding="3" cellspacing="0">
			<tbody>
				<tr align="center">
					<td>
						Essential type category</td>
					<td colspan="6" style="background:#E2DFB7">
						&nbsp;from</td>
				</tr>
				<tr align="center">
					<td style="background:#E2DFB7">
						to</td>
					<td style="background:#E2DFB7">
						Boolean</td>
					<td style="background:#E2DFB7">
						character</td>
					<td style="background:#E2DFB7">
						enum</td>
					<td style="background:#E2DFB7">
						signed</td>
					<td style="background:#E2DFB7">
						unsigned</td>
					<td style="background:#E2DFB7">
						floating</td>
				</tr>
				<tr align="center">
					<td style="background:#E2DFB7">
						Boolean</td>
					<td>
						&nbsp;</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
				</tr>
				<tr align="center">
					<td style="background:#E2DFB7">
						character</td>
					<td>
						avoid</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						avoid</td>
				</tr>
				<tr align="center">
					<td style="background:#E2DFB7">
						enum</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
					<td>
						avoid*</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
				</tr>
				<tr align="center">
					<td style="background:#E2DFB7">
						signed</td>
					<td>
						avoid</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
				</tr>
				<tr align="center">
					<td style="background:#E2DFB7">
						unsigned</td>
					<td>
						avoid</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
				</tr>
				<tr align="center">
					<td style="background:#E2DFB7">
						floating</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
				</tr>
			</tbody>
		</table>
</center>
<br/>
<p>
<b>avoid*</b> 열거형 타입은 동일한 열겨형 타입으로 변환하는 것은 불필요하다.<br/>
추가로, void 타입을 다른 타입으로 변환하는 것에 대한 결과는 미정의된 특성이므로 허용되지 않는다. 이와 관련해서는 [MISRA_C_2012_01_03] 에서 언급한다.
<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.3, Rule 10.8<br>
</p>

]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_10_06</rule>
    <ruleTitle><![CDATA[복합 표현식의 값은 더 큰 essential 타입의 객체에 할당되지 않아야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

C언어는 프로그래머에게 상당한 자유를 주고, 다른 산술 타입간의 할당이 자동적으로 처리되도록 한다. 그러나 이러한 묵시적 변환을 사용하는 것은 값, 부호, 정확도의 손실과 같은 의도치 않은 결과를 발생시킬 수 있다.

Misra의 essential 타입 모델에서 제안하는 더 강한 타입 제한을 사용하는 것은 이러한 문제 발생의 가능성을 줄여준다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.3, Rule 10.7, Section 8.10.3<br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_10_07</rule>
    <ruleTitle><![CDATA[복합 수식이 기본 산술 변환을 수행하는 연산자의 피연산자로 사용된 경우, 다른 피연산자는 해당 수식의 타입보다 큰 essential 타입을 가지지 않아야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

복합 수식에 대한 묵시적 변환을 금지하는 것은 한 수식 내에 존재하는 산술 연산자들이 모두 같은 essential 타입으로 처리되어야 한다는 것을 의미한다. 이는 개발자의 혼동을 줄여준다.</br>
<b>참조</b> 이것이 한 수식의 모든 피연산자가 같은 essential 타입이어야 된다는 것을 의미하지 않는다는 점을 주의하라.</br></br>

수식 <b>u32a + u16a + u16c</b> 은 두 덧셈이 모두 uin32_t로 수행될 것이기 때문에 문제가 없다. 이 경우 비-복합 수식은 묵시적으로 형변환되었다.</br>
수식 <b>(u16a + u16b) + u32c</b> 의 좌측 덧셈은 uin16_t에서 수행되지만 우측 덧셈은 좌측 연산의 결과값을 uint32_t로 변환한 후 uint32_t에서 수행되기 때문에 문제가 있다. 

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.4, Rule 10.6, Section 8.10.3<br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_10_08</rule>
    <ruleTitle><![CDATA[복합 수식의 값은 다른 essential 타입 분류에 속하는 타입이나 더 큰 essential 타입으로 변환되지 않아야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

더 큰 타입으로의 변환은 각 구현체마다 결과가 상이하므로 허용되지 않는다. 아래의 경우를 고려해보자: <br/>

<textarea id="ex1">
(uint32_t) ( u16a + u16b );
</textarea>
<script>CodeMirror.fromTextArea(document.getElementById('ex1'));</script>

16비트 머신에서는 덧셈이 16비트 상에서 결과를 modulo-2로 처리하며 수행된 후 32비트로 변환된다. 그러나 32비트 머신에서는 덧셈 연산이 32비트상에서 수행되고 16비트 머신에서는 버려졌을 높은 자리수의 비트값들이 보존된다.
<br/><br/>
<b>같은 essential 타입 분류의 더 작은 타입으로의 변환은 명시적으로 결과값을 잘라내는 것은 항상 같은 정도(머신에 상관 없이)의 정보 손실을 일으키기 때문에 허용한다.</b>

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.5, Section 8.10.3<br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_11_01</rule>
    <ruleTitle><![CDATA[함수 포인터와 다른 타입 간의 형 변환 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

함수를 가리키는 포인터로/부터의 다음으로의 형변환:</br></br>

- 객체를 가리키는 포인터</br>
- 불완전 타입(incomplete) 객체를 가리키는 포인터</br>
- void*</br></br>
에 대한 동작은 정의되지 않았다.</br></br>

만약 어떤 함수가 호출된 함수와 호환되지 않는 타입을 갖는 포인터의 값으로 호출된 경우 이 결과는 표준에 의해 정의되지 않았다. 단, 함수를 가리키는 포인터를 다른 타입의 함수를 가리키는 포인터로 변환하는 것은 표준에 의해 허용된다. 정수형 값을 함수를 가리키는 포인터로 변환하는 동작도 표준에 의해 허용된다. 그러나 호환가능하지 않은 포인터 타입을 사용하는 함수를 호출하는 결과에 대한 동작이 정의되지 않았고, <b>이를 피하기 위해 이 규칙에서는 위에서 말한 두가지 모두를 금지한다.</b>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_11_02</rule>
    <ruleTitle><![CDATA[불완전 포인터(incomplete)타입과 다른 타입 간의 형 변환 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

불완전 타입과의 변환은 메모리 정렬(align)을 제대로 맞추지 못할 수 있고 예기치 못한 동작을 발생시킬 수 있다.</br>
특히, 불완전 타입과 부동소수 타입간의 변환에 대한 동작은 정의되지 않았다.</br></br>

불완전 타입을 가리키는 포인터는 때때로 어떤 객체의 표현방법을 숨기기 위해 사용된다. 따라서 불완전 타입을 가리키는 포인터로부터 객체를 가리키는 포인터로 변환하는 것은 이 캡슐화를 깨뜨릴 수 있다.
</br></br>
<b>예외사항</b></br></br>
&nbsp;&nbsp;&nbsp;&nbsp;1. null 포인터 상수는 불완전 타입을 가리키는 포인터로 변환될 수 있다.</br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 불완전 타입을 가리키는 포인터는 void로 변환될 수 있다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 11.5<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_11_03</rule>
    <ruleTitle><![CDATA[한 객체 포인터와 다른 객체 포인터 간의 변환 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<b>이 규칙은 포인터의 한정자(const, volatile 등)가 명시되지 않은 타입을 가리키는 경우에 적용된다.</b></br></br>

객체를 가리키는 포인터를 다른 객체를 가리키는 포인터로 변환하는 것은 메모리 정렬(align)을 제대로 맞출 수 없고, 따라서 이러한 객체의 사용은 정의되지 않은 동작이 발생시킬 수 있다.</br></br>

변환이 메모리 정렬이 제대로 맞게끔 수행된다 하더라도 해당 포인터를 통해 객체에 접근하는 경우 객체가 서로 호환되지 않는 경우 정의되지 않은 동작이 발생할 수 있다. 예를 들어 만약 int 타입의 어떤 객체가 short 타입의 포인터를 통해 접근되는 경우에 int와 short가 동일한 데이터 표현법과 alignment를 가진다 하더라도 이에 대한 동작은 정의되지 않았다. C90 표준의 6.3과 C99 표준의 6.5의 7번째 단락에 자세히 설명되어 있다.
</br></br>

<b>예외사항</b></br>
- <b>char, signed char, unsigned char</b>를 가리키는 포인터 간의 변환은 허용된다. 이 타입들이 독립된 byte단위로 접근할수 있게끔 표준이 보장하기 때문이다.
<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 11.4, Rule 11.5, Rule 11.8<br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_11_04</rule>
    <ruleTitle><![CDATA[객체 포인터와 정수형 타입 간의 변환 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

void를 가리키는 포인터를, 객체를 가리키는 포인터로 변환하는 것은 해당 포인터의 메모리 정렬(align)을 깨뜨릴 수 있고 따라서 정의되지 않은 동작을 발생시킬 수 있다. 가능하다면 이를 피해야 하지만 메모리 할당 함수와 같이 꼭 필요한 경우가 있다. 만약 객체를 가리키는 포인터를 void를 가리키는 포인터로 변환했다면 [MISRA_C_2012_11_03]에서 다룬 정의되지 않은 동작이 발생하지 않도록 주의를 기울여야 한다.</br></br>

<b>예외사항</b></br></br>
- 가리키는 타입이 void로 선언된 null 포인터 상수는 객체를 가리키는 포인터로 변환될 수 있다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 11.3, Rule 11.7, Rule 11.9<br>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_11_05</rule>
    <ruleTitle><![CDATA[void 포인터에서 객체 포인터로 변환 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

void를 가리키는 포인터를 객체를 가리키는 포인터로 변환하는 것은 해당 포인터의 메모리 정렬(align)을 깨뜨릴 수 있고 따라서 정의되지 않은 동작을 발생시킬 수 있다. 가능하다면 이를 피해야 하지만 메모리 할당 함수와 같이 꼭 필요한 경우가 있다. 만약 객체를 가리키는 포인터를 void를 가리키는 포인터로 변환했다면 [MISRA_C_2012_11_03] 에서 다룬 정의되지 않은 동작이 발생하지 않도록 주의를 기울여야 한다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 11.2, Rule 11.3<br>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_11_06</rule>
    <ruleTitle><![CDATA[void 포인터와 산술 타입 간의 변환 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

정수형 타입을 void를 가리키는 포인터로 변환하는 것은 해당 포인터의 메모리 정렬(align)을 깨뜨릴 수 있고 따라서 정의되지 않은 동작을 발생시킬 수 있다.</br>
void를 가리키는 포인터를 정수형 타입으로 변환하는 것은 선택된 정수 타입으로 표현 불가능한 값을 만들 수 있고 이에 따라 정의되지 않은 동작을 발생시킬 수 있다.</br>

정수가 아닌 산술형 타입과 void를 가리키는 타입간의 변환은 정의되지 않았다.</br></br>

<b>예외사항</b></br></br>
- 정수형 타입의 null 포인터 상수는 객체를 가리키는 포인터로 변환될 수 있다.
]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_11_07</rule>
    <ruleTitle><![CDATA[객체 포인터와 정수가 아닌 산술 타입 간의 변환금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

이 규칙을 위한 정수가 아닌 산술형 타입은 다음과 같다.</br></br>
- Essential 타입이 Boolean인 타입</br>
- Essential 타입이 character인 타입</br>
- Essential 타입이 enum인 타입</br>
- Essential 타입이 float인 타입</br></br>

Essential 타입이 Boolean, character, enum인 타입을 객체를 가리키는 포인터로 변환하는 것은 해당 포인터의 메모리 정렬(align)을 깨뜨릴 수 있고 따라서 정의되지 않은 동작을 발생시킬 수 있다.</br>
객체를 가리키는 포인터를 Essential 타입이 Boolean, character, enum인 객체로 변환하는 것은 선택된 정수 타입으로 표현 불가능한 값을 만들 수 있고 이에 따라 정의되지 않은 동작을 발생시킬 수 있다. 또한, 객체를 가리키는 포인터와 essential 타입이 floating인 타입간의 변환은 정의되지 않았다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 11.4<br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_11_08</rule>
    <ruleTitle><![CDATA[형 변환 시 포인터의 const 또는 volatile 제거금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

변환을 통해 명시된 타입의 한정자를 제거하려는 시도는 타입 한정자의 원칙을 위반하는 것이다.</br>
여기에서 말하는 한정자는 포인터 자체에 적용된 한정자를 말하는 것이 아니라는 점에 주의하라.</br></br>

명시된 타입의 한정자를 제거한다면 다음과 같은 문제가 발생할 수 있다:</br></br>
- const 한정자를 제거하게 된다면 객체의 읽기전용 상태를 우회할 수 있게 되고 따라서 객체가 수정될 수 있게 된다.</br>
- const 한정자를 제거하는 것은 객체에 접근할 때 exception을 발생시킬 수 있다.</br>
- volatile 한정자를 제거하는 것은 컴파일러에 의해 최적화된 객체에 접근하게끔 할 수 있다.</br></br>

<b>참조</b> C99의 restrict 타입 한정자를 제거하는 것은 가능하다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 11.3<br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_11_09</rule>
    <ruleTitle><![CDATA[매크로 NULL은 정수 null 포인터 상수만으로 사용해야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

0 대신 NULL을 씀으로써 null 포인터 상수가 사용되었음을 더 명확히 하여라.<br/><br/>
만약 아래와 같은 경우에서 0의 값을 갖는 정수 상수식이 나왔다면 그것은 매크로 NULL을 통해 사용된 것이어야 한다:</br>

- 해당 값이 포인터에 할당되는 경우</br>
- 연산자 ==나 !=의 다른 피연산자가 포인터인 경우</br>
- ?:연산자의 세 번째 피연산자가 포인터인 경우 두 번째 피연산자에 쓰일 때</br>
- ?:연산자의 두 번째 피연산자가 포인터인 경우 세 번째 피연산자에 쓰일 때
</br></br>
공백과 괄호들 무시하고 난 후 이러한 정수 상수식들은 확장된 매크로 NULL을 표현할 수 있어야 한다.</br>
(void*) 0의 꼴로 만들어진 null 포인터 상수는 매크로 NULL이 확장되었든 그렇지 않든 허용한다.</br>

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 11.4<br>
]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_12_01</rule>
    <ruleTitle><![CDATA[수식 내부에 사용된 연산자의 우선순위가 명확한지 검사]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

아래 표는 이 규칙의 정의를 위한 것이다.<br/><br/>

<center>
<table align="center" border="1" cellpadding="6">
<tr align="left">
<td rowspan="1">Description</td><td rowspan="1">Operator or Operand</td><td rowspan="1">Precedence</td>
</tr>

<tr align="left">
<td>Primary </td><td>identifier, constant, string literal, (expression)</td><td>16(high)</td>
</tr>

<tr align="left">
<td>Postfix</td><td>[] () (function call) , -> ++(post-increment) --(post-decrement) () {} (C99: compound literal)</td><td>14</td>
</tr>

<tr align="left">
<td>Unary</td><td>++(pre-increment) --(pre-decrement) & * + - ~ ! sizeof defined (preprocessor)</td><td>14</td>
</tr>

<tr align="left">
<td>Cast</td><td>()</td><td>13</td>
</tr>

<tr align="left">
<td>Multiplicative</td><td>* / %</td><td>12</td>
</tr>

<tr align="left">
<td>Additive</td><td>+ -</td><td>11</td>
</tr>

<tr align="left">
<td>Bitwise shift</td><td><< >></td><td>10</td>
</tr>

<tr align="left">
<td>Relational</td><td>< > <= >=</td><td>9</td>
</tr>

<tr align="left">
<td>Equality</td><td>== !=</td><td>8</td>
</tr>

<tr align="left">
<td>Bitwise And</td><td>&</td><td>7</td>
</tr>

<tr align="left">
<td>Bitwise XOR</td><td>^</td><td>6</td>
</tr>

<tr align="left">
<td>Bitwise OR</td><td>|</td><td>5</td>
</tr>

<tr align="left">
<td>Logical AND</td><td>&&</td><td>4</td>
</tr>

<tr align="left">
<td>Logical OR</td><td>||</td><td>3</td>
</tr>

<tr align="left">
<td>Conditional</td><td>?:</td><td>2</td>
</tr>

<tr align="left">
<td>Assignment</td><td>= *= /= %= += -= <<= >>= &= ^= !=</td><td>1</td>
</tr>

<tr align="left">
<td>Comma</td><td>,</td><td>0(low)</td>
</tr>

</table>
</center>
<p>
<br/><br/>
이 테이블에 사용된 우선순위는 규칙설명을 위한 것이다.
다른 연산자 우선순위 관련 테이블과 다를 수 있다.
표현식의 우선순위는 그 표현식의 파싱 트리 루트의 요소의 우선순위이다.
예를 들어 a << b + c 의 파싱 트리는 다음과 같이 표현된다.
파싱트리 루트의 요소는 "<<"이고 이 표현식은 우선순위 10 이다.<br/><br/>

<span style="font-family:Arial">
&nbsp;<<<br/>
&nbsp;/&nbsp;&nbsp;\<br/>
a&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;c<br/>
</span>
<br/><br/>

* sizeof의 피연산자는 괄호로 감싸져야 한다.<br/>
* 우선순위가 2-12의 표현식은 다음의 경우 괄호를 가져야 한다.<br/>
&nbsp;&nbsp;- 우선순위 13이하<br/>
&nbsp;&nbsp;- 표현식의 우선순위보다 클 때<br/>

C언어의 상대적으로 많은 연산자와 그 우선순위 관계는 직관적이지 않다. 이 규칙을 통해 개발자의 실수를 줄일 수 있다.
연산자의 우선순위를 명백히 하기 위해 괄호를 사용하는것은  개발자의 실수 가능성을 제거한다.
또한 코드의 유지보수 및 검토 시 원작자의 의도를 명확히 전달할 수 있다.
 </br></br>
괄호의 과도한 사용은 코드를 어지럽히고 가독성을 감소시킬 수 있다.
이 규칙은 괄호가 너무 적은 것과 괄호가 너무많아서 이해하기 힘든 코드 사이의 타협점을 찾는 것을 목표로 한다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_12_02</rule>
    <ruleTitle><![CDATA[shift 연산자의 우측 피연산자가 좌측 피연산자의 essential 타입의 범위 내의 정수여야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

우측 피연산자가 음수이거나 좌측 피연산자의 사이즈보다 크거나 같으면 정의되지 않은 행동이다.</br></br> 시프트 연산자의 좌측 피연산자가 16비트 integer이면, 이것이 0 - 15의 범위 내에서만 시프트 되는것을 보장하는 것은 매우 중요하다. essential type의 shift연산자에서의 제한과 설명에 대해서는 [Rule 8.10] 을 참고하라.</br></br>
 이 규칙을 보장하는 방법은 다양하다. 가장 단순한 방법은 우측 피연산자로 상수를 사용하는 것이다.( 값이 정적으로 확인될 수 있다. )</br></br> 피연산자가 unsigned integer 타입이면 음수가 아니므로 상한선만 확인하면 된다. 그렇지 않으면 상, 하 제한 모두 확인해야 한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_12_03</rule>
    <ruleTitle><![CDATA[Comma 연산자 사용금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

comma 연산자의 사용은 일반적으로 코드의 가독성을 해치고, 콤마의 기능은 다른 방법으로 대체가능하다. 예를 들어 for 문의 선언부에 여러 변수를 콤마 연산자로 선언하는 경우가 있다. for 문의 증가식에 사용하는 변수를 제외하고는 for 문 이전으로 선언을 옮기면 콤마 연산자를 사용하지 않아도 된다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_12_04</rule>
    <ruleTitle><![CDATA[unsigned integer wrap-around를 발생시키는 상수 수식 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

unsigned integer 표현식은 overflow에 엄격하지 않은 대신 wrap-around가 발생한다.
비록 런타임에서 modulo 연산을 사용하기 위해 쓰는 것과 같은 좋은 목적일지라도,
컴파일 타임에서는 의도한 것이 아닐 수 있다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_13_01</rule>
    <ruleTitle><![CDATA[초기화 리스트가 영구적인 side effect를 일으키면 안 됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System</br>
<span style="color:#B73232">Applies to</span> &nbsp;C99</br></br>

C90 표준은 aggregate 타입 객체의 초기화문이 상수 표현식만 포함하도록 제한한다. 하지만 C99 는 aggregate 초기화문에 run-time에서 평가되는 표현식을 포함하는 것을 허용한다. 또한 초기화된 객체처럼 동작하는 복합 리터럴의 경우도 허용한다. 초기화 리스트에서 표현식의 평가 도중 side effects 가 발생하는 경우 그 순서는 명확하지 않으며, side effects가 영구적이라면  초기화의 동작은 예측할 수 없다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 13.2<br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_13_02</rule>
    <ruleTitle><![CDATA[수식의 값과 영구적인 side effect의 평가결과가 평가 순서에 상관없이 같아야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

두 인접한 시퀀스 사이나 전체 표현식 내에서 :</br>

&nbsp;	1. 객체는 한번 이상 변형될 수 없다.</br>
&nbsp;	2. 어떠한 객체의 값을 읽는 것이 그 객체로 저장될 값의 계산에 영향을 미치지 않는다면 그 객체는 변형되거나 읽을 수 없다.</br>
&nbsp;	3. 한번 이상 volatile-qualified 타입을 변형할 수 없다.</br>
&nbsp;	4. 한번 이상 volatile-qualified 타입을 읽을 수 없다.</br>

Note : 객체는 표현식에 의해 직접적으로 접근되는 만큼 포인터나 함수 호출에 의해 간접적으로 접근될 수 있다.</br>

Note : 이는 규칙의 제목보다 더욱 엄격하다. 그래서 다음과 같은 표현식</br>

x = x = 0;<br/>

은 값 x가 volatile이 아니라면, 값이 영구적인 side effects가 평가 순서에 독립적이라고 하더라도 허용되지 않는다. <br/>



표현식을 평가할 때 표준에서는 컴파일러들에게 상당한 유연성을 부여한다. 대부분의 연산자는 어떤 순서에서든지 평가된 피연산자를 가지고 있다. 평가되지 않는 피연산자를 가지는 예외 상황은 다음과 같다 :</br></br>

&nbsp; - AND 연산자의 두번째 피연산자는 첫번째 피연산자가 0이 아닌경우에만 평가된다.<br/>
&nbsp; - OR 연산자의 두번째 피연산자는 첫번째 피연산자가 0일 경우에만 평가된다.<br/>
&nbsp; - :? 연산자의 첫번째 피연산자는 항상 평가된다. 그리고나서 두번째 또는 세번째 피연산자가 평가된다.<br/>
&nbsp; - 콤마 연산자의 첫번째 피연산자는 평가되고 나서 두번째 피연산자가 평가된다.
<br/><br/>
참조 : 괄호의 우선순위는 연산자에 적용된 우선순위를 변형시킬 수 있다. 그러나 이는 순서에 평가된
가장 낮은 레벨의 피연산자의 평가 순서에는 영향을 미치지 않는다.</br></br>
표현식의 평가와 관련된 예측할수 없는 행동의 많은 경우는 [Rule 13.3]과 [Rule 13.4]를 준수함으로써 피할 수 있다

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Dir 4.9, Rule 13.0, Rule 13.3, Rule 13.4<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_13_03</rule>
    <ruleTitle><![CDATA[증감 연산자(++, --)를 포함한 수식은 해당 증감 연산자를 제외한 잠재적인 side effect 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

다른 연산자와 혼합된 증감연산자의 사용은 다음의 이유로 추천하지 않는다:</br></br>
&nbsp; - 코드의 가독성을 매우 해칠 수 있다.</br>
&nbsp; - 정의되지 않는 행동에 대한 잠재적인 구문의 추가적인 side effect의 가능성이 있다.</br></br>
다른 연산자와는 고립되게 증감 연산자를 사용하는 것이 좀 더 명확하다.</br></br>

<b>이 규칙에서 함수 호출은 side effect로 간주한다.</b></br></br>
모든 full 표현식의 하위 표현식은 그 하위 표현식이 표준에 의해 평가되지 않는 것으로 분류되더라도 이 규칙에 한해서 평가된 것처럼 다뤄져야 한다.</br></br>

<span style="color:#B73232">See also</span>&nbsp;Rule 13.2</br>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Dead Code</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_13_04</rule>
    <ruleTitle><![CDATA[할당 연산자의 결과를 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

다른 산술 연산자와 같이 할당 연산자를 사용하는 것은 다음의 이유로 추천하지 않는다:</br></br>
&nbsp; - 코드의 가독성을 해친다.</br>
&nbsp; - 구문의 추가적인 side effect는 [Rule 13.2]에서 커버된 정의되지 않은 행동을 일으킬 수 있다.</br>
</br></br>
<b>할당문이 포함된 표현식이 평가되지 않는다고 하더라도 이 규칙을 적용한다.</b></br></br>

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 13.2</br>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_13_05</rule>
    <ruleTitle><![CDATA[논리적 &&나 || 연산자의 우측 항에 영구적인 side effect 가 있으면 안 됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

&&와 || 연산자의 우측 피연산자의 평가 여부는 좌측 피연산자의 값에 의존적이다. 만약 우측 피연산자가 side effect를 포함한다면 이러한 side effect는 프로그래머의 기대와는 다르게  발생하지 않을 수 있다. 
 </br></br>
우측 피연산자의 평가가 프로그램 상에서 그 표현식이 발생하는 곳에서 영구적이지 않은 side effect를 일으킨다면 우측 피연산자가 평가되는지의 여부는 중요하지 않다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_13_06</rule>
    <ruleTitle><![CDATA[sizeof의 피연산자에 side effect를 발생시킬 수 있는 수식 포함 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Mandatory</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

sizeof의 피연산자 내의 모든 표현식은 보통 평가되지 않는다. 이 규칙은 실제로 평가되는지와는 상관없이 어떤 표현식의 평가도 side effect를 포함하지 않을 것을 요구한다.
 <br/><br/>

sizeof의 피연산자는 표현식이거나 타입일 수도 있다. 피연산자가 표현식을 포함하는 경우, 실제로는 평가되지 않을 표현식이 평가될 것이라 착각할 수 있다. 이러한 실수로 인하여 프로그래밍 오류가 발생할 수 있다. <br/><br/>
C90 표준에서는 피연산자의 표현식이 런타임에서 평가되지 않는다고 서술한다.<br/>
C99 표준에서는 피연산자의 표현식은 보통 런타임에서 평가되지 않는다. 하지만 피연산자가 가변 길이의 배열타입을 포함하면, 크기 표현식이 평가되어야 한다. 만약 배열크기 표현식의 평가없이 결과가 결정된다면 명시되지 않은 상황이다.
<br/><br/>
<b>이 규칙에서 함수의 호출은 side effect로 간주한다.</b>

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 18.8</br>]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_14_01</rule>
    <ruleTitle><![CDATA[loop counter 의 essential 타입이 실수형이면 안 됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

실수형 loop counter 를 사용하면, 정수형으로 반올림할 때 오류가 발생하여, 실제로 반복하는 횟수가 개발자의 기대와 달라질 수 있다. 반복 과정에서 실수형의 소수점 이하를 반올림 할 수 없을 때 발생한다. <br/><br/>
어떤 코드에서 실수형 loop counter 가 올바른 동작을 하더라도, 다른 코드에서는 다른 숫자 값을 나타낼 수도 있다.

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 14.2</br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_14_02</rule>
    <ruleTitle><![CDATA[for 문이 잘 짜여져야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

for 문의 구조는 다음과 같아야 한다:<br/><br/>
첫 번째 절</br>
&nbsp;&nbsp;&nbsp;&nbsp;- 비었거나</br>
&nbsp;&nbsp;&nbsp;&nbsp;- loop counter 에 값을 할당하거나</br>
	&nbsp;&nbsp;&nbsp;&nbsp;- loop counter 를 정의하고 초기화 해야 함(C99)</br></br>
두 번째 절</br>
	&nbsp;&nbsp;&nbsp;&nbsp;- 표현식은 side effect 가 없어야 함</br>
	&nbsp;&nbsp;&nbsp;&nbsp;- loop counter 와 loop control flag 를 사용할 수 있음</br>
	&nbsp;&nbsp;&nbsp;&nbsp;- for 문의 body 에서 변경하는 다른 객체는 사용하면 안됨</br></br>
세 번째 절</br>
	&nbsp;&nbsp;&nbsp;&nbsp;- 표현식의 side effect 로 오직 loop counter 에만 값을 변경해야 함</br>
	&nbsp;&nbsp;&nbsp;&nbsp;- loop body 에서 변하는 다른 객체는 사용하면 안됨</br></br>

for 문의 body 에서 호출하는 어떤 함수에도 마찬가지이다.</br>
loop control flag 는 for 의 두 번째 절에서 사용하는 Boolean 식에서 사용하는 객체이다.</br></br>
for 문은 다용도의 반복에 사용할 수 있다. 한정된 형태의 반복문을 사용하여 코드를 작성해야  검토하고 분석하기 쉽다. <br/><br/>
<b>예외사항</b><br/>
- for 문의 모든 절이 빌 수도 있다. <b>( ; ; )</b> 와 같은 무한 루프는 허용한다.

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 14.1, Rule 14.3, Rule 14.4</br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_14_03</rule>
    <ruleTitle><![CDATA[결과가 항상 같은 제어식 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

이 규칙은 다음에 적용된다:</br></br>
&nbsp;&nbsp;&nbsp;&nbsp;- if, while, for, do ... while과 switch 문</br>
&nbsp;&nbsp;&nbsp;&nbsp;- ?: 연산자의 첫번째 피연산자</br></br>

 제어식의 결과값이 항상 같으면, 프로그램의 오류가 있을 수 있다. 컴파일러가 항상 결과가 같은 표현식 때문에 도달할 수 없는 코드를 지워버릴 수 있다. 이러한 이유로 실행될 수도 있는 방어 코드도 삭제될 수 있다</br></br>
<b>예외사항</b></br>
&nbsp;&nbsp;&nbsp;&nbsp;	1. 무한 루프를 만들기 위한 표현식은 허용한다.</br>
&nbsp;&nbsp;&nbsp;&nbsp;	2. do ... while 문의 essentially Boolean인 제어식이 0으로 계산되면 허용한다.

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 2.1, Rule 14.2</br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_14_04</rule>
    <ruleTitle><![CDATA[조건문이나 반복문의 제어식이 essentially Boolean type 인지 검사]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

조건문이나 반복문은 반드시 essentially Boolean type 이어야 한다.
for 문의 제어식은 없을 수도 있다. 이 규칙에서도 for 문에 제어식을 사용하지 않는 경우는 검출하지 않는다. 하지만 사용한다면 essentially Boolean type 이어야 한다.  

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 14.2, Rule 20.8</br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_15_01</rule>
    <ruleTitle><![CDATA[goto 문 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

goto 를 무분별하게 사용하면 프로그램이 체계가 없고 이해하기가 너무 어렵다.
goto를 사용하지 않으면 올바른 제어 흐름을 위해 flag를 도입해야 하고, flag를 사용하면 goto를 사용한 것보다 명료하지 못한 경우가 있다.</br></br>
따라서 이 규칙을 따르지 않는다면, [Rule 15.2] 와 [Rule 15.3] 의 가이드라인을 따라 goto 를 제한적으로 사용해야 한다.

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 9.1, Rule 15.2, Rule 15.3, Rule 15.4</br>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_15_02</rule>
    <ruleTitle><![CDATA[goto 문의 label이 같은 함수에서 더 나중에 위치하는지 검사]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

goto 를 무분별하게 사용하면 프로그램이 체계가 없고 이해하기가 너무 어렵다.
</br>
goto 문으로 <b>뒤로</b> 돌아가는 것을 금지해야 한다. 같은 코드를 재수행 해야 할 때는, 언어에서 제공하는 반복문을 사용하여 코드가 복잡해지는 것을 막을 수 있다. <br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 15.1, Rule 15.3, Rule 15.4</br>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_15_03</rule>
    <ruleTitle><![CDATA[goto 문이 참조하는 label은 같은 블록이나 인접한 블록에 있는지 검사]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

goto 를 무분별하게 사용하면 프로그램이 체계가 없고 이해하기가 너무 어렵다.
블록 사이나 내부 블록으로 뛰지(jump) 않도록 하면, 코드가 복잡해지는 것을 막을 수 있다. 
<br/><br/>
참조: C99 에서는 변하기 쉬운 타입을 사용할 때 더 많은 제약이 있다. 변하기 쉬운 타입인 식별자가 있는 내부 scope 로 뛰려고 시도하는 것은 제약을 위배하는 것이다.<br/><br/>

<b>이 규칙에서 복합문으로 이루어지지 않은 switch 절은 블록으로 취급한다. </b>
<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 9.1, Rule 15.1, Rule 15.2, Rule 15.4, Rule 16.1<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_15_04</rule>
    <ruleTitle><![CDATA[반복문에는 하나의 break나 goto 문만 있는지 검사]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

반복문의 출구를 제한하면 코드가 복잡하지 않다. 하나의 break나 goto 문을 허용하면 반복문이 조건식보다 더 일찍 종료되는 경우가 하나가 된다

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 15.1, Rule 15.2, Rule 15.3<br/>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_15_05</rule>
    <ruleTitle><![CDATA[함수는 마지막에 하나의 return만 가지는지 검사]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

IEC 61508 과 ISO 61508 에서는 모듈식 접근을 위해 하나의 출구만 요구하고 있다. <br/>
함수 중간의 return 은 의도하지 않게 함수 종료 코드의 누락을 발생시킨다.
함수의 출구가 계속해서 side effect를 발생하는 문장들과 배치되어 있다면,  함수가 실행될 때 어떤 side effect 가 발생할지 알기가 힘들다.<br/><br/>

<b>함수는 하나의 return 문만 가져야 한다.<br/>
return 문은 함수의 몸체의 마지막 문장이어야 한다.</b>

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 17.4<br/>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_15_06</rule>
    <ruleTitle><![CDATA[반복문이나 선택문이 복합문인지 검사]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

개발자가 반복문이나 선택문의 몸체를 괄호없이 문장만을 나열하는 것이 들여쓰기에 장점이 있다고 믿는 경우가 있다. 실수로 제어 표현식 다음에 ";" 이 포함되면 null 문장으로 연결되므로 위험하다. 복합문을 사용해야 반복문이나 선택문의 몸체를 분명하게 정의할 수 있다.
</br>게다가 개발자가 엉뚱한 if 문과 else 문을 연결해서 읽을 수도 있다.</br></br>

<b>예외사항</b></br></br>

<b>else if</b> 는 <b>else</b> 의 몸체를 복합문으로 해서 if 문을 쓰는 형태가 아니어도 된다.
]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_15_07</rule>
    <ruleTitle><![CDATA[모든 if ... else if 구조는 else 문으로 끝나는지 검사]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

if 문에 뒤따르는 else if 문이 하나라도 있으면 반드시 else 문으로 끝나야 한다.
if ... else if 구조를 else 문으로 끝내는 것은 방어적인 프로그래밍이고 switch 문에 default 절을 사용하는 이유를 보완한다.([Rule 16.5] 참고)</br></br>
else 문은 side effect 가 있거나 코드 리뷰를 위한 지시나 원하는 동작 등을 주석으로 표현해야 한다.</br></br>
참조: 단순한 if 문에는 else 문이 필요하지 않다.


<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 16.5<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_16_01</rule>
    <ruleTitle><![CDATA[모든 switch 문은 잘 짜여야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

C의  switch 문의 구문은 특별히 엄격하지 않고 복잡한 구조를 허용하는데, 구조화되지 못한 행동이다 . 이 규칙과 다른 규칙들은 switch 문이 단순하고 일관된 구조가 되도록 보장한다.  

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 15.3, Rule 16.2, Rule 16.3, Rule 16.4, Rule 16.5, Rule 16.6<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_16_02</rule>
    <ruleTitle><![CDATA[switch label 을 포함하는 가장 가까운 문장은  switch 문이어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

표준에서 switch label 인 case 나 default 가 switch 문의 어떤 문장의 몸체에나 포함될 수 있도록 허용하기 때문에, 구조화되지 못한 코드가 될 수 있다. 이를 방지하기 위해 switch label 은 반드시 switch 문의 가장 바깥쪽 몸체에 있어야 한다.

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 16.1<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_16_03</rule>
    <ruleTitle><![CDATA[모든 switch 절은 break 로 끝나야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

개발자가 실수로 switch 절을 break 로 끝마치지 않으면, 다음 switch 절로 빠져나가거나, 다음 switch 절이 없으면, switch 문의 다음 문장으로 빠져나온다. 다음 switch 절로 빠져나가게 의도했다 하더라도 때로는 오류이다. 제어흐름이 switch 문의 마지막에 있는 break로 끝나지 않는 switch 절에서  나중에 추가되는 switch 절로 빠져나갈 수 있다.
</br></br>
이런 오류를 반드시 발견할 수 있도록, 모든 switch 절의 마지막 문장은 break 이어야 한다.
</br></br>
참조: switch 절은 적어도 하나의 문장은 있어야 정의된다. 따라서 두 연속한 label에 어떤 문장도 없는 경우는 이 규칙에서 허용한다.

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 16.1<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_16_04</rule>
    <ruleTitle><![CDATA[모든 switch 문에 default label 이 있어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

default label 은 방어적인 프로그래밍을 위해 필요하다. default label 에는 어떤 행동을 하는 문장이 따르거나 문장이 없으면 이유를 밝히는 주석이 있어야 한다. 

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 2.1, Rule 16.1<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_16_05</rule>
    <ruleTitle><![CDATA[default label 은 switch 문장의 맨처음이나 마지막 switch label 이어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

이 규칙은 default label 을 switch 문에 위치시키기 쉽게 한다. switch 문에 default 문장을 사용했는지 쉽게 확인할 수 있고, 제어 흐름을 파악하기 쉽다.

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 15.7, Rule 16.1<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_16_06</rule>
    <ruleTitle><![CDATA[모든 switch 문에 적어도 둘 이상의 switch 절이 있어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

하나의 경로만 가지는 switch 문은 쓸모가 없고 프로그램 오류일 가능성이 높다.

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 16.1<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_16_07</rule>
    <ruleTitle><![CDATA[switch-expression 은 Boolean 타입이면 안 됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

표준에 따라 switch 문의 조건식은 정수 타입이어야 한다. Boolean 의 값의 타입은 정수이기 때문에, switch 문을 Boolean 표현식으로 제어하는 것이 가능하다. 그러나, 이러한 경우는 if-else 구조를 사용하는 것이 적절하다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_17_01</rule>
    <ruleTitle><![CDATA[stdarg.h에 정의된 요소들은 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

 <b>va_list, va_arg, va_start, va_end, va_copy</b> 는 사용하면 안 된다.</br></br>
 표준에는 "stdarg.h" 와 관련된 많은 정의하지 않은 행동을 나열하고 있다:</br></br>
	- va_start 를 사용한 함수에서 va_end 를 사용하지 않는 경우</br>
	- 같은 va_list 의 va_arg 를 서로 다른 함수에서 사용하는 경우</br>
	- 함수의 인자의 타입과 va_arg 에 명시한 타입이  맞지 않는 경우]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_17_02</rule>
    <ruleTitle><![CDATA[직, 간접적 재귀호출 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

재귀(Recursion)는 스택 공간을 넘치게 하여, 심각한 오류가 발생할 수 있다. 재귀를 아주 엄격하게 관리해도, 실행 전에 스택 공간에서 오류가 발생할 수 있는 상태를 측정할 수는 없다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_17_03</rule>
    <ruleTitle><![CDATA[함수를 묵시적으로 선언 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90<br/><br/>

함수 호출은 프로토 타입에 따라야 한다. 함수 호출의 인자 수와 타입이 일치해야 한다.<br/><br/>
만약 함수를 묵시적으로 선언하면, C90 컴파일러는 함수의 반환 타입을 int 로 간주한다. 묵시적인 함수는 프로토 타입을 제공하지 않기 때문에, 컴파일러는 함수의 인자나 타입의 정보를 알 수 없다. 인자와 반환 값의 타입이 부적절하게 변환되고, 다른 정의하지 않은 행동도 발생할 수 있다.    ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_17_04</rule>
    <ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 모든 경로의 마지막은 수식을 포함한 return 문이어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

return 문의 표현식은 함수가 반환하는 값을 나타낸다. void 가 아닌 함수가 반환 값이 없으면, 정의하지 않은 행동이다.</br>

&nbsp;	- 모든 return 문에 표현식이 있다.</br>
&nbsp;	- 함수의 제어 흐름이 return 문으로 끝난다.</br></br>

 참조: C99 에서 void 가 아닌 함수의 모든 return 문은 값을 반환해야 한다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_17_05</rule>
    <ruleTitle><![CDATA[배열 타입으로 선언된 함수의 매개변수는 적합한 수의 원소를 가져야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

함수의 매개변수가 특정한 크기의 배열로 선언되면, 함수 호출마다 해당하는 인자의 배열은 원소의 수가 일치해야 한다. 함수의 매개변수에 배열을 사용하면 포인터를 사용하는 것보다 명확하다. 포인터와는 다르게 함수에서 바라는 최소한의 원소의 수를 명시적으로 보여 줄 수 있다.</br></br>
함수의 매개변수에 배열의 크기를 명시하지 원소의 크기가 얼마이든 상관 없다는 뜻이다.  이런 경우에는 배열의 크기를 다른 인자로 결정하거나, 배열의 원소가 특정 값인지 검사하여 반복문을 종료한다.</br></br>
함수에서 매개변수로 전달 받은 배열의 경계를 검사하는 것만큼이나, 배열의 경계를 명시해 주는 것도 중요하다. C 에서는 크기를 명시한 매개변수와 맞지 않은 크기의 배열을 사용하는 것을 허용하지만, 예상하지 못한 동작을 일으킬 수 있다.   
 
 ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_17_06</rule>
    <ruleTitle><![CDATA[배열 타입의 매개 변수의 선언은 [] 사이에 static keyword를 포함하지 않아야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C99<br/><br/>

C99 표준에서는 프로그래머가 컴파일러에게 배열 타입의 파라미터의 원소 개수를 특정 할 수 있는 장치를 제공한다. 어떤 컴파일러는 이 정보를 이용하여 효과적으로 코드를 생성할 수 있다. <br/><br/>
프로그래머가 허용 값을 명시하는 것이 허용되지 않고, 원소의 수가 명시한 것보다 적으면, 정의하지 않은 행동이다.<br/><br/> 
 임베디드 프로그램에서 사용하는 프로세서는 프로그래머가 제공하는 정보를 이해하지 못 할 수 있다. 성능의 향상을 위해 사용한 한정 값 때문에 프로그램이 실패할 수  있다.    ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_17_07</rule>
    <ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

호출한 함수의 반환 값을 사용하지 않으면, 오류가 발생할 수 있다. 함수의 반환 값을 의도적으로 사용하지 않으면, void 로 캐스팅해야 한다. 이렇게 하면 [Rule 2.2] 를 위반하지 않고 값을 사용할 수 있다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_17_08</rule>
    <ruleTitle><![CDATA[함수의 매개변수는 변경되지 않아야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

  함수 매개변수는 자동 저장기간(automatic storage duration)을 가진 객체와 같은 방식으로 행동한다. C 내에서 매개변수들이 수정되는 것을 막지는 않으나, 이는 프로그래머의 기대와 다른 결과를 초래할 수 있다. 따라서, 매개변수를 자동 객체(automatic object)에 복사하여 그 복사본을 수정하는 방식을 사용해야 한다. 최신의 컴파일러에서는 이러한 방식을 사용해도 저장 공간이나 실행 시간에 손해가 없다.</br></br>
  C 에 익숙하지 않지만 다른 언어를 사용해본 프로그래머라면, 해당 함수를 호출할 때 수정한 파라미터가 영향을 줄 것이라고 생각할 수 있다.</br></br>
※ 자동 저장 기간(automatic storage duration): 지역변수의 저장공간은 해당 지역의 함수가 호출/반환할 때 자동적으로 할당/해제된다.</br>
※ 자동 객체(automatic object): 스택에 자동적으로 생성되는 객체로, 디폴트 생성자를 통해 초기화되고 해당 함수의 반환 시점에서 자동적으로 해제된다.</br>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_18_01</rule>
    <ruleTitle><![CDATA[포인터의 연산 결과는 해당 포인터가 가리키는 배열의 요소이어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
몇몇 컴파일러는 컴파일 타임에 배열의 범위가 초과되었는지 알 수 있지만, 일반적으로 런타임 시점에서 유효하지 않은 배열에 대해서 확인하지 않는다. 유효하지 않은 배열을 사용하면 프로그램에서 오류가 발생할 수 있다.<br/><br/>
런타임에 결정되는 배열 값들은 정적 분석이나 수작업 검토에 의해 쉽게 확인될 수 없기 때문에 문제가 발생하기 쉽다. 어떤 값이 유효한지 확인하고 필요하다면 적절한 동작을 추가하기 위해서는 가능한 한 방어적인 프로그래밍 코드가 제공되어야 한다.<br/><br/>
상위 표현식의 하나로부터 얻어진 결과가 pointer_expression에 의해 가리키는 배열의 요소가 아니거나, 배열의 끝에서 1 이상 넘어간 요소라면, 이것은 정의되지 않은 행동이다. C90의 6.3.6과 C99의 6.5.6을 참고하라.<br/><br/>
다차원 배열은 "배열의 배열" 이다. 이 규칙은 다른 하위 배열의 주소를 가리키는 포인터를 만들 수 있는 포인터 연산을 금지한다. 내부 범위를 벗어나는 배열 또한 사용하면 안된다.<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Dir 4.1,&nbsp;Rule 18.4<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_18_02</rule>
    <ruleTitle><![CDATA[포인터 간의 뺄셈은 같은 배열의 요소들을 가리키고 있는 포인터들에만 적용되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
이 규칙은 표현식의 형태에 적용한다:<br/><br/>
<b>pointer_expression_1 - pointer_expression_2</b><br/><br/>
위의 표현식에서 pointer_expression_1과 pointer_expression_2가 같은 배열의 요소를 가리키지 않거나, 배열의 끝보다 1 뒤에 위치한 요소를 가리키는 경우 정의되지 않은 행동을 할 수 있다.<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Dir 4.1,&nbsp;Rule 18.4<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_18_03</rule>
    <ruleTitle><![CDATA[관계 연산자 >, >=, <, 그리고 <=는 같은 객체를 가리키고 있는 포인터를 제외한 다른 포인터 타입의 객체에 적용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
포인터 간 비교를 시도하는 것은 두 포인터가 같은 객체를 가리키지 않는다면 정의되지 않은 행동을 발생시킨다.<br/><br/>
참조 : 배열의 끝보다 1 뒤에 위치한 요소의 주소를 가리키는 것은 허용하지만, 이 요소를 접근하는 것은 허용하지 않는다.<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Dir 4.1<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_18_04</rule>
    <ruleTitle><![CDATA[+, -, +=, -= 연산자는 포인터 타입의 표현식에 적용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
ptr[expr]과 같이 배열에 사용하는 인덱싱 형태는 포인터 산술연산의 선호되는 형태이다. 이는 명확하고 이로 인해 포인터 조작보다 에러가 적기 때문이다. 포인터 값을 명시적으로 계산하는 것은 의도하지 않거나 잘못된 메모리에 접근할 수 있어서 잠재적인 위험을 가지고 있다. 이러한 행동은 배열 인덱싱을 통해서도 가능하고, 또한 배열 인덱싱을 사용할 경우 리뷰 작업 또한 쉽게 할 수 있을 것이다.<br/><br/>
C 언어에서의 포인터 산술연산은 초심자에게 혼란을 줄 수 있다. 표현식 'ptr + 1'은 ptr의 주소에 1을 더하는 것으로 잘못 해석될 수 있다. 사실 새 메모리 주소는 포인터가 가리키는 대상의 크기에 의존한다. 이러한 오해로 인해 sizeof 연산자가 잘못 적용되었을 때 기대하지 않은 행동을 할 수 있다.<br/><br/>
하지만 주의해서 사용했을 때 ++를 사용한 포인터 조작은 몇몇 경우에서 더 자연스러울 수 있다. 예를 들면, 메모리 테스트를 하는 동안 연속적으로 어떤 위치에 접근해야할 때, 즉, 연속적인 위치의 집합으로 이루어진 메모리 공간을 다룰 때, 컴파일 타임에 결정되는 주소 범위를 다룰 때 더욱 편리하다.<br/><br/>

<b>예외사항</b>: 규칙 18.2의 두 포인터 간의 차감 연산은 허용한다.<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 18.1,&nbsp;Rule 18.2<br/>
]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_18_05</rule>
    <ruleTitle><![CDATA[3차원 이상의 포인터 선언 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
3차원 이상의 포인터 사용은 코드의 가독성을 심각하게 손상시킬 수 있으므로, 이는 피해야 한다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_18_06</rule>
    <ruleTitle><![CDATA[자동으로 값이 할당되는 객체의 주소는, 처음 객체가 소멸된 이후에도 지속되는 다른 객체로 복사 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
객체의 주소는 다음과 같은 상황에서 복사된다:<br/>
  - 할당<br/>
  - 메모리 이동 또는 복사 함수<br/><br/>
객체의 수명이 끝났을 때 그 객체의 주소는 불확실하다. 불확실한 주소를 사용하면 정의되지 않은 행동을 할 수 있다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_18_07</rule>
    <ruleTitle><![CDATA[구조체의 멤버로써 가변 길이의 배열 선언금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C99<br/><br/>
가변 길이의 배열 멤버는 Dir 4.12와 Rule 21.3에서 금지된 동적 메모리 할당과 함께 사용될 수 있다.<br/><br/>
가변 길이의 배열은 sizeof 연산자의 행동을 개발자가 기대하지 않는 방향으로 변형시킨다. 가변길이 배열을 포함하는 구조체의 같은 타입의 다른 구조체로의 할당은 예상과는 다르게, 가변 길이 배열 멤버의 시작주소를 제외하고 다른 요소들만 복사할 것이다.
가변 길이 배열을 포함하는 구조체에서, 같은 타입의 다른 구조체로의 할당은 기대한 대로 행동하지 않는다. 왜냐하면 복사가 일어날 때 다른 요소들은 복사되지만, 가변 길이 배열의 주소는 복사되지 않기 때문이다.<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Dir 4.12,&nbsp;Rule 21.3<br/>
]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_18_08</rule>
    <ruleTitle><![CDATA[Variable-length(길이를 변수로 지정한) 배열 타입 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C99<br/><br/>
Variable-length 배열 타입은 블록이나 함수 프로토타입에 선언된 배열의 크기가 상수가 아닐 때 명시된다. 이는 스택에 저장된 변수 길이의 객체로 구현된다. 그러므로 이러한 사용은 스택에 할당되어야 할 메모리 양을 정적으로 결정할 수 없게 만든다.<br/><br/>
Variable-length 배열의 사이즈가 0이거나 음수이면, 정의되지 않은 행동을 할 수 있다.<br/><br/>
Variable-length 배열이 호환되어야하는 다른 배열 타입의 컨텍스트에 사용된다면, 배열 타입의 크기는 동일해야 한다. 또한 모든 크기는 양수로 평가되어야한다. 이러한 요구사항들이 충족되지 못한다면, 정의되지 않은 행동을 할 수 있다.<br/><br/>
Variable-length 배열이 sizeof 연산자의 피연산자로 사용된다면, 어떤 상황에서는 배열 크기를 나타내는 표현식이 평가되는지 아닌지 명확하지 않다.<br/><br/>
각각의 Variable-length 배열 타입은 그 수명이 시작될 때 고정된 크기를 가진다. 이러한 행동은 다음과 같이 혼란스러울 수 있다.<br/><br/>
<textarea id="ex1" >
void f ( int_16_t n )
{
	uint16_t vla[ n ];		/* Not-compliant - Undefined if n <= 0 */
}

void g ( void )
{
	f ( 0 );	/* Undefined */
	f ( -1 );	/* Undefined */
	f ( 10 );	/* Defined */
}

void h ( uint16_t n, uint16_t a[ 10 ][ n ] )		/* Non-compliant */
{
	uint16_t ( *p )[ 20 ];
	/* Undefined unless n == 20: incompatible types otherwise */
	p = a;
}
</textarea>
<script>CodeMirror.fromTextArea(document.getElementById('ex1'));</script><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 13.6<br/>
]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_19_01</rule>
    <ruleTitle><![CDATA[오버랩되는 객체에 할당 또는 복사 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
두 객체가 메모리 영역 내에서 overlap 되어 생성되고 한 객체가 다른 객체에 복사되거나 할당되는 경우, 이것은 정의되지 않은 행동이다.<br/><br/>
다음의 경우는 예외이다.<br/><br/>
 1. 정확히 overlap 되었고, 호환되는 타입의 두 객체의 할당(타입한정자 무시)<br/>
 2. 표준 라이브러리 함수 memmove를 사용하여 부분적 또는 완전하게 overlap된 객체 간의 복사<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 19.2<br/>]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_19_02</rule>
    <ruleTitle><![CDATA[union 키워드 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
잘 정의된 유니온 멤버에는 값을 할당할 수 있고, 그 후 같은 멤버 값을 사용할 수 있다.
<br/><br/>
하지만 유니온 멤버에 값을 할당한 후 다른 유니온 멤버를 읽는다면,  그 행동은 다음과 같이 멤버의 상대적인 크기에 의존한다:<br/><br/>
 - 만약 할당된 멤버보다 읽으려는 멤버 크기가 더 큰 경우 그 값은 보장할 수 없다.<br/>
 - 그렇지 않으면, 값은 implementation-defined 이다.
 <br/><br/>
표준에서는 unsigned char 타입의 배열 타입인 멤버로 다른 유니온 멤버의 byte로의 접근을 허용한다.
하지만, 불특정한 byte로의 접근이 가능하기 때문에, union을 사용해서는 안된다.
<br/><br/>
먄약 이 규칙을 따르지 않는다면, 다음의 행동을 결정해야 한다:<br/><br/>
 - Padding - union의 끝에 얼마나 많은 패딩이 추가되는지<br/>
 - Alignment - union 내 구조체 멤버들이 어떻게 정렬되는지<br/>
 - Endianness - word의 최상위 바이트가 메모리 주소의 가장 낮거나 가장 높은곳에 위치하는지<br/>
 - Bit-order - bit가 byte 내에서 어떻게 정렬되는지, 그리고 어떻게 bit가 bit field로 할당되는지<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 19.1<br/>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_20_01</rule>
    <ruleTitle><![CDATA[소스코드에서 #include의 상단에는 전처리 지사자 또는 주석만 허용]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
코드의 가독성을 위해서, 특정 코드 파일의 모든 #include 지시자는 파일의 최상단 근처에 같이 모여 있어야 한다.
추가적으로, 선언이나 정의 내에 표준 헤더파일을 include 하기 위해 #include를 사용하거나
관련된 표준 헤더파일을 include 하기 전에 표준 라이브러리의 일부를 사용하는 것은 정의되지 않은 행동이다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_20_02</rule>
    <ruleTitle><![CDATA[문자 ', ", \ 와 문자열 /* , //은 헤더파일의 이름에 포함 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
다음의 경우 정의되지 않은 행동이다.<br/><br/>
- 문자 ',  ", \ 또는 문자열 /*, // 가 헤더이름 내에 < 과 > 사이에 사용됨<br/>
- 문자 ', \ 또는 문자열 /* , // 이 헤더이름 " 사이에 사용됨]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_20_03</rule>
    <ruleTitle><![CDATA[#include 지시자는 <filename> 또는 "filename"의 형태를 따라야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
#include 지시자가 다음의 형태 중 하나를 사용하지 않는다면 정의되지 않은 행동이다.<br/><br/>
- #include <filename><br/>
- #include "filename"]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_20_04</rule>
    <ruleTitle><![CDATA[키워드와 같은 이름으로 매크로 정의 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
키워드의 의미를 바꾸기 위해 매크로를 사용하는 것은 혼란을 줄 수 있다.
키워드와 같은 이름인 매크로가 정의되어 있는 동안 해당 표준헤더가 include 되어 있다면 정의되지 않은 행동을 할 수 있다.<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 21.1<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_20_05</rule>
    <ruleTitle><![CDATA[#undef 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
#undef의 사용은 translation unit 내의 특정 지점에서 매크로가 존재하는지 불명확하게 한다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_20_06</rule>
    <ruleTitle><![CDATA[매크로 인자 부분에 전처리 지시자 사용금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
만약 인자가 전처리 지시자 처럼 행동한다면, 매크로가 대체되었을 때 그 행동은 예측하지 못한 결과를 가져올 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_20_07</rule>
    <ruleTitle><![CDATA[매크로 인자는 괄호로 감싸야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
매크로 함수는 성능 저하가 일어나지 않지만, 단순히 치환만을 수행한다는 특징이 있다. 따라서 인수의 타입, 연산 우선순위 등은 개발자가 고려해야 한다. 매크로 인자에 괄호가 사용되지 않는다면, 매크로로 치환할 때 연산자 우선순위가 원하는 결과로 나오지 않을 수 있다.
매크로 인자가 표현식으로 사용되지 않는다면, 어떠한 연산자도 포함되지 않기 때문에 괄호는 필요하지 않다.<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Dir 4.9<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_20_08</rule>
    <ruleTitle><![CDATA[#if 또는 #elif의 제어 표현식은 0 또는 1로 값이 나와야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
Strong typing(컴파일 타임에 최대한 많은 타입 체크를 해주는)은 Boolean 값을 갖기 위해, 조건을 포함하는 전처리 지시자로 이루어진 제어 표현식을 요구한다.<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 14.4<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_20_09</rule>
    <ruleTitle><![CDATA[#if 또는 #elif의 제어 표현식에 사용된 모든 식별자는 평가하기 전에 #define으로 정의 되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
전처리 지시자 내에서 매크로 식별자를 사용하기 위한 시도가 있다면, 그리고 그 식별자가 정의되지 않았다면, 전저리기는 그 값을 0으로 가정할 것이다. 이것은 개발자의 예상과는 다를 수 있다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_20_10</rule>
    <ruleTitle><![CDATA[전처리 연산자 # 과 ## 사용금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
복수의 #, 복수의 ## 또는 # 과 ##의 혼합된 연산자가 사용된 표현식의 평가 순서는 표준에 명시되지 않았다.
그러므로 특정한 경우 매크로 확장의 결과를 예측하는 것은 불가능하다. ## 연산자의 사용은 코드를 모호하게 만들 수 있다.<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 20.11<br/>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_20_11</rule>
    <ruleTitle><![CDATA[전처리 연산자 #의 피연산자 바로 뒤에 ## 연산자 사용금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
복수의 #, 복수의 ## 또는 # 과 ##의 혼합된 연산자가 사용된 표현식의 평가순서는 표준에 명시되지 않았다. 
#과 ##의 사용은 규칙 20.10에서 금지한다. 특정 상황에서 # 연산자의 결과는 string literal이고 이것을 다른 전처리 토큰에 붙여넣는 것이 유효한 토큰이 될 것이라고 보장할 수 없다.<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 20.10<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_20_12</rule>
    <ruleTitle><![CDATA[# 또는 ## 의 피연산자이며 추가적인 매크로 치환이 필요한 매크로 인자는 다른 연산자의 피연산자로 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
# 또는 ## 의 피연산자로 사용된 매크로 인자는 사용되기 전에 확장되지 않는다. 하지만 이 매크로 인자가 다른 곳에서 쓰일 경우에는 확장된다. 
 매크로 인자가 추가적인 매크로 치환이 필요하다면, 매크로 치환 내 혼합된 문맥은 개발자의 예상과 다를 수 있다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_20_13</rule>
    <ruleTitle><![CDATA[첫번째 토큰이 # 인 행은 유효한 전처리 지시자여야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
전처리 지시자는 일치하는 #else, #elif, #endif와 만날때까지 소스코드를 제외시키는데 쓰일 수 있다. 제외된 코드 내 포함된 잘못된 전처리 지시자는 컴파일러에 의해 발견되지 못할 수 있고, 의도했던 것보다 더 많은 코드가 제외될 수 있다.
제외된 코드 내에서도 문법적으로 올바른 전처리 지시자를 사용하는 것은 이런 일이 발생하지 않도록 보장한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_20_14</rule>
    <ruleTitle><![CDATA[모든 #else, #elif, #endif 전처리 지시자는 같은 파일 내에 관련된 #if, #ifdef, #ifndef 가 존재해야함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
조건부 컴파일 지시자가 여러 파일에 걸쳐서 사용됨으로써 코드 블럭이 포함되거나 제외된다면 이는 혼란을 불러일으킨다. #if 가 한 파일 내에서 종료되도록 요구하는 것은 코드의 시각적인 복잡도를 줄이고, 유지보수시 오류의 발생을 줄인다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_21_01</rule>
    <ruleTitle><![CDATA[예약된 식별자 또는 예약된 매크로 이름을 #define 또는 #undef에 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
  예약된 식별자와 매크로 이름은 구현체에 의해 사용하기 위한 것이다. 예약된 매크로의 의미를 변경하거나 제거하는 것은 정의되지 않은 행동을 초래한다.<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 20.4<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_21_02</rule>
    <ruleTitle><![CDATA[예약된 지시자 또는 예약된 매크로 이름으로 선언 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
  프로그램은 예약된 식별자가 표준에 명시된 대로 행동하도록 설계되고, 그것들을 특별하게 처리한다. <br/>예약된 식별자가 재사용된다면, 프로그램은 정의되지 않은 행동을 한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_21_03</rule>
    <ruleTitle><![CDATA[stdlib.h의 메모리 할당과 해제 함수 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<b>calloc, malloc, realloc</b>과 <b>free</b>는 사용하면 안되고, 매크로는 이들과 같은 이름으로 재정의하면 안된다. <br/><br/>
표준에서 제공하는 동적 메모리 할당과 해제를 사용하면 정의되지 않은 행동을 할 수 있다. 예를 들어:<br/><br/>
 - 동적으로 할당되지 않은 메모리의 해제<br/>
 - 해제된 메모리의 사용<br/>
 - 할당된 메모리에 값이 저장되기 전에 사용<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Dir 4.12, Rule 18.7, Rule 22.1, Rule 22.2<br/>
]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_21_04</rule>
    <ruleTitle><![CDATA[setjmp.h 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<b>setjmp</b>와 <b>longjmp</b>를 사용하면 일반적인 함수호출 메커니즘이 생략될 수 있다. <br/>이들을 사용하면 정의되지 않고 지정되지 않은 행동을 할 수 있다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_21_05</rule>
    <ruleTitle><![CDATA[signal.h 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
Signal handling은 implementation-defined을 포함하고 정의되지 않은 행동을 한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_21_06</rule>
    <ruleTitle><![CDATA[표준 입출력 함수 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
스트림과 파일 입출력은 그와 연관된 구체적이지 않은, 정의되지 않은, 실행 시 정의되는 수많은 행위를 포함한다.<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 22.1, Rule 22.3, Rule 22.4, Rule 22.5, Rule 22.6<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_21_07</rule>
    <ruleTitle><![CDATA[stdlib.h의 atof, atoi, atol, atoll 함수 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<b>atof, atoi, atol</b>과 C99에서 추가된 <b>atoll</b>은 사용하지 않는 것이 좋고, 매크로는 이들과 같은 이름으로 정의되어서는 안된다. <br/><br/>
이 함수들은 문자열이 변환돨 수 없을 때 정의되지 않은 행동을 할 수 있다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_21_08</rule>
    <ruleTitle><![CDATA[stdlib.h의 라이브러리 함수인 abort, exit, getenv, system 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<b>abort, exit, getenv</b> 그리고 <b>system</b>함수는 사용하지 않는 것이 좋고 매크로는 이들과 같은 이름으로 정의되어서는 안된다.<br/><br/>
이 함수들은 이와 연관된 정의되지 않은, 실행 시 정의되는 행동을 포함한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_21_09</rule>
    <ruleTitle><![CDATA[stdlib.h의 라이브러리 함수 bsearch, qsort 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<b>bsearch</b>와 <b>qsort</b>는 사용하지 않는 것이 좋고 매크로는 이들과 같은 이름으로 정의되면 안된다.<br/><br/> 요소들을 비교할 때 비교 함수가 일관되게 동작하지 않거나, 그 중 한 요소를 변경한다면 이는 정의되지 않은 행동이다. <br/> qsort의 구현은 재귀적으로 되어있을 것이고 스택 자원에 알 수 없는 요소를 배치한다. 임베디드 시스템에서는 일반적으로 스택의 크기가 작게 고정되어 있기 때문에 문제가 될 수 있다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_21_10</rule>
    <ruleTitle><![CDATA[표준 라이브러리 time, date 함수 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<b>"time.h"</b>에서 제공하는 기능은 사용해서는 안된다.<br/>또한, C99의 <b>wcsftime</b>를 사용해서는 안되며 매크로는 이 이름으로 확장되어서는 안된다.<br/><br/>시간과 날짜 함수는 그와 연관된 구체적이지 않은, 정의되지 않은, 실행 시 정의되는 행동을 포함한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_21_11</rule>
    <ruleTitle><![CDATA[tgmath.h 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C99<br/><br/>
<b>"tgmath.h"</b>의 함수 등을 사용하면 정의되지 않은 행동을 할 수 있다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_21_12</rule>
    <ruleTitle><![CDATA[fenv.h의 예외 처리 식별자 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C99<br/><br/>
<b>feclearexcept, fegetexceptflag, feraiseexcept, fesetexceptflag, fetestexcept </b>는 사용하면 안되고, 매크로는 이 이름으로 확장되어서는 안된다.<br/>
Implementation-defined된 부동소수점 예외 매크로인 <b>FE_INEXACT, FE_DIVBYZERO, FE_UNDERFLOW, FE_OVERFLOW, FE_INVALID, FE_ALL_EXCEPT </b>는 사용하면 안된다.<br/><br/>
몇몇 상황에서 부동소수점 상태 flag의 값은 정해져있지 않고, 이에 접근하려는 시도는 정의되지 않은 행동을 한다.<br/><br/> <b>feraiseexcept 함수</b>에 의해 발생되는 예외의 순서가 정해져있지 않기 때문에 프로그램이 의도된 순서대로 정확히 동작하지 않을 수 있다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_22_01</rule>
    <ruleTitle><![CDATA[표준 라이브러리를 통해 동적으로 얻은 리소스는 명시적으로 해제되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
자원을 할당하는 표준 라이브러리 함수는 malloc, calloc, realloc 그리고 fopen이다.<br/>
자원이 명시적으로 해제되지 않는다면 이로 인해 자원의 고갈이 발생하는 것이 가능하다. 가능한 빨리 자원을 해제하는 것은 자원 고갈의 가능성을 줄여준다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Dir 4.12, Dir 4.13, Rule 21.3, Rule 21.6<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_22_02</rule>
    <ruleTitle><![CDATA[메모리는 시스템 라이브러리 함수를 통해 할당되었을 때만 해제되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
메모리를 할당하는 표준 라이브러리 함수는 malloc, calloc, realloc이다.<br/>
할당되지 않은 메모리를 해제하거나 같은 곳에 할당된 메모리를 한번 이상 해제하는 것은 정의되지 않은 행동을 유발한다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Dir 4.12, Dir 4.13, Rule 21.3<br/>]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_22_03</rule>
    <ruleTitle><![CDATA[서로 다른 스트림에서 같은 파일을 동시에 읽기, 쓰기로 열면 안 됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
서로 다른 스트림에서 같은 파일을 동시에 읽기, 쓰기로 열면 안 된다. 표준에서는 이런 경우에 대한 동작을 명시하지 않고 있으므로, 의도한 동작을 보장할 수 없다.<br/>
단, 같은 파일을 읽기 전용으로 서로 다른 스트림에서 여러 번 여는 것은 가능하다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 21.6<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_22_04</rule>
    <ruleTitle><![CDATA[읽기 전용으로 열린 스트림에 쓰기를 하면 안 됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
표준에서는 읽기 전용 스트림에 쓰기를 시도하는 경우, 그에 따른 행동을 명시하지 않고 있으므로, 읽기 전용 스트림에 쓰기를 시도하는 것은 안전하지 않다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 21.6<br/>]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_22_05</rule>
    <ruleTitle><![CDATA[FILE 객체를 가리키는 포인터는 dereference되면 안 됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
FILE 객체에 대한 포인터는 직, 간접적(memcpy나 memcmp 호출 시 인자로 사용)으로 dereference되면 안 된다.<br/>
표준(C90 Section 7.9.3(6), C99 Section 7.19.3(6))에서는 FILE 객체의 주소는 스트림을 제어하는데 매우 중요하며, 객체의 사본으로는 동일한 동작을 보장할 수 없다고 말한다. 따라서 이런 사본이 생성되지 않도록 막기 위해 이 규칙이 필요하다.<br/>
FILE 객체에 대한 직접적인 조작은 금지된다. 이렇게 조작된 객체를 스트림 지정자로 사용 시 호환되지 않을 가능성이 있기 때문이다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 21.6<br/>]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2012 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_C_2012_22_06</rule>
    <ruleTitle><![CDATA[FILE 객체를 가리키는 포인터를 해당 스트림이 닫힌 후에 사용하면 안 됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
표준에서는 FILE 객체의 해당 스트림이 닫힌 후에는 FILE 포인터의 값은 불확실하다고 기술되어 있다. 따라서 이 포인터의 값을 사용하는 것은 안전하지 않다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Dir 4.13, Rule 21.6<br/>]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>API00_C</rule>
    <ruleTitle><![CDATA[FILE 타입을 파라미터로 가지는 함수에서 파라미터에 대한 검증이 존재하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C와 C++커뮤니티에서 방어적인 프로그래밍의 일부로 거론 되어지는 함수 호출자와 피호출자에서 일어나는 중복되는 검증의 큰 문제는 퍼포먼스에 있다. 어느 한쪽에서만 검증이 이루어지는 체계가 필요하다. 호출자에서 검증이 이루어지면 잘못된 값이 인자로 전달되는 자체를 막아주기 때문에 효율적이다. 피호출자에서 검증이 이루어지면 코드가 한 부분에 캡슐화되어 코드의 양이 줄고 일관적인 검증이 가능해진다. 안전과 보안상의 이유로 이 표준에서는 피호출자에서 파라미터를 검증하는 것을 추천한다.  ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>API03_C</rule>
    <ruleTitle><![CDATA[표준 라이브러리에 있는 매크로,객체,함수들의 이름은 재사용 되어선 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 라이브러리 함수는 지속적으로 사용가능한 인터페이스가 되도록 유지되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>API04_C</rule>
    <ruleTitle><![CDATA[일관적으로 사용 가능한 오류 처리 메커니즘을 사용하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ strlcpy()는 strcpy()보다 안전하고 일관적으로 설계되었으나 오류 처리에 대해서는 사용자가 직접 코드를 작성해야 한다. strcpy_m()은 오류 값을 반환하기 때문에 보다 일관적으로 구현이 가능하다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>API07_C</rule>
    <ruleTitle><![CDATA[타입의 안전성을 보장하는 함수 사용 권장 ]]></ruleTitle>
    <ruleDesc><![CDATA[ strncpy()는 결과 문자열이 null로 종료된다는 것을 보장하지 않는다. 따라서 결과 문자열이 null로 종료되지 않았을 경우를 반환값으로 검사할 수 있는 strncpy_s()의 사용을 권장한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>API09_C</rule>
    <ruleTitle><![CDATA[호환되는 값은 같은 타입을 가져야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 호환되는 값은 같은 타입을 가져야 한다. 예를 들어 어떤 함수의 반환값이 다른 함수의 인자로 사용된다고 할 때, 해당 타입들은 같은 타입을 가지도록 해야 묵시적인 변환으로 부터 발생하는 오류를 줄일 수 있다. 쉽게 범할 수 있는 오류로 size_t 타입과 ssize_t 타입을 구분없이 사용하는 경우가 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>ARR02_C</rule>
    <ruleTitle><![CDATA[배열의 사이즈 명시되고 initialize와 일치하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C표준은 bound와 초기화 literal로 선언되는 배열 변수를 허용한다. 초기화 literal은 또한 명세된 원소들의 수 이내의 배열 bound를 뜻한다. 
컴파일러들이 그들의 초기화 목록에 기반한 배열의 크기를 계산할수 있지만, 명시적으로 배열의 크기를 명세하는것은 배열 크기가 올바른지를 확인할수 있는 여분의 검사를 제공한다. 그것은 또한 컴파일러에게 배열크기 초기화에 의해 암시되는 크기보다 작으면 경고를 해줄수 있도록 한다. 
이 제안은 (모든 경우에서) string literal로 초기화되는 charcter배열에는 적용하지 않는다. STR36_C를 참조. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>ARR30_C</rule>
    <ruleTitle><![CDATA[배열의 인덱스가 유효한 범위 안에 있음을 보장해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 아래 식에서, index가 0보다 작을때 return 문장에서 증가 식의 동작은 undefined 43 이다. 어떤 구현체에서 증가는 하드웨어 trap을 작동시킬수 있다. 또 다른 구현체에서 증가는 역참조되었을때 하드웨어 trap을 작동시키는 결과를 만들어낼수 있다. 또 다른 구현체는 테이블로부터 동떨어진 object를 가리키는 포인터를 역참조하는 포인터를 만들어낼수도 있다. object에 접근하는 이러한 포인터를 사용하는것은 정보를 노출하거나 잘못된 object 변경되는 경우를 일으키도록 유도할수 있다. 

int* f(int index) { 
... 
static int table[TABLESIZE]; 
... 
return table + index; 
}  ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>ARR31_C</rule>
    <ruleTitle><![CDATA[Array 변수의 선언마다 type이 일치하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 배열은 관련된 모든 소스파일에 대해서 일관적인 타입을 사용해야 한다. 단, 같은 파일 내에서 배열이 함수의 인자로 전달되면 포인터로 변환되기 때문에 이 경우에는 강하게 요구되지 않는다. 그러나 함수 프로토타입 밖에서는, 만약 배열이 한 파일에서 포인터 표기를 사용해 선언되었지만 다른 파일에서 배열 표기로 사용되고 있다면, 두 표기는 같지 않다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>ARR32_C</rule>
    <ruleTitle><![CDATA[가변길이배열의 인덱스가 유효한지 검사]]></ruleTitle>
    <ruleDesc><![CDATA[ Variable-length arrays (VLA) 는 그들이 integer 상수 식이 아닌 크기로 선언되고 block 스코프 또는 함수 prototype 스코프에서만 선언될수 있고 linkage를 가지지 않는 점을 제외하고 본질적으로 전통적인 C 배열과 같다. variable-length array 는 integer 식의 크기와 vla의 선언이 둘다 실행시간에 평가되는 곳에서 선언될수 있다. variable-length array 에 제공되는 크기 argument가 양의 integer 값이 아니면 undefined behavior 이다(C99의 Annex J 의 undefined behavior 69 참고). 더해서, argument의 크기가 과도하면 프로그램이 예측하지 못한방식으로 동작할수 있다. 공격자는 치명적인 프로그램 데이타를 덮어씀으로서 이 동작을 유발시킬수 있다[Griffiths 2006]. 프로그래머는 반드시 variable-length arrays로의 크기 argument 가 올바른지 예외적 integer 조건의 결과로 인해 깨져있지는 않은지 확인해야 한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>ARR33_C</rule>
    <ruleTitle><![CDATA[memcpy 함수 사용시 배열에 복사 할 때 오버플로가 발생하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 데이터를 배열에 복사할 때 충분한 공간을 확보하지 않으면 오버플로가 발생한다.  ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>ARR34_C</rule>
    <ruleTitle><![CDATA[배열 타입에 대한 incompatible type 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C99  section 6.7.5.2 에 따라, 식에 둘 혹은 그 이상의 incompatible array 사용은 undefined behavior를 일으킨다. Appendix J의 undefined behavior 70 참조. compatible해져야 할 두 array 타입에 대해, 양쪽은 compatible underlying element type을 가져야 하고 , 양쪽의 size specifier는 같은 상수값을 가져야 한다. 둘중 하나가 위배되면 undefined behavior를 일으킨다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>ARR36_C</rule>
    <ruleTitle><![CDATA[포인터 타입에 대한 >, >=, <. <= 연산은 같은 배열의 요소에 대한 pointer에 대해서만 적용 가능 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 두 개의 포인터로 뺄셈을 수행하려면 두 포인터가 같은 배열을 참조하거나 적어도 배열의 마지막 원소 다음 부분을 가리키고 있어야 한다. 이때 결과 값은 배열에서 두 원소 간의 거리가 된다. 이때 C에서의 포인터 뺄셈은 두 포인터 간의 객체 수를 나타내며 바이트 수를 나타내진 않는다는 제한이 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>ARR37_C</rule>
    <ruleTitle><![CDATA[pointer 연산은 배열이나 배열 요소에 대한 pointer만 적용 가능 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 배열의 원소를 참조하는 포인터에 대해서만 산술 연산을 수행해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>CON33_C</rule>
    <ruleTitle><![CDATA[라이브러리 함수 사용 시 발생할 수 있는 race condition을 방어하는 함수 사용 권장 ]]></ruleTitle>
    <ruleDesc><![CDATA[ strerror()는 사람이 읽을 수 있는 오류 내용을 반환한다. 하지만 이 오류 문자열은 다른 스레드에서 접근하고 수정이 가능하기 때문에 항상 일정하게 오류 문자열을 출력하는 것을 보장할 수 없다. 따라서 스레드 안정성을 보장하는 strerror_r()의 사용을 권장한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>DCL01_C</rule>
    <ruleTitle><![CDATA[scope상에서 동일한 identifier 가리는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 한 스코프 영역이 다른 스코프 영역 안에 포함돼 있는 경우 두 스코프에서 동일한 변수 이름을 사용하지 마라. 변수 이름을 재사용할 경우, 프로그래머 입장에선 어떤 변수가 변경되고 있는지 헷갈린다. 변수 이름이 재사용되고 있는 자체가 이름이 너무 일반적이라는 점을 알려준다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>DCL02_C</rule>
    <ruleTitle><![CDATA[identifier에 혼동 가능한 문자 사용 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 유사한 이름을 가지는 identifier 사이에서 혼동의 여지가 있는 문자의 사용을 검사한다. 혼란의 여지가 있는 문자들로는 여러가지가 있지만, 식별이 어려워 문제가 야기될 것이라 판단되는 0(zero)-O(capital o), 1(one)-l(lowercase L)-I(capital i)에 대해 검사한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>DCL03_C</rule>
    <ruleTitle><![CDATA[assert 매크로 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ runtime assert는 incorrect assumptions 을 확인하기 위해서만 사용해야 하고, runtime error checking 에서는 사용해서는 안된다. 결과적으로 runtime assertions 은 일반적으로  unsuitable 하다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>DCL04_C</rule>
    <ruleTitle><![CDATA[하나의 선언문에 2개 이상의 변수선언 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 모든 선언은 그 라인에 변수의 역할에 대한 설명 comment 가 있는 단일한 변수만을 위한 것이이어야 한다. 하나의 선언문에 다중 변수 선언은 변수들의 타입과 그들의 초기값에 관해서 혼란을 일으킬수 있다. 만약 하나이상의 변수가 하나의 선언문에 선언되면, 반드시 변수의 타입과 초기화 값에 주의해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>DCL05_C</rule>
    <ruleTitle><![CDATA[function pointer type을 typedef로 사용했는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 코드의 가독성을 높이기 위해 타입 정의(typedef)를 사용하는 것을 권장한다. 함수 포인터 타입의 경우에는 타입 정의를 사용하지 않으면 읽기 어렵고 이해하기도 힘들어진다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>DCL07_C</rule>
    <ruleTitle><![CDATA[함수 정의 시 old style parameter 선언 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수는 정확한 타입 선언 정보를 가진 형태로 정의되어야 한다. 만약 함수 선언이 명확하게 구체화되지 않은 경우, 컴파일러에서 함수 타입 정보에 대한 정확한 검사를 할 수 없게 된다. 검사의 일환으로 NonPrototype-Format 선언을 금지한다. C99 표준에서 파라미터 식별자와 선언리스트의 분리는 구식의 방법이라 말하고 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>DCL08_C</rule>
    <ruleTitle><![CDATA[상수 정의에 상수간의 관계가 적절히 나타나게 정의되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 한 정의가 다른 정의에 영향을 미친다면 둘 간의 관계를 인코딩하고 각각을 따로 정의하지 마라.  ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>DCL13_C</rule>
    <ruleTitle><![CDATA[포인터 타입의 인자가 수정되지 않았을 때 const가 선언되었는지 여부 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수의 매개 변수를 const로 선언하는 것은 함수가 그 값을 바꾸지 않는다고 약속하는 것과 같다. 함수는 포인터 인자로 참조되는 값을 수정할 수도 있고, 이렇게 수정된 값은 함수가 반환한 후에도 지속된다. 포인터가 참조하는 값을 바꾼 부분은 의도적일 수 있기 때문에 컴파일러가 이를 검사하지는 않는다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>DCL15_C</rule>
    <ruleTitle><![CDATA[하나의 파일에서만 쓰인 파일 scope 변수나 함수가 internal linkage를 가지는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 객체나 함수가 현재 스코프 밖에서 보일 필요가 없다면 static으로 선언되어 외부로부터 가려져야 한다. 이렇게 하면 모듈화된 코드를 만들고 전역 네임스페이스가 복잡해지는 것을 제한할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>DCL19_C</rule>
    <ruleTitle><![CDATA[변수나 함수가 사용 가능한 최소 범위에서 선언되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 변수와 함수는 사용 가능한 최소 범위에서 선언되어야 한다. 더 큰 스코프에서 사용할 수 있도록 하는 것은 가독성이 떨어지고, 유지가 어려워진다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>DCL20_C</rule>
    <ruleTitle><![CDATA[함수 선언과 정의시 파라미터가 없을 경우 명시적인 void 타입 파라미터를 선언했는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수에 인자가 없는 경우라도 반드시 void를 명시해주어야 컴파일러에서 파라미터를 가진 함수인지 검사하지 않는다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>DCL30_C</rule>
    <ruleTitle><![CDATA[automatic 객체의 주소는 그것이 더이상 존재하지 않게 된 후에도 남아있을수 있는 다른 객체에 할당되면 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 객체는 프로그램 수행 시 자신에게 할당된 저장공간이 있는 부분에 존재한다. 객체가 상수 주소를 갖고 존재한다면 자신의 수명 내에서 마지막으로 저장된 값을 계속 유지하고 있을 것이다. 객체가 자신의 수명을 다한 후에도 참조된다면, 정의되지 않은 행동을 유발할 수 있다. 수명을 다한 객체를 참조하는 포인터 역시 정의되지 않은 값을 갖게 된다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>DCL31_C</rule>
    <ruleTitle><![CDATA[함수나 변수의 선언이나 정의 시 type을 명시하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C99 표준은 타입 지정을 항상 요구하고 암시적 함수 선언을 금지한다. 하지만 컴파일러는 이 제한이 나오기 전에 만들어진 코드들과의 호환을 위해 먼저 코드를 진단해보고 암시적 선언을 허용하는 것으로 가정해 컴파일한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>DCL32_C</rule>
    <ruleTitle><![CDATA[External identifier가 식별 가능한지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ external identifier는 31번 째 문자까지 식별이 가능하다. 따라서 길이가 31이 넘는 external identifier에 대해서 31번째문자 까지가 다른 external identifier에 대해 유일하여 식별 가능한지 확인해야 한다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>DCL35_C</rule>
    <ruleTitle><![CDATA[function pointer 변수에 return 타입이 일치하지 않는 function assign 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ function pointer 변수에 return 타입이 일치하지 않는 function assign하였는지 검사한다. function pointer에 대응하는 function의 타입이 compatible하지 않으면, function pointer를 사용시 undefined behavior가 발생한다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>DCL36_C</rule>
    <ruleTitle><![CDATA[함수나 변수의 선언마다 type이 호환되는지(compatible) 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 다른 스코프에서 정의된 식별자나 한 스코프에서 여러 번 선언된 식별자는 링크 과정을 통해 같은 객체나 함수를 참조할 수 있다. 식별자는 외부 링크, 내부 링크, 링크 없음으로 분류된다. 외부 링크와 내부 링크를 모두 갖는 것으로 분류되는 식별자를 사용하면 정의되지 않은 행동을 초래할 수 있다. 컴파일 단위는 전처리 지시자 #include 로 포함되는 모든 소스와 헤더 파일과 소스 파일 자체를 포함한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>DCL37_C</rule>
    <ruleTitle><![CDATA[예약된 식별자를 재선언하거나 재정의 하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 예약된 식별자를 재선언 하거나 재정의 하여 사용하는 것은 정의되지 않은 행동을 유발한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>ENV30_C</rule>
    <ruleTitle><![CDATA[getenv(), setlocale(), localeconv(), strerror() 함수들의 반환 값을 변경하면 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ getenv(), setlocale(), localeconv(), strerror() 함수들의 반환 값을 변경하는 것은 undefined behavior를 유발한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>ENV31_C</rule>
    <ruleTitle><![CDATA[ setenv(), _putenv_s() 함수 호출 후 main() 함수의 세번 째 인자 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 윈도우 _putenv_s() 함수를 호출했거나 환경변수를 수정하는 다른 값을 수정한 경우라면 envp 포인터는 더 이상 환경변수를 참조하고 있지 않을 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>ENV32_C</rule>
    <ruleTitle><![CDATA[atexit 핸들러에서 반환 이외의 방법으로 종료(exit, longjmp)되면 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ atexit() 에 등록된 핸들러는 어떤 방법으로도 반환하지 않고 직접 프로그램을 종료해서는 안된다. atexit() 핸들러 전부가 클린업 동작을 수행하게 해주는 일은 매우 중요하며, 보안에 민감한 부분이기도 하다. 특별히 애플리케이션 프로그래머가 알지 못하는 지원 라이브러리에 의해 핸들러가 설치된 경우 더욱 그렇다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>ERR02_C</rule>
    <ruleTitle><![CDATA[sprintf 함수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ sprintf 함수 대신 오류 코드를 반환하는 sprint_m의 사용을 권장한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>ERR03_C</rule>
    <ruleTitle><![CDATA[TR 24731-1에 정의된 함수를 호출할 때는 런타임 지정 핸들러를 사용하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ ISO/IEC TR 24731-1-2007 에 의해 정의된 대부분 함수들은 그들의 명세의 일부로서 실행시간 제약들의 목록인 실행시간에 다루어질수 있는 위배사항들을 포함한다[ISO/IEC TR 24731-1:2007]. 라이브러리 구현체는 함수에 대한 실행시간 제약들이 프로그램에 의해 위배되지는 않았는지 반드시 검사해야한다. 만약 실행시간 제약들이 위배되면, 일반적으로 set_constraint_handler_s()로 등록한 실행시간 제약 핸들러가 호출된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>ERR07_C</rule>
    <ruleTitle><![CDATA[동일한 기능을 하는 함수라면 오류 검사를 제공하는 함수 사용을 권장 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 동일한 기능을 수행하는 두 개의 함수 중 하나를 선택해야 한다면, 오류를 검사하고 보고해주는 함수를 사용할 것을 권장한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>ERR30_C</rule>
    <ruleTitle><![CDATA[errno를 사용하는 라이브러리 함수를 호출하기 전에 errno 값을 0으로 설정 ]]></ruleTitle>
    <ruleDesc><![CDATA[ errno의 값은 프로그램 기동시에 0 이지만, 어떤 라이브러리 함수에 의해서도 결코 0으로 설정되지 않는다. errno의 값은 C standard 에서 errno의 사용이 함수 설명에 기술되지 않은 라이브러리 함수 호출에 의해서 그것에 에러가 있건 없건간에 0이 아닌값으로 설정될수 있다. 그것은 단지 프로그램에 대해 오류가 보고된 이후 errno의 내용을  조사하기 위한 의미가 있을 뿐이다. 더 정확하게는, errno는 에러 코드를 반환한 에러로 errno를 설정하는 라이브리러 함수 이후에만 의미가 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>ERR32_C</rule>
    <ruleTitle><![CDATA[시그널 핸들러에서의 금지함수 ]]></ruleTitle>
    <ruleDesc><![CDATA[ [ISO/IEC 9899-1999]에 따르면 abort 또는 raise 함수, 그리고 signal 함수 호출로부터 리턴되는 SIG_ERR을 취한 그에 대응하는 signal handler 호출의 결과로서가 아닌 signal 발생 이후의 errno의 값이 참조될때, 프로그램은 undefined behavior이다. (Annex J 의 undefined behavior 126 참고) 
signal handler는 signal()을 호출하도록 허용되고 만약 실해하면 signal()은 SIG_ERR를 반환하고 errno을 양의 값으로 설정한다. 그러나 signal을 일으킨 사건이 external 이었다면 signal handler 가 호출하게 될 함수는 _Exit() 또는 abort() 또는 현재 처리중인 signal 상의 signal() 뿐이고, signal()이 실패하면 errno값은 정해지지 않는다. 
이 규칙은 SIG31_C의 특별한 경우이다. errno에 의해 지정되는 객체는 static 저장소 수명을 가지고 volatile sig_atomic_t 가 아니다. 결과적으로, errno가 설정될 필요가 있을 어떤 액션을 취하는것은 대개 undefined behavior를 일으킬것이다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>ERR33_C</rule>
    <ruleTitle><![CDATA[함수의 반환값에 대해 오류 검증을 하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 많은 함수는 유효한 값을 반환하기도 하고 -1이나 null 포인터와 같은 오류 값을 반환하기도 한다. 함수의 성공적인 수행을 확인하기 위하여 반환값을 검사해야 한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP00_C</rule>
    <ruleTitle><![CDATA[우선 순위가 다른 연산자 혼용 시 괄호를 사용하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 우선 순위가 다른 연산자 혼용 시 괄호를 사용할 것을 권장한다. 연산자의 우선 순위를 완벽히 이해하지 못 한 채로 혼용하는 경우 의도와 다른 결과를 초래할 수 있기 때문이다.  ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP01_C</rule>
    <ruleTitle><![CDATA[sizeof()의 인자로 포인터 변수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 특정 타입의 사이즈를 결정할 때 포인터 타입의 사이즈를 사용하면 안된다. 포인터 타입의 사이즈는 포인터가 가리키는 타입의 사이즈가 아니다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP02_C</rule>
    <ruleTitle><![CDATA[논리연산자 && 과 || 의 오른쪽 피연산자에 side effect 포함금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 논리 AND와 논리 OR 연산자는 단축 평가를 수행한다. 즉 첫 번째 피연산자로 평가가 완료된 경우 두 번째 피연산자는 평가하지 않는다. 따라서 두 번째 연산자가 부수 효과를 갖고 있다면 이 부수 효과가 실제로 발생하는지 보이지 않으므로 주의해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP04_C</rule>
    <ruleTitle><![CDATA[함수 memcmp의 인자로 구조체 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 구조체는 메모리상으로 정렬시키기 위해 data가 pad된다. 이 pading의 내용이나 추가되는 패딩의 크기는 unspecified이다. 따라서 구조체 사이에 바이트단위의 비교가 시도된다면 그 결과가 부정확 할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP05_C</rule>
    <ruleTitle><![CDATA[const를 명시적으로 제거하는 타입 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 포인터의 const qualification을 명시적으로 제거하는 타입 변환을 검사한다. const qualifiication이 제거되면 프로그램이 해당 포인터에 참조되는 object를 수정할 수 있게 되면, 그 결과는 undefined behavior이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP06_C</rule>
    <ruleTitle><![CDATA[sizeof 연산자에 side effect expression 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ sizeof 연산자는 피연산자의 크기를 바이트 단위로 알려준다. 피연산자는 표현식일 수도 있고 괄호로 묶인 타입 이름일 수도 있다. 피연산자의 타입이 가변 배열 타입이 아닌 경우에는 평가되지 않는다. 부수 효과를 가져올 수 있는 표현식이 제공되는 경우에는 표현식이 평가되지 않았다는 사실을 모르는 프로그래머에게는 혼란을 줄 수 있다. 결국 프로그래머는 프로그램의 상태에 대해 유효하지 않은 가정을 하고, 이는 에러나 소프트웨어의 취약성으로 이어진다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP09_C</rule>
    <ruleTitle><![CDATA[메모리 할당 함수의 할당 크기를 입력하는 인자에 sizeof를 포함한 expression을 사용했는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 타입의 사이즈를 하드코딩 하면 안된다. 기본 타입의 사이즈는 컴파일러에 따라 혹은 같은 컴파일러 사이에도 버전에 따라 달라질 수 있기 때문이다. 따라서 sizeof 연산자의 사용을 권장한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP10_C</rule>
    <ruleTitle><![CDATA[하위 표현식의 평가 순서에 의존하지 않도록 하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 하위 표현식의 평가나 부수 효과가 발생하는 순서가 지정돼 있지 않은 경우는 다음과 같다. 1.함수에 주어진 인자가 평가되는 순서 2.할당문에서 피연산자가 평가되는 순서 3.초기화 표현식에서 나열된 객체들이 부수 효과를 갖는 순서는 지정돼 있지 않다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP11_C</rule>
    <ruleTitle><![CDATA[integer type과 floating type 간 명시적 타입 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ incompatible type 사이의 타입 변환을 금지한다. integer type과 floating type 간의 명시적인 타입 변환은 기대하는 값과 다른 엉뚱한 값을 발생시킬 우려가 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP12_C</rule>
    <ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수는 side effect를 가지는지 여부와 상관없이 유용한 값을 반환한다. 대부분의 경우 이 값은 함수가 성공적으로 수행되었는 또는 어떤 에러가 발생했는지 여부를 나타낸다. 혹은, 어떤 계산의 결과값을 가지기도 한다. 만약 반환 값이 있는 함수에 대해서는 그 의미있는 반환 값을 사용하는지 검사해야 한다. 만약 반환 값을 사용할 필요가 없는 함수라면 반환 타입을 void로 하도록 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP13_C</rule>
    <ruleTitle><![CDATA[relational, equality 연산자가 결합되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 비교 또는 동등 연산자는 좌측부터 결합된다. 이 연산자들의 결합은 일반적인 결합과 다른 결과를 가진다. a &lt; b &lt; c 의 결과값은 해당 expression 자체의 참 거짓이 아니라, 만약 a가 b보다 큰 경우 1과 c를 비교하게 된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP14_C</rule>
    <ruleTitle><![CDATA[underlying type unsigned char, unsigned short에 대해 bitwise operator(~, <<) 사용시 해당 underlying type으로의 명시적 변환 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ int보다 작은 정수 타입에 대한 bitwise 연산에서는 예상치 못한 결과값이 발생할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP16_C</rule>
    <ruleTitle><![CDATA[함수 이름이 호출식이나 주소연산자(&)가 붙은 형태로만 사용되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ null이 아닌 함수의 포인터를 비교하는 표현식은 대부분 프로그래머의 실수로 그 결과는 정의되지 않는 행동을 유발한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP17_C</rule>
    <ruleTitle><![CDATA[조건문에서 bitwise 연산자 (&,|) 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ bitwise AND (&, ampersand) 또는 bitwise OR (|, pipe) 연산자를 조건식에서 사용하지 말라.  이것은 전형적으로 프로그래머에게 실수를 유발하고 예측하지 못한 작동을 하는 결과가 될수 있다. & 또는 | 는 bitwise 연산에서만 쓰고, && 또는 || 는 논리 연산에서만 써야한다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP18_C</rule>
    <ruleTitle><![CDATA[condition에 assignment 연산자 사용금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 조건문이나 반목문의 조건절의 최상위 표현식에 대입연산자를 사용하면 안된다. 이는 대개 개발자의 실수이며 예상하지 못한 결과를 유발한다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP19_C</rule>
    <ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[Statement의 body가 하나의 statement만을 가지고 있더라도, 항상 body는 block으로 처리해야 한다. 이는 코드의 통일성과 가독성을 향상시킨다. 더욱 중요한 것은, 하나의 statement만 가지는 body에 statement를 추가할 때, brace를 추가하지 않아서 잘못된 코드가 만들어 질 수 있다는 점이다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP20_C</rule>
    <ruleTitle><![CDATA[가독성 향상을 위해 조건 구문을 명시적으로 표기하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 코드의 가독성을 높이기 위하여 성공, 참/거짓, 동등 여부를 표현하는 것이 좋다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP30_C</rule>
    <ruleTitle><![CDATA[평가순서에 따라 결과가 달라지는 문장사용금지 (sequence point detection) ]]></ruleTitle>
    <ruleDesc><![CDATA[ 표현식의 평가는 부수 효과를 가져오는데, 이 때 이전 평가 단계에서의 모든 부수 효과가 발생하고 다음 평가 단계에서의 부수 효과가 아무것도 발생하지 않은 지점에 해당하는 시퀀스 포인트라는 샐행 지점이 있다. C99의 6.5절에 따르면, 이전과 다음 시퀀스 포인트 사이의 객체는, 객체에 저장된 값을 표현식 평가로 한 번 수정할 수 있다. 또한 이전 값은 저장될 값을 결정하려는 목적으로만 읽을 수 있다. 이 요구사항은 전체 표현식의 모든 가능한 하위 표현식의 순서에 대해 만족돼야 한다. 그렇지 않다면 어떤 행동을 할지 예측할 수 없다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP31_C</rule>
    <ruleTitle><![CDATA[assert 매크로의 인자로 side-effect 포함 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ assert() 매크로는 코드안에서 진단 테스트를 짜넣기 편리하게 동작한다 (제안 MSC11_C참고) 표준 assert 매크로와 함께 사용된 표현식은 side effect를 가져서는 안된다. 전형적으로, assert 매크로의 동작은 NDEBUG 전처리 심볼의 상태에 의존적이다. NDEBUG가 정의되어있지 않으면, assert 매크로는 그것의 인지 표현식을 평가하도록 정의되고 표현식의 결과가 false 로 변환가능하다면 프로그램을 중단시킨다. NDEBUG가 정의되어 있으면 assert는 아무 동작도 하지 않도록 정의된다. 따라서, assertion에서 표현식의 평가로부터 도출되는 어떤 side effect 는 디버깅버젼이 아닌 코드에서는 잃어버리게 된다. 
assert는 매크로이기 때문에, 이 룰은 PRE31_C의 특별한 케이스이다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP32_C</rule>
    <ruleTitle><![CDATA[volatile을 제거하는 명시적 타입 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 포인터의 volatile qualification을 명시적으로 제거하는 타입 변환을 검사한다. volatile object가 non-volatile value의 사용에 의해 참조될 수 있으면 그 결과는 undefined behavior이다.  ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP33_C</rule>
    <ruleTitle><![CDATA[변수 사용 전 값 할당 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 로컬의 자동 변수는 초기화되기 전에 사용될 경우 이상한 값이 들어 있다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP34_C</rule>
    <ruleTitle><![CDATA[메모리 할당 함수의 반환값이 검증되지 않아 null 포인터 참조가 시도되는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ null 포인터 결과값을 참조하려는 시도는 undefined behavior이다.  ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP35_C</rule>
    <ruleTitle><![CDATA[함수의 반환 값을 인접한 다음 시퀀스 포인트에서 접근하거나 수정하지 마라 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 호출의 결과 값을 다음 시퀀스 포인트 후에 접근 또느 수정하려고 한다면 정의되지 않은 결과를 얻게 된다. C함수는 배열을 반환할 수 없다. 하지만 배열을 가진 구조체나 공용체는 반환할 수 있다. 만약 함수 호출 후 얻은 반환 값에 배열이 있다면 그 배열은 표현식 내에서 접근되거나 수정되면 안된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP36_C</rule>
    <ruleTitle><![CDATA[pointer type의 변환 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 다른 타입의 객체에 대해서는 다른 타입의 정렬이 가능하다. 명시적인 캐스팅이나 포인터가 void 포인터로 변환됐다가 다른 타입으로 변경되는 경우로 인해 타입 체크 시스템이 무효화된다면, 객체의 정렬도 바뀔 수 있다. 그 결과 한 객체에 대한 포인터가 다른 객체에 대한 타입으로 변경된 경우, 두 번째 객체의 타입은 처음 것보다 덜 엄격한 정렬을 요구해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP37_C</rule>
    <ruleTitle><![CDATA[특정 함수의 특정 인자가 존재하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ POSIX 함수 open()은 세 번째 인자로 생성된 파일에 접근하는 모드를 결정하는 가변인자를 가진 함수다. 새로운 파일을 생성하기 위해 open()을 사용하고 세 번째 인자를 생략한다면, 파일은 의도하지 않은 접근 권한을 갖고 생성될 것이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>EXP40_C</rule>
    <ruleTitle><![CDATA[const-qualified 타입의 변수가 수정되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ const-qualified 타입의 object를 non-const-qualified 타입의 lvalue를 사용하여 수정하는 것은 undefined behavior를 유발한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>FIO04_C</rule>
    <ruleTitle><![CDATA[입출력 함수의 성공 또는 실패 여부를 나타내는 반환값이 검증되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 입출력 함수는 성공 또는 실패 여부를 명백히 나타낸다. 실패한 경우에 반환된 값을 그대로 사용하는 경우 undefined behavior가 발생할 수 있다. 따라서, 입출력 함수의 결과값은 검사되어야 하고 에러가 발생한 경우에는 적절한 에러 처리가 필요하다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>FIO07_C</rule>
    <ruleTitle><![CDATA[rewind() 보다 fseek() 사용 권장 ]]></ruleTitle>
    <ruleDesc><![CDATA[ fseek()을 사용하는 것이 rewind()를 사용하는 것 보다 오류를 처리하는 능력이 뛰어나다. 따라서 fseek()의 사용을 권장한다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>FIO08_C</rule>
    <ruleTitle><![CDATA[remove() 함수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ remove()함수는 이미 열려 있는 파일에 대하여 호출될 경우에 대한 행동이 정의되어 있지 않다. 따라서 remove() 보다는 unlink()를 권장한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>FIO11_C</rule>
    <ruleTitle><![CDATA[함수 fopen 호출 시 지정된 mode 문자열을 사용해야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ C표준은 fopen() 함수 호출에 대해 mode로 사용할 수 있는 지정된 문자열을 식별한다. 표준을 따르고 호환 가능하게 하려면 반드시 지정된 문자열 중 하나를 써야 한다. (지정된 문자열 목록: r, w, a, rb, wb, ab, r+, w+, a+, r+b, rb+, w+b, wb+, a+b, ab+) ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>FIO12_C</rule>
    <ruleTitle><![CDATA[setbuf() 보다 setvbuf() 사용 권장 ]]></ruleTitle>
    <ruleDesc><![CDATA[ setbuf()을 사용하는 것이 setvbuf()를 사용하는 것 보다 오류를 처리하는 능력이 뛰어나다. 따라서 setvbuf()의 사용을 권장한다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>FIO33_C</rule>
    <ruleTitle><![CDATA[입출력 함수의 반환값이 검증되지 않아 변수가 초기화되지 않은 상태로 사용되는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 입출력 함수가 정상적으로 수행되지 않은 경우, 반환값을 받는 변수가 초기화 되지 않은 상태로 남아있을 수 있다. 그 변수를 사용하는 경우에 발생할 수 있는 undefined behavior를 피하기 위해 함수 수행 실패에 대한 검증이 있어야 한다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>FIO34_C</rule>
    <ruleTitle><![CDATA[plain char/signed char 타입 사용 금지 상황 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 문자 입/출력 함수들  fgetc(), getc(), getchar() 는 모두 스트림으로 부터 문자를 읽고 int로 반환한다. 스트림이 end-of-file에 도달하면 end-of-file 지시자가 설정되고 함수는 EOF를 반환한다. 문자 입/출력 함수 fputc(), putc(), putchar(), ungetc() 또한 문자 또는 EOF를 반환한다. 
문자 입/출력 함수에 의해 반환되는 값은 그 값이  EOF 와 비교될것이라면 char 로 변환하지 말아야한다. 이들 함수의 반환값이 일단 char 타입으로 변환되면 문자값들이 EOF 와 구분할수 없게될수 있다. 또한  sizeof(int) == sizeof(char) 이면, 반환값을 capture 하기 위해 사용한 int 는 EOF 와 구분할수 없게될수 있다. sizeof(int) == sizeof(char) 에 대한 자세한 사항은 FIO35_C 를 참고. 올바른 문자 타입 사용에 대한 정보는 제안 STR00_C 를 참고. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>FIO38_C</rule>
    <ruleTitle><![CDATA[FILE 타입끼리 assign하면 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 스트림을 제어하는데 사용하는 FILE 객체에서는 주소 값이 중요하다. 하지만 복사된 FILE 객체는 원래 주소를 보존할 필요가 없다. 따라서 입출력 연산 시 FILE 객체를 복사해 사용하지 않는 것이 좋다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>FIO39_C</rule>
    <ruleTitle><![CDATA[파일 입출력 사이에 플러시나 파일 위치 조정 함수가 존재하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 파일 스트림에 대해서 입력 다음에 fflush 호출이나 파일 위치 조정 함수(fseek, fsetpos, rewind)의 호출 없이 바로 출력을 수행하면 안되며, 반대로 출력 다음에 파일 위치 조정 함수 없이 바로(입력에서 파일 끝에 도달하지 않은 이상) 입력을 수행하면 안된다. 구현에 따라서 텍스트 파일을 업데이트 모드로 여는 것(혹은 생성하는 것)이 실제로는 바이너리 스트림을 열 수도 있다.  ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>FIO41_C</rule>
    <ruleTitle><![CDATA[특정 매크로 함수의 인자에 side-effect 포함 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ side-effect를 가지는 stream 인자를 getc()나 putc()에 전달할 경우 예상하지 못한 결과가 발생할 수 있다. 따라서 해당 함수의 인자로 side-effect를 가지는 expression을 사용하지 말아야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>FIO44_C</rule>
    <ruleTitle><![CDATA[fsetpos()에 fgetpos()에서 반환된 값을 사용했는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ fsetpos 함수는 stream이 가리키는 스트림에서 pos로 표시되는 객체의 값에 따라 mbstate_t 객체와 파일 위치 표시자를 설정한다. 이때 pos는 같은 파일 스트림에 대해 fgetpos 함수를 호출해 성공적으로 반환된 값이어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>FLP02_C</rule>
    <ruleTitle><![CDATA[floating point 수식은 equality 검사에서 사용금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 컴퓨터는 유한한 개수의 숫자를 표현할 수 있다. 따라서 반복되는 이진 표기값을 정확하게 표현하는 것은 이진 부동소수점을 가진 대부분의 부동 소수점 표현으로는 불가능하다. 즉, 부동 소수점 연산에서는 정확하지 않은 결과가 발생할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>FLP03_C</rule>
    <ruleTitle><![CDATA[floating 오류 처리 루틴 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ floating-point 연산중의 에러는 연산 전에 피연산자를 확인하는데 집중하는 프로그래머에 의해 자주 무시된다. floating-point 연산중에 발생하는 에러는 일반적으로 인정하는 바와 같이 결정과 진단이 어렵지만, 그렇게 함으로써 얻어지는 이점은 비용을 무릅쓸 만하다. 이 제안은 floating-point 연산중의 에러를 잡는 방향을 제시한다. 
floating-point 예외 조건이 일어났는지를 결정하는 가장 portable한 방식은 C99에 의해 제공되는 fenv.h 의 floating-point 예외 장치를 사용하는것이다[ISO/IEC 9899:1999]. 그러나 C99 floating-point 예외 함수들에 문제가 없지는 않다. 
덜 portable 하지만 잠재적으로 더 안전한 해법은 구현체에 의해 제공되는 특성들을 사용하는것이다. 이 접근법이 취해지면, 해당 시스템의 조건들이 잘 이해될 필요가 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>FLP04_C</rule>
    <ruleTitle><![CDATA[scanf의 float type 입력값에 대해 isinf, isnan 수행 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Floating-point 숫자는 infinity 와 NaN (not-a-number) 라는 2종류의 예외적값을 가질수 있다. 이 값들은 예외 또는 풀수없는 floating point 연산의 결과로서 반환된다. (FLP32_C 참고) 추가적으로, 그들은 사용자에 의해 scanf 혹은 유사한 함수로 직접 입력될수 있다. 그런 값들을 탐지하거나 다루는데 실패하는것은 undefined behavior를 일으킬수 있다. 
NaN 값은 특히 문제가 된다. 식 NaN==NaN (모든 가능한 NaN값에 대해) 이 false 를 반환하기 때문이다. 인자중 하나로서 NaN과 이루어진 어떤 비교는 false 를 반환한다. 그리고 NaN 상의 모든 계산 함수들은 그것들을 코드로 전파한다. 즉, 코드의 어떤 장소에 NaN 이 들어갔고, 적절히 다루어지지 않는다면, 멀리 떨어진 다른 장소에서 문제를 일으킬수 있다. 
scanf 와 같은 Formatted-input 함수들은 INF, INFINITY, NAN 값들을 %f 포맷에 대한 올바른 입력값으로 받아들일것이고, 악의적인 사용자에게 그것들을 프로그램에 직접 입력시키는것을 허용한다. 프로그램은 모든 floating point 입력값들이 이런 값들을 가지고 있지 않은지, 가지고 있다면(특히 그것들이 사용자에 의해 제외된다면) 부적절한지를 확실히 검사해야 한다. <math.h> 라이브러리는 이것을 위한 두가지 매크로를 가지고 있다: isinf, isnan ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>FLP30_C</rule>
    <ruleTitle><![CDATA[for, while, do에 대해서 floating point 수식을 조건식 및 증감식에서 사용금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ floating-point 숫자는 부분값으로 표현될수 있기때문에, 그것들이 어떤 단순한 부분값을 정확하게 표현할수 있다고 흔히 잘못 가정된다. 사실 floating-point 숫자는 integer가 그렇듯, 그리고 binary floating-point 숫자가 모든 decimal 부분들을 정확히 표현해낼수 없는것과 같이(심지어 그것이 적은수의 10진수 숫자들로 표현될수 있을지라도), 제한된 정밀도에 영향받기 쉽다.
추가적으로, floating-point 숫자는 큰 값을 표현할수 있기때문에 그것들이 그 값들의 모든 자릿수를 표현할수 있을것으로 흔히 잘못 가정된다. 큰 동작범위를 가지기 위해서 floating-point 숫자들은 정해진 수의 정확도와 지수의 비트수를 유지한다. 큰 floating-point 값의 증가는 유효한 정확도 내의 값으로의 변경이 아닐수도 있다.
다른 구현체들은 다른 정밀도제한을 가지며, 코드 이식성 유지를 위해서는 floating-point 변수들을 loop counter로 사용해서는 안된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>FLP32_C</rule>
    <ruleTitle><![CDATA[수학함수가 안전하게 사용되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C99 Section 7.12.1 은 math.h에 있는 수학함수들에 대한 두 타입의 error를 정의하고 있다.   [ISO/IEC 9899:1999]:domain error 는 입력인자가 정의된 함수의 domain을 초월했을때 error를 일으킨다.  range error 는 함수의 수학계산 결과가 명세된 타입의 object에 표현될수 없다면( extreme magnitude 로인한 경우 등) error를 일으킨다. Domain errors 는 함수 호출 전 bounds checking 으로 예방될수 있다. Range errors 는 거의 예방할수 없지만, range errors를 예방하는 대신 그것을 탐지하고 range error가 발생했을때의 사후처리를 해야한다 ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>FLP34_C</rule>
    <ruleTitle><![CDATA[floating type의 expression의 값을 다른 type으로 묵시적 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 부동소수점 값이 더 작은 범위나 정밀도를 가진 부동소수점 값으로 변환되거나 정수로 변환되는 경우, 혹은 정수가 부동 소수점으로 변환되는 경우 값은 변환될 타입으로 표현 가능해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>FLP36_C</rule>
    <ruleTitle><![CDATA[integer 타입을 floating 타입으로 묵시적인 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 작은 primitive 타입은 더 큰 타입으로 묵시적으로 변환될 수 있다. 이런 변환은 정수형 사이에서는 정확한 값을 가지지만 실수형 사이에서는 정확성이 떨어질 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>INT01_C</rule>
    <ruleTitle><![CDATA[사이즈 타입 비교 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ size_t 타입은 일반적으로 전체 공간의 주소를 커버한다. ISO/IEC TR 24731-1-2007 는 새로운 타입 rsize_t 를 소개한다. 그것은 size_t로 정의되지만 명시적으로 단일한 object의 크기를 고정하기 위해 사용된다[Meyers 2004]. 이 목적을 문서화한 rsize_t 타입을 사용하는 코드에서 object의 크기는 그것이 RSIZE_MAX보다 크지 않음을 확인하기 위해 검사될수 있다. 일반적인 단일 object의 최대크기인 RSIZE_MAX는 라이브러리 함수에 대한 추가적인 입력 validation을 제공한다. TR 24731-1 의 추가 논의사항에 대해서는 제안 STR07_C 참조. 
object의 크기를 표현하기위해 사용되는 어떤 변수 (크기,인덱스,loop counter,길이로 사용되는 integer값을 포함하는)는 가능한한 rsize_t로 선언되어야 한다. 그렇지 않을경우에는 size_t 로 선언되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>INT02_C</rule>
    <ruleTitle><![CDATA[정수 변환 규칙을 이해하고 사용하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 서로다른 타입에 대해 연산을 처리할 때에는 주의해야 한다. 정수 승계, 정수 변환 순위를 잘 이해하여 정수 변환 규칙에서 발생하는 변환들을 알고 있어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>INT03_C</rule>
    <ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
    <ruleDesc><![CDATA[ integer 취약점에 대한 방어의 최일선은 범위검사, 명시적이거나 엄격한 타입검사 이다. 신뢰할수 없는 출처로부터의 integer 값을 강제로 제한하는것도 한가지 접근방법이다(제안 INT04_C 참조). 그러나 제어될수 없는 다양한 입력 변수들이 프로그램의 어딘가의 연산에 에러를 일으키는것을 보장하기 어렵다. 
대안 혹은 보조적인 접근은 개개의 연산을 보호하는것이다. 그러나 이러한 문제에 영향받기 쉬운 큰 수의 integer연산과 예외적 상태를 방지하기 위해 요구되는 많은 검사들 때문에, 이 접근은 엄청나게 노동집약적이고 고비용의 구현이 될수 있다. 
이 문제의 좀더 경제적인 해법은 하나 또는 그 이상의 입력들이 신뢰할수 없는 출처와 결과값에 의해 영향을 받을수 있는 곳, 잘못되면 보안상 헛점을 일으킬수 있는 곳에서 integer에 대한 모든 연산에 대해 secure integer library를 사용하는것이다. 

IntegerLib 

secure integer library 의 한 예는 CERT/CC 에 의해 개발되어 자유롭게 사용 가능한 IntegerLib 이다. 
이 라이브러리의 목적은 integer overflow, integer truncation, sign error등과 같은 일반적인 integer문제로부터 자유로운, C 프로그램을 쓰는 소프트웨어개발자들을 도울수 있는 유틸리티 함수들의 모음을 제공하는것이다. 이 문제들은 소프트웨어취약점의 일반적인 출처이다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>INT05_C</rule>
    <ruleTitle><![CDATA[scanf, fscanf 사용 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 문자를 입력받고 그들을 integer로 변환하는 함수가 모든 가능한 입력에 대한 에러를 다룰수 없다면 그 함수들을 사용하지 말아야한다. 예를들면, 문자열 데이터를 stdin 또는 (fscanf()와 vscanf() 의 경우) 다른 입력 stream 으로부터 읽는데 사용될수 있는 scanf(), fscanf(), vscanf(), vfscanf() 와 같은 formatted input 함수들. 이 함수들은 올바른 integer값에 대해서는 잘 동작하지만 잘못된 값에 대해서는 강인한 에러처리가 부족하다. 
대안으로,  null-terminated 바이트 문자열로 문자 데이터를 입력받고 integer 값으로 변환하는데 strtol() 또는 관련된 함수를 사용한다. (제안 INT06_C 참고) ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>INT06_C</rule>
    <ruleTitle><![CDATA[문자를 integer로 변환하는 함수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ atoi(), atol(), atoll() 등을 이용하여 문자열 토큰을 integer로 변환하는 방법은 예상하지 못하는 오류들을 발생시킬 가능성이 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>INT07_C</rule>
    <ruleTitle><![CDATA[숫자 값의 용도로 사용되는 char에 명시적으로 signed나 unsigned를 사용하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 세 개의 타입 char, signed char, unsigned char를 통틀어 문자 타입이라고 한다. 컴파일러는 그것이 signed char이든 unsigned char이든 간에 char가 같은 범위, 표현, 동작을 갖도록 정의한다. 하지만 어느 것을 고르든 char는 나머지 두 개의 타입과는 분리된 타입이고 서로 호환되지 않는다. 숫자 값이나 저장공간으로 쓸 때는 항상 signed char나 unsigned char를 사용하라. 이렇게 하는 것이 문자 타입의 부호와 상관없이 호환 가능한 코드를 만드는 유일한 방법이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>INT09_C</rule>
    <ruleTitle><![CDATA[열거형 상수가 유일한 값으로 매핑되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C의 열거형 타입은 정수로 매핑된다. 일반적으로 각 열거형 타입이 개별 값으로 매핑된다고 생각하지만, 열거형 타입 멤버들이 서로 같은 값을 갖는 명확하지 않은 에러가 종종 만들어지기도 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>INT10_C</rule>
    <ruleTitle><![CDATA[% 연산자를 쓸 때 나머지가 양수라고 가정하지 마라 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C99 정의에서 % 연산자에 대한 결과의 부호는 피제수(표현식의 첫 번째 연산자)의 부호를 따른다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>INT11_C</rule>
    <ruleTitle><![CDATA[pointer type과 integer type 간 명시적 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 정수와 포인터를 서로 변환하는 일이 C에서 일반적이기는 하지만, 포인터에서 정수로, 정수에서 포인터로 변환하는 것은 구현마다 다르게 정의하고 있다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>INT12_C</rule>
    <ruleTitle><![CDATA[int bit 필드에 명시적으로 signed나 unsigned를 사용하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 저장 공간을 절약하기 위해 플래그나 작은 범위를 갖는 정수 값을 같은 공간에 저장하려고 비트 필드를 사용할 수 있다. 그런데 비트 필드에서 int가 signed int와 같은 타입인지 혹은 unsigned int와 같은 타입인지는 구현마다 다르다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>INT13_C</rule>
    <ruleTitle><![CDATA[bitwise 연산자에 signed underlying type 피연산자 사용금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 비트 연산자는 signed 정수에 대한 비트 연산이 구현마다 다르게 정의돼 있기 때문에 unsigned 정수 피연산자와만 사용돼야 한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>INT14_C</rule>
    <ruleTitle><![CDATA[bitwise 연산자와 산술 연산자가 혼용되면 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 동일한 데이터에 비트 연산자와 산술 연산자를 수행하면 안된다. 최적화를 위해 간혹 산술적 수치 값에 비트 연산을 수행하는 경우가 있다. 비트 연산자에는 단항 연산자 ~와 이항 연산자 <<, >>, &, ^, |가 있다. 이런 연산은 유효하고 컴파일도 되지만, 코드의 가독성을 떨어뜨린다. 숫자 값이나 비트맵을 포함하고 있는 변수를 선언할 때, 프로그래머의 의도가 분명하게 보여야 코드의 유지보수가 용이해진다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>INT15_C</rule>
    <ruleTitle><![CDATA[typedef 타입을 변환 포맷에 사용 시 오버플로 방지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 사용자가 지정한 타입들은 printf() 같은 포맷이 지정된 출력 함수나 scanf() 같은 포맷이 지정된 입력 함수와 사용하면 문제를 일으킨다. C99의 intmax_t와 uintmax_t 타입은 같은 부호를 갖는 정수 타입으로 표현될 수 있는 모든 값을 표현할 수 있다. 이로 인해 프로그래머가 정의한 정수 타입과 intmax_t, uintmax_t 간의 변환도 가능하다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>INT30_C</rule>
    <ruleTitle><![CDATA[unsigned integer 타입의 상수에 대한 wrap around가 일어나면 안됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[ unsigned 정수 연산은 결과 값이 정수 표현 범위를 벗어나는 경우 래핑될 수 있다. 이러한 래핑이 발생하면 버퍼 오버플로를 초래하거나 공격자로 하여금 임의 코드를 수행하게 한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>INT31_C</rule>
    <ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ integer 변환(묵시적, 명시적 모두 포함)은 데이터의 손실이나 부호의 변동을 가져오면 안된다. 이런 변환은 배열의 참조자, 포인터 연산, 객체의 사이즈나 길이 등에서 신뢰하지 못하는 코드를 유발할 수 있다. 단, 해당 변환에 대해 미리 인지하고 검사를 완료한 코드는 허용한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>INT32_C</rule>
    <ruleTitle><![CDATA[signed 정수 연산이 오버플로되지 않도록 보장해야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 정수 오버플로는 undefined behavior를 유발한다. 따라서 signed 정수에서의 연산이 signed 오버플로를 발생시키지 않도록 보장해야 한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>INT33_C</rule>
    <ruleTitle><![CDATA[division by zero가 발생하면 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ /, % 연산자의 두 번째 피연산자로 0(zero)가 오면 undefined behavior가 발생한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>INT34_C</rule>
    <ruleTitle><![CDATA[범위를 벗어난 값으로 shift 연산자를 사용하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 비트 시프트에서 피연산자가 정수 타입인 경우 정수 승계가 일어나며, 왼쪽 피연산자의 승계된 타입이 결과값의 타입이 된다. 만일 오른쪽 피연산자의 값이 음수이거나 승계된 왼쪽 피연산자의 값과 같거나 큰 경우 정의되지 않은 동작이 일어난다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>INT35_C</rule>
    <ruleTitle><![CDATA[정수 표현식으로 비교하거나 할당할 때 더 큰 타입으로 표현하여 묵시적인 변환을 방지하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 정수 표현식이 더 큰 정수와 비교되거나 더 큰 정수에 할당되는 경우 정수 표현은 반드시 피연산자 중 하나를 명시적으로 캐스팅해 큰 타입에서 평가하게 해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MEM01_C</rule>
    <ruleTitle><![CDATA[free된 포인터에 즉시 새로운 값을 저장하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Dangling pointer는 exploitable 이중 free와 free된 메모리 접근 취약점을 이용하도록 유도할수 있다. Dangling pointer를 제거하고 많은 메모리관련 취약점을 피하는 간단하지만 유효한 방법은 포인터에 그들이 free된 후 또는 그들을 다른 적절한 object에 지정한 후에 NULL값을 지정하는것이다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MEM02_C</rule>
    <ruleTitle><![CDATA[메모리 할당 함수의 반환 값을 즉시 할당된 타입의 포인터로 변환하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ void * 타입의 object는 일반적인 data포인터이다. 그것은 어떤 object라도 가리킬수 있다. 어떤 incomplete 나 T 타입 object 에 대해, C는 T* 에서 void* 로, 또는 void* 에서 T* 로의 묵시적 변환을 허용한다. Standard C Library는 다른 타입의 object들에 대해 동작하도록 디자인된 함수의 파라메터와 return 타입을 선언하기 위해 void* 를 사용한다. 표준 메모리 할당함수 malloc(), calloc(), realloc() 의 경우가 그러하다. 
예를들면 c library 는 malloc()을 다음과 같이 선언한다. 

void *malloc(size_t); ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MEM04_C</rule>
    <ruleTitle><![CDATA[특정 함수의 특정 인자로 검증되지 않은 변수 또는 0(constant zero) 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 메모리 할당 시에 사이즈를 0으로 입력하는 것에 대한 처리는 implementation-defined이다. 또한 메모리 할당 함수가 non-null 포인터를 반환하는 경우 할당된 메모리를 읽거나 쓰는 것에 대해서는 undefined behaviord이다. 따라서 메모리 할당 함수에 전달되는 사이즈가 0인지 검사하고 사용해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MEM05_C</rule>
    <ruleTitle><![CDATA[함수의 array type parameter에 사이즈 명시 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 과도한 스택할당을 피하라. 특히 스택의 확장이 제어될수 있는 상황이나 공격자에 의해 영향을 받을수 있는 상황에서. 
C99는  variable-length arrays (VLAs) 를 지원한다 [ISO/IEC 9899:1999]. 만약 배열 길이가 신뢰할수 없는 출처에 기인한다면 공격자는 스택에 과도한 할당을 수행하는 프로세스를 일으킬수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MEM08_C</rule>
    <ruleTitle><![CDATA[realloc()의 인자의 타입과 cast되는 타입이 다른지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C standard에 의하면, recalloc(ptr, size) 호출은 ptr이 가리키는 구 객체를 할당해제 하고 size에 의해 크기가 명세되는 새 객체를 반환한다. 새 객체의 내용은 새 객체와 구 객체중 작은쪽의 크기까지 할당해제 전의 구 객체의 내용과 같다, 구 객체의 크기 너머의 새 객체의 바이트들은 결정되지 않은 값들을 가진다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MEM30_C</rule>
    <ruleTitle><![CDATA[free된 포인터 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ [ISO/IEC 9899-1999] 에 따르면, free() 또는 realloc()함수 호출에 의해 해제된 공간을 참조하는 포인터 값을 사용하는 프로그램의 동작은 undefined. (undefined behavior 168 of Annex J 참조) 
한번 free된 메모리에 접근하는것은 heap을 관리하는 자료구조를 파괴할수 있다. 해제된 메모리로의 참조는 dangling pointer로의 참조가 된다. dangling pointer에 접근하는것은 취약점을 드러내는 결과가 될수 있다. 
메모리가 해제될때, 재할당 또는 해제된 chunk를 재활용 할때의 메모리 관리자의 재량권 때문에 그 내용은 아직 변형없이 남아있고 접근 가능하다. 해제된 위치의 데이타는 문제없이 보일수 있다. 그러나 이것은 불시에 변경될수 있고 프로그램을 unintended behavior로 유도한다. 결과적으로 한번 해제된 메모리가 읽거나 쓰이지 않음을 보장할 필요가 있다 ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MEM31_C</rule>
    <ruleTitle><![CDATA[중복 free 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 중복해서 메모리를 free하는것은 free된 후에 메모리에 계속해서 접근히는것과 유사하다. (MEM30_C 참조) 
먼저, 할당해제된 메모리에 대한 포인터를 읽는것은 undefined behavior이다. 포인터값이 애매하고 trap representation 을 가지기 때문이다. 후자의 경우 그렇게 하는것은  hardware trap을 일으킨다. free된 포인터를 읽는것이 trap을 일으키지 않을때, heap을 관리하는 자료구조가 프로그램에 보안 취약점을 전파할수 있는 방식으로 깨질수 있다. 이런형태의 이슈는 double-free 취약점으로 지칭된다. 실제  double-free 취약점은 엉뚱한 코드를 실행하도록 활용될수 있다. 
double-free 취약점을 제거하기 위해, 동적으로 할당된 메모리가 정확히 한번만 해제되도록 보장할 필요가 있다. 프로그래머는 반복이나 조건문에서 메모리를 free할때 주의해야한다. 코드가 잘못되면, 이런 구조는 double-free 취약점으로 유도될수 있다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MEM32_C</rule>
    <ruleTitle><![CDATA[메모리 할당 함수의 할당 성공 여부 반환값이 검증되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 메모리 할당 함수의 반환 값은 할당의 성공이나 실패 여부를 의미한다. C99에 따르면 calloc(), malloc(), realloc()는 메모리 할당이 실패할 경우 null 포인터를 반환한다. 따라서 메모리 함수의 최종 상태를 확인한 뒤 문제가 발생한 경우에는 적절한 가이드를 해줘야 한다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MEM33_C</rule>
    <ruleTitle><![CDATA[유연한 배열 원소에 정확한 문법을 사용하라 ]]></ruleTitle>
    <ruleDesc><![CDATA[ flexible array member는 유용하지만 주의 깊게 사용될 필요가 있다.  
struct flexArrayStruct {	 
int num;	 
int data[];	 
};	 
이 정의는 저장소에 할당될때, 첫번째 멤버 num 만이 고려된다는 것을 의미한다. 따라서 flexArrayStruct type 구조체 변수의 member data 접근 결과는 undefined 이다. 규칙 DCL38_C 이 flexible array member를 가진 구조체를 선언하는 올바른 방법을 설명한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MEM34_C</rule>
    <ruleTitle><![CDATA[동적할당이 없는 포인터에 free 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 동적으로 할당되지 않은 메모리를 해제하는것은 규칙 MEM31_C 에서 논의된사항들과 유사한 심각한 에러를 유발할수 있다. 이 에러의 구체적인 결과는 구현체에 의존적이지만 그 범위는 아무것도 아닌것에서 프로그램 종료에까지 걸쳐있다. 구현체를 막론하고, 동적메모리 할당 함수(malloc() 같은것)에 의해 반환된 포인터가 아닌 다른 어떤것에는 free() 호출을 피해야 한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MEM35_C</rule>
    <ruleTitle><![CDATA[malloc, memcpy 함수 사용시 오버플로가 발생하면 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 특정 함수 호출 시 전달되는 size가 size_t 타입의 범위를 벗어나는 경우 오버플로가 발생할 수 있다. 따라서 size_t 타입의 사용을 권장한다. 만약 expression 인자의 결과가 size_t 타입의 범위 내라는 보장이 있다면 전체 expression을 size_t로 casting 하기를 권장한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MSC04_C</rule>
    <ruleTitle><![CDATA[중첩된 C 스타일 주석 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 주석 내에서 /*를 사용하지 마라. 주석 마침 표시를 누락하면 에러가 발생할 소지가 많으며, 대부분 실수처럼 보이기 때문에 이런 식의 주석 사용은 권하지 않는다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MSC05_C</rule>
    <ruleTitle><![CDATA[time_t 타입에 대해 직접 산술 연산을 수행하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ time_t 타입은 '시간을 표시할 수 있는 산술적인 타입'으로 정의돼 있다. 하지만 이 산술 타입으로 시간을 어떻게 인코딩하는지는 정의돼 있지 않기 때문에 이 타입에 대해 직접 산술 연산을 수행하는 것은 안전하지 않다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MSC06_C</rule>
    <ruleTitle><![CDATA[메모리 초기화 관련 함수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 컴파일러가 프로그램 생성 시 사용되지 않거나 필요하지 않은 코드를 제거할 수 있다. 일반적으로 이런 방식은 이득이 되지만, 컴파일러가 필요 없다고 판단해 제거한 코드가 사실은 보안상의 이유로 추가된 것일 수 있다. 민감한 데이터를 저장하는데 사용한 버퍼를 지우기 위해 덮어쓰기를 수행하는 경우를 예로 들 수 있다. 따라서 민감한 데이터를 다룰 때는 의도한 대로 동작하는지 확인해봐야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MSC07_C</rule>
    <ruleTitle><![CDATA[도달 불가능한 코드 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 전혀 실행되지 않는 코드는 죽은 코드라고 불린다. 일반적으로 죽은 코드는 프로그램 자체나 환경의 변화로 인해 논리 에러가 발생했음을 암시한다. 죽은 코드는 컴파일되는 동안 프로그램에서 최적화되어 날아가는 게 일반적이다. 하지만 논리 에러가 해결됐음을 보장하고 프로그램의 가독성을 높이기 위해 죽은 코드를 찾아 파악한 후 제거해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Dead Code</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MSC11_C</rule>
    <ruleTitle><![CDATA[assert 매크로 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ runtime assert는 incorrect assumptions 을 확인하기 위해서만 사용해야 하고, runtime error checking 에서는 사용해서는 안된다. 결과적으로 runtime assertions 은 일반적으로  unsuitable 하다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MSC12_C</rule>
    <ruleTitle><![CDATA[side effect 가 없고 제어흐름의 변화를 일으키지 않는 문장 사용금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 실행되기는 하지만 아무 일도 발생하지 않거나 의도하지 않은 효과가 나타나는 경우는 대부분 코딩 에러로 인해서이며, 기대하지 않은 동작을 초래할 수 있다. 아무 효과도 없는 문장이나 표현식은 발견 후 제거해야 한다. 대부분 최근 컴파일러는 아무 효과도 발생하지 않는 코드에 대해 경고 메시지를 보내준다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MSC13_C</rule>
    <ruleTitle><![CDATA[미사용 변수 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 사용되지 않은 변수의 존재는 중요한 논리적 오류를 나타낼수 있다. 이러한 오류를 방지하기 위해, 사용되지 않은 변수들은 코드로부터 확인되고 제거되어야 한다. 
이 제안은 MSC12_C의 구체적인 케이스이다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MSC14_C</rule>
    <ruleTitle><![CDATA[unsigned integer 타입에 ~ 연산자 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ unsigned integer 타입의 정수에 보수 연산자(~)를 사용하는 것은 일반적으로 사용 가능하지만 표준으로 보장되지는 않는다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MSC16_C</rule>
    <ruleTitle><![CDATA[function pointer 변수에 함수의 pointer를 직접 대입 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수의 메모리 위치는 compile 시점에 계산되며, 프로그램이 늦게 사용하는 순서로 정렬된다. 공격자가 특정 함수 포인터를 덮어 쓸 수 있다면, 임의적인 코드가 수행 될 수 있다. 따라서 이러한 공격에 대비하기 위하여 함수 포인터는 암호화되어 저장하고 사용 시점에 복호화되어 수행되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MSC17_C</rule>
    <ruleTitle><![CDATA[문장이 있는 모든 switch 절이 break문으로 끝나는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ switch문에서 case절에 break문이 없으면 fall through가 발생한다. 만약 의도적으로 break문을 생략한 것이 아니라면, 의도하지 않은 control flow가 발생하게 된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MSC20_C</rule>
    <ruleTitle><![CDATA[Switch label(case, default)을 포함하는 가장 가까운 문장이 switch 문인지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ switch 문에서 새로운 블록이 시작되고 그 안에 case 절이 존재하게 되어 case 절들의 scope이 서로 달라질 수 있다. 만약 루프에 case절이 존재하게 되면 루프 안으로 jump가 발생하게 될 것이다. 이러한 경우 발생하는 행동은 정의되어있지 않다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MSC21_C</rule>
    <ruleTitle><![CDATA[for의 조건에서 equality 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ for 또는 while 문장이 loop counter를 사용한다면, loop 종료를 위해서 inequality (연산자 !=) 연산자를 사용하기보다는 관계연산자(<등)를 사용하는것이 더 안전하다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MSC30_C</rule>
    <ruleTitle><![CDATA[rand() 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ rand()를 사용하여 생성되는 무작위 수는 예측 가능한 수다. 따라서 무작위 수를 사용해야 할 경우에 이 함수를 호출하는 것은 바람직하지 못하다. 대안으로는 srandom()과 현재 시간을 조합하는 방법 또는 윈도우에서 제공하는 CryptGenRandom()를 사용하는 방법이 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MSC31_C</rule>
    <ruleTitle><![CDATA[time_t, size_t 타입과 integer 타입간 비교 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수는 표준에서 반환 타입을 부분적으로 지정한 경우 동일한 타입의 리터럴 상수 값으로 비교돼야 한다. 부분적으로 지정된 타입이 unsigned char나 unsigned short로 구현된 경우 타입 값은 어떤 아키텍처에서 -1과 같은 정수 리터럴에 대해 같은 값을 갖고 있음에도 동일하다고 평가되지 않을 수 있다. C99에서 time_t 타입은 시간을 표현할 수 있는 산술 타입이 되도록 요구하고 있다. 시간을 표시하는 최선의 산술 타입을 결정하는 일은 구현에서의 몫이다. 만일 time_t가 signed int보다 작은 unsigned 정수 타입으로 구현됐다면, 항상 정수 리터럴 -1과 같지 않게 된다. 마찬가지로 size_t가 어떻게 구현됐는지에 따라 정수 리터럴 -1과 비교할 때 기대한 대로 평가되지 않을 수 있다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MSC33_C</rule>
    <ruleTitle><![CDATA[특정 함수의 특정 인자로 검증되지 않은 변수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ asctime 함수는 struct tm *timeptr을 인자로 받아서 sprintf로 조합시킨 최대 길이 26(마지막 널 캐릭터 포함)의 string을 반환한다. 만약 인자로 전달된 timeptr의 값에 문제가 있다면 sprintf에서 오버플로가 발생하게 된다. 따라서 asctime 함수에 전달되는 인자는 검증되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MSC34_C</rule>
    <ruleTitle><![CDATA[사용이 권장되지 않거나 구형의 함수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 어떤 함수들은 사용이 권장되지 않거나 새로운 함수를 통해 대체가 가능하다. 이러한 함수들의 사용이 발생하지 않도록 검사한다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MSC35_C</rule>
    <ruleTitle><![CDATA[switch문에서 첫번째 case 레이블 이전에 어떤 실행문도 포함 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ switch 문장 안에서 첫번째  case 레이블 앞에는 어떤 실행문도을 포함하지 말라. 그런 문장들은 컴파일러가 무시하기 때문에 결코 실행되지 않는다. 
만약 프로그래머가 변수를 선언하고 그것들을 첫번째 cast문장의 앞에서 초기화 하고 어떤 case문장들 안에서 그 변수들을 사용하려는 시도들 한다면 그 변수들은 switch 블록 scope 안의 scope를 가질것이지만 초기화되지는 않을것이며 따라서 쓰레기값을 가지게 될것이다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MSC36_C</rule>
    <ruleTitle><![CDATA[alligned_alloc()으로 할당된 포인터를 가지고 realloc() 사용금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 만약 포인터가 aligned_alloc() 로부터 alignment 를 가지고 반환되었고 realloc() 이 다른 alignment로 메모리를 재할당하였다면, undefined behavior이다. 이 룰은  C1X standard [Jones 2009]를 준수하는 컴파일러에만 적용된다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MSC37_C</rule>
    <ruleTitle><![CDATA[non-void return type의 함수에서 명시적 return이 존재하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 반환 타입이 void가 아닌 함수에서 마지막 brace가 끝나기 전에 return문이 존재하지 않았다면 해당 함수의 반환 값은 정의되어 있지 않다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MSC38_C</rule>
    <ruleTitle><![CDATA[표준 라이브러리에 있는 매크로 이름은 재사용 되어선 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 표준 라이브러리에 있는 매크로를 재정의하면 안된다.  ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>MSC40_C</rule>
    <ruleTitle><![CDATA[내용이 없는 무한 루프를 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 루프 바디 내에서 아무것도 하지 않는 비어있는 무한루프는 좋은 해법이 아니며, 그것을 사용하는 코드는 없어야 한다. 그 해법은 그것이 아무것도 하지 않으면서도 CPU cycle을 소비하기 때문에 좋은 해법이 아니다. 최적화된 컴파일러는 그런 루프를 제거할수 있고, 그것은 예상치 못한 결과를 유도할수 있다. C1X 위원회 문서 [ISO/IEC 9899:201x] Section 6.8.5.6 에 의하면, volatile 객체들에 접근하지 않는 입/출력연산을 수행하지 않고, 바디,제어식 또는 (for 문장의 경우에서) 그것의 expression-3 안에서 동기화 또는 atomic 연산을 수행하지 않는 반복문장은, 구현체에 의해 종료로 가정될수 있다. 
이것은 컴파일러에게 그러한 빈 루프가 종료됨을 증명할수 없더라도 그것을  제거하는 식으로 변형시키는것을 허락하도록 의도된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>POS30_C</rule>
    <ruleTitle><![CDATA[readlink() 함수의 반환값이 검증되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ readlink() 함수는 링크가 가리키는 곳이 어디인지 읽어온다. 하지만 2번 째 인자로 오는 버퍼에 널 종료문자를 남기지 않는다. 대신 이 함수는 버퍼에 기록된 글자 수를 반환한다. 따라서 반환된 숫자가 -1이 아닌지 확인 후 버퍼를 사용해야 한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>POS33_C</rule>
    <ruleTitle><![CDATA[vfork() 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ vfork() 함수는 많은 이식성과 보안상의 이슈를 가지고 있다. 모든 상황에서 vfork()보다 fork()의 사용을 권장한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>POS34_C</rule>
    <ruleTitle><![CDATA[putenv의 인자로 자동 지속성을 갖는 type 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ POSIX 함수 putenv()는 환경 변수를 설정하기 위해 사용하는 함수다. putenv()는 인자로 전달된 문자열의 사본을 만들지 않고 문자열 포인터를 환경 변수 배열에 그대로 삽입한다. 만일 자동 지속성을 갖는 버퍼 포인터가 putenv()의 인자로 전달된다면 함수가 반환되고 스택 메모리가 다른 용도로 사용될 시점에 버퍼로 할당됐던 메모리 영역이 다른 데이터로 덮어 쓰였을 가능성이 있다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>POS39_C</rule>
    <ruleTitle><![CDATA[시스템 간에 데이터를 전송할 때 정확한 byte ordering을 사용하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 서로 다른 엔디언의 시스템 사이에 데이터를 전송할 때, 프로그래머는 시스템이 데이터를 풀이하기 전에 바이트 순서에 반전되는지에 대해 주의를 기울여야만 한다. htonl(), htons(), ntohl(), ntohs()는 network 바이트 순서와 host의 바이트 순서 간의 변환이 가능하도록 해주는 함수들이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>POS44_C</rule>
    <ruleTitle><![CDATA[스레드를 종료시키는 시그널 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 스레드를 종료시키는 잡을 수 없는 시그널을 사용하는 것은 비단 해당 시그널 뿐만 아니라 프로세스 전체를 종료시킬 수 있기 때문에 사용하지 말아야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>PRE00_C</rule>
    <ruleTitle><![CDATA[함수 매크로 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 매크로는 사용법이 함수와 비슷하지만 문법은 다르기 때문에 위험하다. C99에서는 C 프로그래밍 언어에 인라인 함수를 도입했는데, 인라인 함수와 매크로를 모두 사용할 수 있는 경우라면 인라인 함수를 사용하는 편이 좋다. 인라인 함수를 사용하면 우리가 알고 있는 함수 호출 프로시저가 인라인으로 치환되기 때문에 함수 호출이 빨라진다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>PRE01_C</rule>
    <ruleTitle><![CDATA[함수 매크로의 파라미터가 괄호로 감싸졌는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 매크로 정의는 모든 매개변수 이름에 괄호를 사용해야 한다.  ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>PRE02_C</rule>
    <ruleTitle><![CDATA[매크로로 치환될 영역이 괄호로 감싸졌는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 매크로로 치환될 영역을 괄호로 둘러싸면 근처의 표현식으로 인해 우선순위가 바뀌는 일을 방지할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>PRE04_C</rule>
    <ruleTitle><![CDATA[표준 헤더를 ""로 include 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 표준 헤더와 같은 이름의 파일이 포함 파일 탐색 경로에 존재하면 undefined behavior이다. 
다음 목록은 표준 헤더를 나열한다.
<assert.h> 	<complex.h> 	<ctype.h> 	<errno.h> 	<fenv.h>
<float.h> 	<inttypes.h> 	<iso646.h> 	<limits.h> 	<locale.h>
<math.h> 	<setjmp.h> 	<signal.h> 	<stdarg.h> 	<stdbool.h>
<stddef.h> 	<stdint.h> 	<stdio.h> 	<stdlib.h> 	<string.h>
<tgmath.h> 	<time.h> 	<uchar.h> 	<wchar.h> 	<wctype.h>
표준 헤더파일 이름, system-specific 헤더파일 이름, 또는 다른 헤더파일 이름을 재활용해서는 안된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>PRE06_C</rule>
    <ruleTitle><![CDATA[헤더 파일 중복 금지를 위한 처리가 되어있는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 헤더 파일을 포함하는 부분에서 중복된 헤더파일 때문에 문제가 일어날 수 있다. 각 헤더에 '이미 포함됐음' 이라는 의미의 심볼을 정의하여 전체 헤더를 인클루전 가드로 둘러 쌈으로써 해결할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>PRE07_C</rule>
    <ruleTitle><![CDATA[연속되는 물음표 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 물음표를 두 개 이상 연속해서 사용하는 경우 삼중자 표기로 오해할 수 있다.  ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>PRE08_C</rule>
    <ruleTitle><![CDATA[헤더파일 중복 include 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 포함되는 헤더파일이 유일한지 확인해야한다. C99[ISO/IEC 9899:1999] 에 따르면 
구현체는 period (.)와 하나의 nondigit가 뒤따르는 하나 또는 그 이상의 nondigit 또는 digit(6.4.2.1)들로 구성된 연속체에 대한 유일한 매핑을 제공해야한다. 첫번째 문자는 숫자여서는 안된다. 구현체는 알파벳 대소문자를 무시할 수 있고, period 앞 기호문자들을 8개로 매핑을 제한할수 있다. 
이것은 다음을 의미한다.
* 파일명의 처음 8문자만이 의미있음을 보증한다.
* 파일은 파일명에서 period 뒤에 단 하나의 nondigit 문자를 가진다.
* 파일명의 대소문자는 의미를 보증하지 않는다.
헤더파일 이름이 유일함을 보증하기 위해 모든 포함파일들은 그들의 처음 여덟자가 다르거나 그들의 (단일문자) 파일 확장자가 달라야한다.
이 제안을 따르는것이 짧을 파일명 사용을 요구하는것은 아니며, 단지 파일명이 유일해야한다는 것이다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>PRE10_C</rule>
    <ruleTitle><![CDATA[복수 구문 매크로를 do-while 루프로 묶었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 매크로는 다수의 연속된 문장집합을 실행하는데 자주 사용된다. 
인라인 함수는, 일반적으로, 이런 일에 적합하다. (제안 PRE00_C를 참조). 그러나 때때로 그들은 실행가능하지 않다(매크로가 다른 타입들의 변수들에 대해 연산을 수행할때 등). 
매크로에서 다수의 문장이 사용될때, 그들은 do-while 루프 안에 함께 묶여있어야 한다. 그렇게 해서 매크로는 절 또는 단일 문장이 나타날것이 기대되는 위치 또는 문장 블록에 안전하게 나타날수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>PRE11_C</rule>
    <ruleTitle><![CDATA[매크로 정의 시 semicolon으로 끝나는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 매크로는 소스코드의 가독성을 높이기 위해 자주 사용된다. 매크로정의는 그것들이 하나의 또는 다수의 문장들로 확정되는지에 관계없이, 세미콜론으로 끝나서는 안된다. (제안 PRE10_C 참고) 필요하다면 세미콜론은 매크로 확장 안에 포함되어야한다. 의도치 않게 매크로 정의 끝에 세미콜론을 넣는것은 프로그램의 제어흐름을 변화시킬수 있다. 
이 문제를 피하는 다른 방식은 함수형 매크로 대신 inline이나 static함수를 사용하는것이다 (제안 PRE00_C 참고). 
일반적으로, 프로그래머는 매크로 정의의 끝에 세미콜론이 없음을 확인해야한다. 이러한 매크로를 사용하는 동안에 필요한곳에서 세미콜론을 가지게 하는것에 대한 책임은 매크로를 사용하는 사람에게 위임되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>PRE30_C</rule>
    <ruleTitle><![CDATA[여러 문자열을 붙여서 유니버설 문자열 이름을 만드는 매크로 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C99는 identifier들, 문자 상수들, 기본 문자집합에 없는 문자들로 된 string literal들에 쓰일수 있는 universal character name을 지원한다. universal character name \Unnnnnnnn 는 그것의 8자리의 identifier 가 nnnnnnnn 인 문자들을 지시한다. 유사하게, universal character name \unnnn 는 그것의 4자리의 identifier 가 nnnn 인 문자들을 지시한다. 그리고 그것의 8자리의 identifier는 0000nnnn이다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>PRE31_C</rule>
    <ruleTitle><![CDATA[매크로 함수에 side-effect가 있는 인자 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 안전하지 않은 함수형 매크로는 코드 확장에서 파라메터를 한번 이상 평가하거나 전혀 평가하지 않는다. 안전하지 않은 매크로를 절대 할당, 증가, 감소, volatile 접근, 입/출력, 또는 다른 side effect가 있는 인자와 같이 사용해서는 안된다. (함수 호출도 side effect를 일으킬수 있다). 
안전하지 않은 매크로에 대한 문서화는 매크로 사용시 side effect를 일으키는것에 대해 반드시 경고해야 하지만, 매크로 사용의 책임은 프로그래머에게 있다. 그들의 사용에 관련된 위험요소들때문에, 안전하지 않은 매크로함수를 만들지 말것이 제안된다. (제안 PRE00_C 참고) 
aseert() 매크로는 안전하지 않은 매크로의 좋은 예이다. 그것의 인자는 한번 또는 전혀 평가되지 않을수 있고, NDEBUG 매크로에 의존적이다. 더 자세한 정보는 규칙 EXP31_C 참고. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>PRE32_C</rule>
    <ruleTitle><![CDATA[함수 매크로 사용시 인자 부분에 Preprocessor directive가 들어가면 안됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 매크로의 인자는 전처리 지시자를 포함하는 것은 정의되지 않은 행동을 유발한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>SIG30_C</rule>
    <ruleTitle><![CDATA[시그널 핸들러에서는 비동기적으로 안전한 함수만 호출하라 ]]></ruleTitle>
    <ruleDesc><![CDATA[  signal handler안에서는 비동기적으로 안전한(asynchronous-safe)함수만을 호출해야한다. 이 제한은 어플리케이션에 정의된 함수뿐만 아니라 라이브러리 함수들에게도 적용된다. 
C Rationale [ISO/IEC 2003] 의 7.14.1.1 에 따르면, signal이 발생할때, 프로그램의 일반적인 제어흐름은 인터럽트된다. signal handler에 의해 잡히는 signal 발생하면 handler가 불려진다. 그것이 종료될때, signal이 발생했던 지점에서 실행이 계속된다. 이 장치는 signal handler가 signal 시점에 실행되는 라이브러리 함수를 부른다면 문제를 일으킬수 있다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>SIG31_C</rule>
    <ruleTitle><![CDATA[시그널 핸들러에서 변수 사용 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ signal handler 에서 공유객체에 접근하거나 변경하는것은 일관성 없는 상태에 데이타를 남겨놓는 race condition을 일으킬수 있다. 이 규칙의 예외는 volatile sig_atomic_t 변수를 읽고 쓰는것이다. volatile 키워드의 필요성은 규칙 DCL34_C에 기술되어있다. 그것은 signal handler로부터 다른 어떤 타입의 객체에 접근하는 프로그램의 동작을 아는데 중요하다 (C99 의 Appendix J 의 undefined behavior 125 참고). 
sig_atomic_t 타입은 비동기적 interrupt 상황에서도 atomic entity로서 접근할수 있는 객체의 integer 타입이다. sig_atomic_t 타입은 구현체에 정의된다. SIG_ATOMIC_MIN 에서 SIG_ATOMIC_MAX 범위의 integer 값들은, 안전하게 해당 타입의 변수에 저장될수 있다. 추가적으로 sig_atomic_t 가 signed integer 타입일때, SIG_ATOMIC_MIN 는 -127보다 클수 없고 SIG_ATOMIC_MAX 는 127보다 작을수 없다. 그 외에는 SIG_ATOMIC_MIN 은 0이어야 하고 SIG_ATOMIC_MAX sms 255보다 작지 않다. SIG_ATOMIC_MIN 와 SIG_ATOMIC_MAX 매크로는 헤더 <stdint.h> 정의되어있다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>SIG32_C</rule>
    <ruleTitle><![CDATA[시그널 핸들러에서는 longjmp() 함수 호출 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ signal handler안에서 longjmp() 함수를 호출하는것은 undefined behavior 를 유도할수 있다. 비동기적으로 안전하지 않은 (non-asynchronous-safe)함수를 호출하게 된다면, 프로그램의 완전성(integrity)이 손상받기 쉽다. longjmp() 뿐만 아니라 POSIX siglongjmp() 또한 signal handler안에서 호출되어서는 안된다. 
이 규칙은 SIG30-C와 밀접하게 연관되어있다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>SIG33_C</rule>
    <ruleTitle><![CDATA[raise() 함수 재귀적으로 호출 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C99는 raise() 함수의 재귀적 호출을 불허한다. C99, Section 7.14.1.1#4[ISO/IEC 9899:1999] 에 따르면, 
abort 또는 raise 함수 호출의 결과로 signal이 발생하면, signal handler는 raise 함수를 호출해서는 안된다. 
(Annex J 의 undefined behavior 124 참조) ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>SIG34_C</rule>
    <ruleTitle><![CDATA[interruptible signal handlers 안에서 signal() 함수 호출 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ signal handler들은 자신의 signal을 다루는 목적을 재설정 하지 않아야 한다. 이것은 지속성이 없는(nonpersistent) 플랫폼에서 자주 일어난다. signal을 받는 플랫폼은 연결된 signal handler의 호출 전에 signal에 대한 disposition 을 리셋한다. 
signal handler는 비동기적으로 안전(asynchronous-safe)하게 될 필요가 없을때에만 singal() 을 호출하는것이 좋다. (다른말로하면 모든 해당 signal들은 mask되어야 하고, handler는 interrupt되어서는 안된다.) ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>STR03_C</rule>
    <ruleTitle><![CDATA[string 관련 함수 사용시 배열에 복사 할 때 오버플로가 발생하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 표준 함수인 strncpy()와 strncat()은 지정된 수 n개의 문자를 소스 문자열로부터 대상 배열로 복사한다. 소스 배열의 처음 n개의 문자 중에 널문자가 없다면 결과 값 역시 널문자로 종료되지 않고, n개를 초과하는 문자들은 버려진다. 따라서 널문자까지 복사될 만큼의 충분한 공간이 확보되었는지 주의를 기울여야 한다.  ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>STR04_C</rule>
    <ruleTitle><![CDATA[기본 문자 집합에서는 문자들을 위해 plain char를 사용하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 세 개의 타입 char, signed char, unsigned char를 통틀어 문자 타입이라고 한다. 컴파일러는 그것이 signed char이든 unsigned char이든 간에 char가 같은 범위, 표현, 동작을 갖도록 정의한다. 하지만 어느 것을 고르든 char는 나머지 두 개의 타입과는 분리된 타입이고 서로 호환되지 않는다. 기본 문자 집합에서의 문자들은 타입 호환성을 제외하고는 어떤 데이터 타입이 사용되든지 상관하지 않는다. 결과적으로 표준 문자열 처리 함수들과의 호환성을 위해 문자 데이터에는 일반 char를 사용하는 방법이 최선이다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>STR05_C</rule>
    <ruleTitle><![CDATA[문자열 상수를 가리키는 포인터는 const로 선언되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ string literal들은 관념적으로 constant이고 결과적으로 const 한정자에 의해 보호되어야한다.  string literal들을 변형하려고 시도하지 않아야한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>STR06_C</rule>
    <ruleTitle><![CDATA[특정 함수에 사용된 변수가 이 후에 다시 사용되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ strtok()이 분할되는 초기 string을 변형시키기 때문에, string은 그 결과 unsafe해지고 원형그대로 사용할수 없게 된다. string원형을 보존하고 싶다면 사본을 만들고 그 주소를 strtok()에 전달해서 사용해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>STR07_C</rule>
    <ruleTitle><![CDATA[문자열 관련 TR24731함수 권장 ]]></ruleTitle>
    <ruleDesc><![CDATA[ ISO/IEC TR 24731 은 C 표준 함수들을 대체하도록 디자인된 다음버젼의 함수들을 정의한다. 예를들어 ISO/IEC TR 24731 Part I 은 strcpy(), strcat(), strncpy(),  strncat() 를 대체하는  strcpy_s(), strcat_s(), strncpy_s(), strncat_s() 를 정의한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>STR09_C</rule>
    <ruleTitle><![CDATA[plain char type변수와 문자상수값 비교시 부등호 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 이식성있는 어플리케이션을 위해서, plain char 또는 plain wide char 타입 식에 대해 할당 연산자  = , 등가 연산자 == 와 != , 단항연산자 & 만을 사용한다. 
이것은 C99표준이 일관된 수치값[C99 N1401]을 가지기 위해 숫자('0' - '9')만을 요구하기 때문에 제안된다. 따라서, plain character 또는 plain wide character 타입 식에 대한 예상된 값에 의존한 연산들은 예측되지 않은 동작을 할수 있다. 
그러나 숫자에 대한 요구사항때문에, 다른 연산자들은 그것을 위해서 다음 제한들에 따라 사용될수 있다. 
* 이상연산자 + 는 integer값 0 에서 9 에 '0'을 더하기 위해 사용될수 있다.
* 이상연산자 - 는 '0'을 빼기 위해 사용될수 있다.
* 관계연산자 <, <=, >, >= 는 character 또는 wide character 가 숫자인지 판단하기 위해 사용될수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>STR10_C</rule>
    <ruleTitle><![CDATA[기본타입과 L타입의 문자열 결합 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ MISRA 2008에 의하면, wide string literal 과 narrow string literal 의 결합은 undefined behavior를 유도한다. 이것은 C99 ISO/IEC 9899:1999 에 의하면 묵시적인  undefined behavior 이다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>STR30_C</rule>
    <ruleTitle><![CDATA[특정 함수의 인자로 string literal 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ string literal은 컴파일 시점에 문자열과 null 종료문자를 포함한 static array로 생성된다. 만약 프로그램이 string literal를 수정하려고 하면 undefined behavior가 발생한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>STR31_C</rule>
    <ruleTitle><![CDATA[문자열 관련 TR24731함수 권장 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 데이터를 그 데이터 유지하기에 충분히 크지 못한 버퍼에 복사하는것은 버퍼 오버플로우를 발생한다. null-terminated 바이트 문자열(NTBS)은 제한되있지 않는 반면, 버퍼 오버플로우는 NTBS를 데이터를 조작할때 자주 일어난다. 이런 에러를 방지하기 위해 truncation을 통해서만 복사하거나, 또는 대상이 복사될 문자 데이터와 null-terminated 문자를 유지하기에 충분한 크기인지 확인하고 복사한다. (제안 STR03_C 참고) ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>STR33_C</rule>
    <ruleTitle><![CDATA[wide 문자 스트링에 대해 특정 함수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Wide character strings은 그것이 narrow strings 또는 multi-byte character strings 으로 오인될때 사이즈가 잘못될수 있다. 부정확한 string 사이즈는 사용될때 버퍼 오버플로우를 유도할수 있다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>STR34_C</rule>
    <ruleTitle><![CDATA[plain char type에 대한 묵시적 변환 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Signed character 는 더 큰 signed 타입으로 변환되거나 할당되기 전에 반드시 unsigned char 로 변환되어야 한다. 컴파일러가  signed char 또는 unsigned char 와 같은 range, representation, behavior를 가지는 char 를 정의하기 위한 범위를 가지기 전에, 이 룰은 signed char 와 (plain) char character 양쪽에 적용되어야 한다.
이 룰은 character data 가 음수로 해석될수 있는 값을 가질수 있는 케이스에만 적용할수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>STR35_C</rule>
    <ruleTitle><![CDATA[고정된 크기의 배열에 제한이 없는 데이터 복사 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ strcat(), strcpy()는 제한이 없는 길이의 문자열을 제한이 있는 길이의 버퍼로 복사하면서 오버 플로가 발생할 수 있다. 이를 피하기 위하여 memcpy()의 사용을 권장한다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>STR36_C</rule>
    <ruleTitle><![CDATA[string literal로 초기화된 문자 배열의 size를 지정하지 말것 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C standard는 배열 변수를 경계값으로 선하는것과 초기화 literal로 선언하는것 양쪽을 허용한다. 초기화 literal은 배열크기를 내포한다. 문자열에서 string literal에 의해 명세된 크기는 literal의 문자들의 수에 종료 null 문자 하나를 더한것이다.
string literal과 string literal의 문자들의 수에 부합하는 명시적인 경계값으로 선언된 배열변수에 의해 배열 변수가 초기화 되는것은 일반적이다. C99, Section 6.7.8, Initialization, paragraph 14.
그러나 string이 null-terminated byte string으로서 사용되도록 의도되면, 배열은 string을 유지하기에는 부족한 문자들을 가질것이다. 종료 null 문자는 수에 포함되지 않기 때문이다. 이러한 문자열은  null-terminated byte string으로 간주된다면 제한된 기능과 취약점을 유발할 가능성을 가진다. 
더 나은 접근방식은 string literal로 초기화 되는 string의 경계를 명세하지 않는것이다. 컴파일러가 자동적으로 종료 null 문자를 포함한 전체 string literal 를 위한 충분한 공간을 할당할것이기 때문이다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>STR37_C</rule>
    <ruleTitle><![CDATA[특정 함수의 특정 인자에서 plain char에서 unsigned char로의 묵시적인 형 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ <ctype.h> 헤더는 문자열을 분류하고 매핑하는 데 유용한 여러 함수를 선언하고 있다. 모든 경우에서 인자는 int 타입이고 표현 가능한 값들은 unsigned char이거나 매크로 EOF와 동일한 값이어야 한다. 인자 값이 이 외의 값을 가질 때의 동작은 정의되어 있지 않다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CERT_C</ruleSetName>
    <ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
    <rule>STR38_C</rule>
    <ruleTitle><![CDATA[특정 함수의 특정 인자에서 wide-char와 char혼용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ strncpy, wcsncpy의 인자에서 wide-char과 char가 혼용되면 안된다. ASCII 문자 집합으로부터 wide char를 취하려고 하면 null 바이트가 포함될 수 있다.그 결과 정의되지 않은 행동이 유발된다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-119</rule>
    <ruleTitle><![CDATA[메모리 버퍼의 경계에서 부적절한 제한이 발생하는 연산 수행 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 응용프로그램은 메모리 버퍼에서 동작되지만, 버퍼의 경계를 벗어나는 메모리 주소에는 읽기나 쓰기가 불가능하다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/119.html">CWE-119</a>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-120</rule>
    <ruleTitle><![CDATA[입력 값의 크기를 검사하지 않고 버퍼를 복사하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 입력 값과 출력 값의 크기를 고려하지 않고 복사를 수행하는 경우 버퍼 오버플로가 발생할 수 있다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/120.html">CWE-120</a>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-121</rule>
    <ruleTitle><![CDATA[스택 기반에서 버퍼 오버플로가 발생하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 스택 기반 버퍼 오버플로는 스택에서 이미 할당된 버퍼의 공간을 벗어난 접근이 발생할 때 일어난다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/121.html">CWE-121</a>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-122</rule>
    <ruleTitle><![CDATA[힙 기반에서 버퍼 오버플로가 발생하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 힙 오버플로는 일반적으로 malloc()과 같은 함수를 통해 힙에서 할당된 버퍼의 공간을 벗어난 접근이 발생할 때 일어난다.  </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/122.html">CWE-122</a>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-129</rule>
    <ruleTitle><![CDATA[검증된 배열 인덱싱인지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 배열을 사용하거나 계산할 때, 검증되지 않았거나 잘못된 방법으로 검증되어 신뢰할 수 없는 입력값을 사용해서는 안된다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/129.html">CWE-129</a>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-131</rule>
    <ruleTitle><![CDATA[버퍼 사이즈에 대해 잘못된 계산이 있는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 버퍼 할당 시에 버퍼 사이즈에 대한 잘못된 계산은 오버플로를 초래할 수 있다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/131.html">CWE-131</a>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-135</rule>
    <ruleTitle><![CDATA[멀티 바이트로 구성된 문자열에 대해 잘못된 길이 계산이 있는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 와이드형 문자 혹은 멀티 바이트 문자 를 포함하는 문자열에 대한 잘못된 계산으로 오류가 발생할 수 있다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/135.html">CWE-135</a>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-14</rule>
    <ruleTitle><![CDATA[버퍼값을 삭제하는 코드가 컴파일러에 의해 제거되는지 검사]]></ruleTitle>
    <ruleDesc><![CDATA[ 컴파일러가 프로그램 생성 시 사용되지 않거나 필요하지 않은 코드를 제거할 수 있다. 일반적으로 이런 방식은 이득이 되지만, 컴파일러가 필요 없다고 판단해 제거한 코드가 사실은 보안상의 이유로 추가된 것일 수 있다. 민감한 데이터를 저장하는데 사용한 버퍼를 지우기 위해 덮어쓰기를 수행하는 경우를 예로 들 수 있다. 따라서 민감한 데이터를 다룰 때는 의도한 대로 동작하는지 확인해봐야 한다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/14.html">CWE-14</a>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-170</rule>
    <ruleTitle><![CDATA[널 종료 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 문자열은 널 문자 또는 그와 동등한 종료자로 종료되어야 한다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/170.html">CWE-170</a>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-190</rule>
    <ruleTitle><![CDATA[정수 오버플로 또는 wraparound 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 계산된 결과의 타입이 결과의 값을 항상 포함할 수 있을 것이라고 가정할 때 정수 오버플로 또는 wraparound가 발생할 수 있다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/190.html">CWE-190</a>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-192</rule>
    <ruleTitle><![CDATA[강제 정수 변환 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 강제 정수 변환은 primitive 데이터 타입의 잘림, 확장, 변환등에서 결점을 가지게 된다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/192.html">CWE-192</a>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-193</rule>
    <ruleTitle><![CDATA[off-by-one 오류 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 최대값 또는 최소값 계산을 1 많거나, 1 모자르게 잘못 계산하여 오류가 발생할 수 있다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/193.html">CWE-193</a>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-20</rule>
    <ruleTitle><![CDATA[입력값이 검증되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 제어 흐름이나 자료 흐름에 영향을 줄 수 있는 입력값은 사전 검증이 필요하다. 사전 검증이 없다면, 공격자가 입력값에 의도적으로 공격을 하여 어플리케이션이 예측하지 못한 오류로 작동에 이상이 생기게 할 수 있다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/20.html">CWE-20</a>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-242</rule>
    <ruleTitle><![CDATA[위험이 내재하는 함수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 안전하다고 보장되지 않는 함수의 사용을 금지한다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/242.html">CWE-242</a>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-252</rule>
    <ruleTitle><![CDATA[함수의 반환값을 확인하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 예상하지 못하는 상황이나 조건에 대비하여 메서드나 함수의 반환값을 확인하였는지 검사한다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/252.html">CWE-252</a>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-311</rule>
    <ruleTitle><![CDATA[중요한 정보를 암호화 하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 중요한 정보는 저장이나 전파 이전에 암호화 되어야 한다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/311.html">CWE-311</a>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-327</rule>
    <ruleTitle><![CDATA[안전하지 않은 암호화 알고리즘을 사용하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 안전하지 않은 암호화 알고리즘은 중요한 정보를 노출시킬 수 있으며 불필요한 리스크를 초래할 수 있다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/327.html">CWE-327</a>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-330</rule>
    <ruleTitle><![CDATA[적당하지 않은 무작위 수 사용 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 예측할 수 없는 번호를 통한 보안 체계에 적당하지 않은 무작위 수나 값을 사용하면 안된다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/330.html">CWE-330</a>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-369</rule>
    <ruleTitle><![CDATA[Divide by zero 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 어떤 값을 0으로 나누면 안된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-390</rule>
    <ruleTitle><![CDATA[함수의 반환값에 대해 오류 검증을 하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 많은 함수는 유효한 값을 반환하기도 하고 -1이나 null 포인터와 같은 오류 값을 반환하기도 한다. 함수의 성공적인 수행을 확인하기 위하여 반환값을 검사해야 한다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/390.html">CWE-390</a>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-391</rule>
    <ruleTitle><![CDATA[오류 검증 여부 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 오류나 예외를 무시하는 것은 공격자가 예상하지 못한 행동을 쉽게 유발시킬 수 있게 한다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/391.html">CWE-391</a>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-416</rule>
    <ruleTitle><![CDATA[메모리가 해제된 객체가 사용되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ free된 메모리를 사용하면 예상하지 못하는 값에 접근하게 되어 프로그램에 충돌이 발생한다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/416.html">CWE-416</a>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-456</rule>
    <ruleTitle><![CDATA[초기화 누락 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 특정 상황에서 중요한 역할을 하는 변수들은 사용 전에 초기화되어야 한다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/456.html">CWE-456</a>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-464</rule>
    <ruleTitle><![CDATA[자료 구조 sentinel 추가 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 자료 구조 sentinel이 추가되는 것은 프로그램 로직에 심각한 문제를 일으킬 수 있다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/464.html">CWE-464</a>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-466</rule>
    <ruleTitle><![CDATA[pointer type과 integer type 간 명시적 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 정수와 포인터를 서로 변환하는 일이 C에서 일반적이기는 하지만, 포인터에서 정수로, 정수에서 포인터로 변환하는 것은 구현마다 다르게 정의하고 있다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/466.html">CWE-466</a>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-467</rule>
    <ruleTitle><![CDATA[sizeof()의 인자로 포인터 변수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 특정 타입의 사이즈를 결정할 때 포인터 타입의 사이즈를 사용하면 안된다. 포인터 타입의 사이즈는 포인터가 가리키는 타입의 사이즈가 아니다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/467.html">CWE-467</a>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-469</rule>
    <ruleTitle><![CDATA[사이즈 결정을 위한 포인터 뺄셈 연산 사용]]></ruleTitle>
    <ruleDesc><![CDATA[사이즈를 결정하기 위해 한 포인터에서 다른 포인터로 뺄셈을 할 수 있다. 하지만 포인터가 같은 메모리 공간에 존재하지 않을 경우 이러한 계산은 잘못될 수 있다.</br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/469.html">CWE-469</a>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-476</rule>
    <ruleTitle><![CDATA[메모리 할당 함수의 반환값이 검증되지 않아 null 포인터 참조가 시도되는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ null 포인터 결과값을 참조하려는 시도는 undefined behavior이다.  </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/476.html">CWE-476</a>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-480</rule>
    <ruleTitle><![CDATA[잘못된 연산자 사용 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 프로그래머는 의도하지 않게 잘못된 연산자를 사용할 수 있으며, 이는 어플리케이션의 로직에 변화를 줄 수 있다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/480.html">CWE-480</a>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-561</rule>
    <ruleTitle><![CDATA[도달 불가능한 코드 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 전혀 실행되지 않는 코드는 죽은 코드라고 불린다. 일반적으로 죽은 코드는 프로그램 자체나 환경의 변화로 인해 논리 에러가 발생했음을 암시한다. 죽은 코드는 컴파일되는 동안 프로그램에서 최적화되어 날아가는 게 일반적이다. 하지만 논리 에러가 해결됐음을 보장하고 프로그램의 가독성을 높이기 위해 죽은 코드를 찾아 파악한 후 제거해야 한다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/561.html">CWE-561</a>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Dead Code</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-562</rule>
    <ruleTitle><![CDATA[스택 변수의 주소 반환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 스택 메모리 변수의 주소를 반환하는 것은 의도하지 않는 행동으로 오류를 유발할 수 있으며 보통의 경우엔 충돌이 발생한다. 스택 메모리가 다른 용도로 사용될 시점에 버퍼로 할당됐던 메모리 영역이 다른 데이터로 덮어 쓰였을 가능성이 있다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/562.html">CWE-562</a>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-628</rule>
    <ruleTitle><![CDATA[함수 호출의 인자가 정확한지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 호출 시 인자로 정확하지 않은 값이 전달되면 그 결과도 정확할 수 없다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/628.html">CWE-628</a>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-665</rule>
    <ruleTitle><![CDATA[부적절한 초기화 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 초기화가 적절하지 못하면 그 데이터를 접근하거나 사용하는 시점에 예측할 수 없는 오류가 발생할 수 있다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/665.html">CWE-665</a>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-676</rule>
    <ruleTitle><![CDATA[잠재적으로 위험성을 가진 함수 사용 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 사용 자체에는 문제가 없다고 하더라도 잠재적으로 위험성을 가지는 함수들의 사용을 자제해야 한다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/676.html">CWE-676</a>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-681</rule>
    <ruleTitle><![CDATA[Numeric 타입 사이의 부정확한 변환 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 어떤 데이터를 다른 타입으로 변환할 때, 데이터가 손실되거나 예상하지 못한 값으로 변경될 수 있다. 중요한 데이터라면 큰 오류로 이어질 수 있다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/681.html">CWE-681</a>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-682</rule>
    <ruleTitle><![CDATA[부정확한 계산 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 잘못된 계산으로 인하여 부정확한 값이나 의도하지 않은 값을 가지게 되면 자원 관리나 보안상의 문제에 대해 오류를 초래할 수 있다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/682.html">CWE-682</a>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-686</rule>
    <ruleTitle><![CDATA[함수 호출의 인자로 부정확한 타입 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 호출시 인자로 잘못된 데이터 타입이 사용되면 오류가 발생할 가능성이 크다. 또한 그 결과 값도 신뢰할 수 없게 된다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/686.html">CWE-686</a>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-687</rule>
    <ruleTitle><![CDATA[함수 호출의 인자로 부정확한 값 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 호출시 인자로 잘못된 값이 사용되면 오류가 발생할 가능성이 크다. 또한 그 결과 값도 신뢰할 수 없게 된다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/687.html">CWE-687</a>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-704</rule>
    <ruleTitle><![CDATA[잘못된 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 어떤 타입과 서로 다른 타입 사이에 적절하지 않은 변환이 존재하면 안된다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/704.html">CWE-704</a>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-705</rule>
    <ruleTitle><![CDATA[잘못된 제어 흐름 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수의 기능이 다 끝나기 전에 비정상 종료가 수행되면 정상적인 제어 흐름으로 진행될 수 없다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/705.html">CWE-705</a>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-754</rule>
    <ruleTitle><![CDATA[비정상적이거나 예외적인 조건에 대해 잘못된 검증이 발생하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 종종 발생할 수 있는 비정상적이거나 예외적인 조건에 대해 정확한 검증이 필요하다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/754.html">CWE-754</a>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-768</rule>
    <ruleTitle><![CDATA[잘못된 short-circuit 평가 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 조건식에서 논리 연산자가 2개 이상 결합된 경우 우변의 표현식들은 side-effect를 가져서는 안된다. 조건에 따라 해당 표현식들이 평가되지 않을 수 있기 때문이다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/768.html">CWE-768</a>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-788</rule>
    <ruleTitle><![CDATA[버퍼를 넘어서는 접근 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 버퍼 공간의 끝을 넘어서는 인덱스나 포인터에 대해 읽기나 쓰기를 수행하는 것에 대한 행동은 정의되어 있지 않다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/788.html">CWE-788</a>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CWE_C</ruleSetName>
    <ruleSetDesc><![CDATA[CWE(Common Weakness Enumeration) for C Rules. This CWE Mapping based on CWE v2.8]]></ruleSetDesc>
    <rule>CWE-805</rule>
    <ruleTitle><![CDATA[잘못된 길이 값으로 버퍼에 접근하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 버퍼에 대해 읽고 쓰는 연산들이 잘못된 버퍼의 길이 값을 가지고 있으면 버퍼의 경계를 넘어서는 곳에 접근하는 오류가 발생한다. </br></br><b>Link to </b> <a href="http://cwe.mitre.org/data/definitions/805.html">CWE-805</a>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_01</rule>
    <ruleTitle><![CDATA[특정 함수의 특정 인자로 검증되지 않은 객체 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 방어적 프로그래밍을 위해 특정 함수의 인자로 검증된 객체를 사용해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_02</rule>
    <ruleTitle><![CDATA[특정 함수의 특정 인자로 오는 상수값의 범위 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 방어적 프로그래밍을 위해 특정 함수의 특정 인자로 적절한 범위의 상수값을 사용해야 한다. 예를 들어 sin 함수는 0에서 1사이의 값만 유효하다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_03</rule>
    <ruleTitle><![CDATA[함수 호출 시 인자의 개수와 파라미터의 개수가 일치하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 호출 시 인자의 개수와 파라미터의 개수가 일치해야 한다. 함수의 프로토타입이 명시되지 않은 경우에 인자가 사용되는 경우도 검출한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_04</rule>
    <ruleTitle><![CDATA[함수 매크로 사용시 파라미터와 인자의 개수가 일치하는지 여부 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 매크로 사용시 파라미터와 인자의 개수가 일치하지 않는 경우 정의되지 않은 행위를 유발한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_05</rule>
    <ruleTitle><![CDATA[변수의 타입 크기를 벗어나는 상수 할당금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 변수의 타입 크기를 벗어나는 상수를 할당하면 해당 변수는 의도하지 않은 값을 가지게 된다. 이는 이후 프로그램의 논리적 오류를 발생시키므로 주의해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_06</rule>
    <ruleTitle><![CDATA[Boolean Type의 변수에는 Boolean 타입의 변수와 0, 1 이외의 값 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Boolean 타입의 변수에는 Boolean 값(0, 1)만 사용 가능하다. C 언어에서는 Boolean 타입이 없다. 따라서 Boolean 용도의 integral 타입을 사용하게 된다. 이때, 사용자 정의 Boolean 타입에 대해서 Boolean 값이 아닌 산술 연산 값이 사용되면 안된다. 이는 True(1), False(0) 값만 있다고 구현되어 있는 알고리즘에서 해당 값이 아닌 엉뚱한 산술 연산의 값이 할당되어 False(0)가 아닌 True로 판단하여 알고리즘이 구성되는 논리적 오류를 막기 위함이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_07</rule>
    <ruleTitle><![CDATA[변수 사용 전 값 할당 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 모든 변수는 사용하기 전에 값이 할당되어 있어야 한다. 이것은 꼭 변수 선언시에 초기화를 해야한다는 것은 아니다. ISO C 표준에 다르면 static 변수의 저장 공간은 초기화 해주지 않으면 자동으로 0으로 초기화가 되지만 일반 변수는 자동으로 초기화가 되지 않는다. 따라서 값이 할당되지 않는 변수를 사용하게 되면 의도하지 않은 쓰레기값을 이용하게 되므로 오류를 유발하게 된다. 이 룰에서는 flow 고려하지 않고 명백히 할당이 되지 않은 변수를 사용할 때 검출한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_08</rule>
    <ruleTitle><![CDATA[division by zero를 방지하기 위한 제수 검증 여부 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 0으로 나누게 되면 소프트웨어 실행시 Exception이 발생된다. 따라서 division by zero를 방지하기 위해 제수가 0이 아닌지 검증 한 후에 사용해야만 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_09</rule>
    <ruleTitle><![CDATA[const나 volatile 을 제거하는 명시적 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ const나 volatile 을 제거하는 캐스팅을 하면 안 된다. const나 volatile은 타입의 불변성이나 휘발성을 지정할 때 사용한다. 포인터로 다뤄지는 type에 const나 volatile을 제거하는 캐스팅을 하게 되면 이러한 속성이 제거 되어 원래의 개체가 가지고 있는 불변성이나 휘발성을 보장할 수 없게 된다. 즉, 값을 수정하지 못하게 하기 위해 const로 지정한 타입에 const를 제거하는 캐스팅을 하면 값을 수정할 수 있는 동작을 컴파일러가 검사해 주지 못하게 되므로 의도하지 못한 실수 등에 의해 값이 변경되는 경우를 미리 방지할 수 없다. volatile의 경우, 이를 제거하는 캐스팅을 하면 다른 환경에 의해 개체의 값이 바뀌는 것이 반영되지 않을 수 있어 실행시간에 의도했던 외부 환경에 의한 값의 변경이 나타나지 않을 수 있으므로 실행 시간에 의도하지 않은 동작을 보일 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_10</rule>
    <ruleTitle><![CDATA[범위를 벗어난 값으로 shift 연산자를 사용하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ shift 연산자의 오른쪽 피연산자는 왼쪽 피연산자의 underlying type의 비트 길이 보다 작아야 한다. 예를 들어 만약 left-shift 또는 right-shift의 왼쪽 피연산자가 16-bit integer라면, 이 shift가 0에서 15 사이의 수 만큼 이루어져야 한다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_11</rule>
    <ruleTitle><![CDATA[문자값의 사용 및 저장 외의 용도로 plain char 타입사용금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C언어에는 (plain) char, signed char, unsigned char의 세가지 서로 다른 char 타입이 존재한다. 이중 (plain) char는 문자값을 다룰 때 사용하도록 한다. 다른 숫자값을 저장하거나 연산의 결과를 저장하는데 사용하면 안된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_12</rule>
    <ruleTitle><![CDATA[숫자값의 사용 및 저장외의 용도로 signed, unsigned char 타입 사용금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C언어에는 (plain) char, signed char, unsigned char의 세가지 서로 다른 char 타입이 존재한다. 이중 signed char, unsigned char는 작은 숫자값을 다룰 때 사용하도록 한다. 문자값을 저장하기 위해서는 (plain) char를 이용하도록 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_13</rule>
    <ruleTitle><![CDATA[평가순서에 따라 결과가 달라지는 문장사용금지 (sequence point detection) ]]></ruleTitle>
    <ruleDesc><![CDATA[ 표현식의 평가는 부수 효과를 가져오는데, 이 때 이전 평가 단계에서의 모든 부수 효과가 발생하고 다음 평가 단계에서의 부수 효과가 아무것도 발생하지 않은 지점에 해당하는 시퀀스 포인트라는 샐행 지점이 있다. C99의 6.5절에 따르면, 이전과 다음 시퀀스 포인트 사이의 객체는, 객체에 저장된 값을 표현식 평가로 한 번 수정할 수 있다. 또한 이전 값은 저장될 값을 결정하려는 목적으로만 읽을 수 있다. 이 요구사항은 전체 표현식의 모든 가능한 하위 표현식의 순서에 대해 만족돼야 한다. 그렇지 않다면 어떤 행동을 할지 예측할 수 없다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_14</rule>
    <ruleTitle><![CDATA[함수 매크로의 파라미터가 괄호로 감싸졌는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 매크로의 파라미터가 매크로 정의시에 #나 ##로 연결되는 경우를 제외하고는 괄호로 감싸여져서 사용되어야 한다. 그렇게 함으로써 연산자 우선순위의 변경 등의 이유로 의도되지 않는 결과가 발생하는 것을 막을 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_15</rule>
    <ruleTitle><![CDATA[매크로 identifier는 사용되기 전에 defined 되었는지 검사(#ifdef, #ifndef, defined 는 제외) ]]></ruleTitle>
    <ruleDesc><![CDATA[ 만약 preprocessor directive 내에서 어떤 identifier를 사용하려고 시도한다면, 그리고 그 identifier가 정의되지 않았다면, preprocessor는 경고하지 않고 값을 0으로 가정한다. #ifdef, #ifndef 그리고 defined()는 매크로의 존재를 검사하는데 사용하므로 제외된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_16</rule>
    <ruleTitle><![CDATA[지역변수의 주소는 return 문에 사용금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 지역변수의 주소가 return 문에 사용이 되면 해당 함수를 벗어나는 순간 invalid한 영역이 되어 버려서 잘못된 주소를 접근하는 문제를 발생시킬 수 있다. 이는 메모리 crash의 문제를 발생시킬 수 있다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_17</rule>
    <ruleTitle><![CDATA[지역변수의 주소가 자신의 scope을 넘어서는 변수에 할당금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 지역변수의 주소가 자신의 scope을 넘어서는 변수에 할당되면 해당 스코프를 벗어나는 순간 invalid한 영역이 되어 버려서 잘못된 주소를 접근하는 문제를 발생시킬 수 있다. 이는 메모리 crash의 문제를 발생시킬 수 있다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_18</rule>
    <ruleTitle><![CDATA[함수 prototype에서 포인터 타입의 parameter가, 그 포인터가 가리키는 object를 수정하는데 사용되지 않았다면 포인터는 const로 선언되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수의 포인터 parameter 값이 함수의body 안에서 변경되지 않으면, 그 포인터 parameter를 const로 선언되어야 한다. 이 규칙은 함수 인터페이스 정의를 보다 더 정밀하게 만든다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_19</rule>
    <ruleTitle><![CDATA[문장이 있는 모든 switch 절이 break문으로 끝나는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 문장이 있는 모든 switch 절은 break문으로 끝나야 한다. 만약에 switch 절이 복합문이라면 복합문을 구성하는 마지막 문장이 break여야 한다. 이는 break를 쓰지 않아 fall through되는 오류를 줄여준다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_20</rule>
    <ruleTitle><![CDATA[switch문이 하나 이상의 case 문을 가졌는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ switch문이 하나 이상의 case 문을 가져야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_21</rule>
    <ruleTitle><![CDATA[switch문의 마지막 절이 default절 이어야 한다 ]]></ruleTitle>
    <ruleDesc><![CDATA[ switch의 마지막 절에 default가 오는 것은 defensive programming을 위함이다. switch 문에는 default절이 반드시 마지막에 존재해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_22</rule>
    <ruleTitle><![CDATA[비교 조건식의 연산 결과가 항상 같게 나오는 표현식 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 조건식의 결과가 항상 true 혹은 false 값을 가진다면 대부분 프로그래밍 에러라고 볼 수 있다. 따라서 다음과 같은 경우를 검출한다.
-변수와 변수타입의 최대/최소값을 넘는 상수 비교, 변수와 경계값 상수 비교의 결과가 항상 참이거나 거짓인 비교
-비교 조건식의 연산 결과가 항상 같게 나오는 관계연산자(논리곱/논리합) 조합 사용 금지
-비교 조건식의 연산 결과가 항상 같게 나오는 상수 사용 금지 ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_23</rule>
    <ruleTitle><![CDATA[조건문에서 bitwise 연산자 (&,|) 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ bitwise AND (&, ampersand) 또는 bitwise OR (|, pipe) 연산자를 조건식에서 사용하면 안된다. 이것은 전형적으로 프로그래머에게 실수를 유발하고 예측하지 못한 작동을 하는 결과가 될수 있다. & 또는 | 는 bitwise 연산에서만 쓰고, && 또는 || 는 논리 연산에서만 써야한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_24</rule>
    <ruleTitle><![CDATA[else if 가 있다면 else가 반드시 있는 지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ if 문 뒤에 하나 혹은 여러 개의 else if 문이 따라온다면 마지막에 else 문이 와야 한다. 단순한 if 문의 경우에는 else 문이 포함될 필요는 없다. 마지막 else문의 요구는 defensive programming을 위함이다. 이것은 switch case 문에서 default 절이 필요한 이유와 같은 것이다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_25</rule>
    <ruleTitle><![CDATA[switch, while, do-while, for, if의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ switch, while, do-while, for, if 문의 body가 복합문이어야 한다. 비록 복합문 내에 하나의 statement만 존재하더라도 가독성을 높이고 유지보수를 위해서는 복합문으로 구성하는 것이 좋다. 이후에 새로운 문장을 추가해야 할 때 indentation만 넣은채 해당 블럭에 포함되는 것처럼 혼돈될 수 있다. 또한 macro등을 사용할 때 여러 문장으로 이루어진 매크로인 경우 복합문으로 구성하지 않으면 의도하지 않은 제어 흐름으로 변할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.5_26</rule>
    <ruleTitle><![CDATA[non-void return type의 함수에서 명시적 return이 존재하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 반환 타입이 void가 아닌 함수에서 마지막 brace가 끝나기 전에 return문이 존재하지 않았다면 해당 함수의 반환 값은 정의되어 있지 않다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.6.2_01</rule>
    <ruleTitle><![CDATA[직,간접적인 재귀호출 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 직간접으로 함수는 자신을 호출하면 안 된다. 증명할 수 없고, 검사할 수 없는 서브루틴의 호출을 피하기 위함이다. 만일 재귀를 사용한다면, 재귀의 깊이를 예측할 수 있는 판단 기준이 명확해야 한다. while이나 for 문과 같이 반복 구조를 사용하여 재구성함으로써 재귀 호출을 피할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.6.2_02</rule>
    <ruleTitle><![CDATA[exit 함수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ exit 함수 사용을 금지한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.6.3_01</rule>
    <ruleTitle><![CDATA[동적 메모리 할당 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 동적 변수와 객체의 수, 그리고 새로운 동적 변수나 객체를 할당하기 위한 기존의 자유 메모리 공간은 할당 시, 시스템 상태에 따라 결정되기 때문에, 그 변수나 객체를 할당 또는 이용할 때 결함이 발생할 수 있다. 예를 들면, 시스템에 의해 할당되는 위치에 있는 자유 메모리의 양이 충분하지 못하면, 또 다른 변수에 대한 메모리 내용이 실수로 덮어 씌워질 수도 있다. 동적 변수나 객체가 이용되지 않는다면, 이런 결함이 방지된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.6.4_01</rule>
    <ruleTitle><![CDATA[동적 변수 또는 동적 객체 설치에 대한 온라인 확인 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 동적 메모리 할당 관련 함수인 malloc(), calloc(), realloc()를 사용했다면 동적 할당된 변수를 사용하기 전에 문제가 없는지 검사를 해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.6.6_01</rule>
    <ruleTitle><![CDATA[조건식으로 검사되지 않은 포인터 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 포인터는 사용시에 주의해야 한다. 조건식을 통해 검사를 수행한 후에 포인터를 사용하도록 한다. 이때 outmode 파라미터로 사용되는 것은 허용한다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.7_01</rule>
    <ruleTitle><![CDATA[함수 복잡도(cyclomatic complexity number) 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 구조적 프로그래밍 원칙에 따라 구조 복잡성을 최소화해야 한다. 함수의 복잡도 값이 50을 넘지 않게 해야 한다. 함수의 복잡도 값이 높다는 것은 내부 제어 흐름 구조가 복잡하다는 것이므로 가독성을 떨어뜨리고 유지보수를 어렵게 한다. 하나의 함수에서 너무 많은 역할을 하고 있는 것이 아닌지 검토가 필요하며 가능하면 기능적 분해를 통해 복잡도가 낮은 함수들로 재구성한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.7_02</rule>
    <ruleTitle><![CDATA[goto 문장 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 구조화된 프로그래밍을 위해서 goto 문장의 사용을 금지한다. 이런 문장의 사용은 프로그램의 제어 흐름을 복잡하게 만들어 가독성과 유지보수성을 떨어뜨린다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.7_03</rule>
    <ruleTitle><![CDATA[for문의 초기화,제어,증감 expression은 모두 loop 제어와 관련 있는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ for문의 세 가지 expression은 다음의 목적으로 사용되어야 한다. 
First expression: loop counter의 초기화
Second expression: loop counter를 검사하는 부분이 포함되어야 하고, 추가적으로 다른 loop control 변수를 검사할 수 있음
loop counter의 증가 혹은 감소 ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.7_04</rule>
    <ruleTitle><![CDATA[함수의 최대 nesting depth 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 구조적 프로그래밍 원칙에 따라 구조 복잡성을 최소화해야 한다. 함수의 최대 nesting depth 값이 5를 넘지 않게 해야 한다. 함수의 최대 nesting depth 값이 높다는 것은 제어문이 중복되어 조합되어 있다는 것으로 내부 제어 흐름 구조가 복잡하다는 것이므로 가독성을 떨어뜨리고 유지보수를 어렵게 한다. 하나의 함수에서 너무 많은 역할을 하고 있는 것이 아닌지 검토가 필요하며 가능하면 기능적 분해를 통해 함수를 재구성한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.8_01</rule>
    <ruleTitle><![CDATA[헤더파일에 전역변수 정의 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 헤더파일은 여러 소스 파일에 포함될 수 있으므로 전역변수의 정의를 배제하고 선언만을 넣는 것이 좋다. 헤더 파일에 전역변수를 정의시 중복 정의의 문제를 발생시킬 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.8_02</rule>
    <ruleTitle><![CDATA[헤더파일에 함수 정의 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 헤더파일은 여러 소스 파일에 포함될 수 있으므로 함수의 정의를 배제하고 프로토타입 선언만을 넣는 것이 좋다. 헤더 파일에 함수를 정의시 중복 정의의 문제를 발생시킬 수 있다. 단 inline 함수는 허용한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.9_01</rule>
    <ruleTitle><![CDATA[함수의 코드 라인 수(LOC) 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 프로그램이 분석 가능하도록 구조화 규칙에 맞게 작성해야 한다. 이를 위해 모듈을 잘 설계해야 한다. 하나의 함수의 코드 라인수(LOC)가 100 이하가 되도록 하는 것이 좋다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.9_02</rule>
    <ruleTitle><![CDATA[함수가 하나의 exit point 를 가졌는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수가 하나의 exit point 를 가지는 것이 모듈화 설계에 있어서 바람직하다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.9_03</rule>
    <ruleTitle><![CDATA[함수의 파라미터는 함수와 연관된 것만 선언되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 모든 함수의 인터페이스는 그 기능에 필요한 파라미터들만 보유해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC61508</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 61508 , Functional safety of electrical/electronic/programmable electronic safety-related systems.]]></ruleSetDesc>
    <rule>IEC61508_C.2.9_04</rule>
    <ruleTitle><![CDATA[longjmp 함수, setjmp 매크로 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ longjmp 함수, setjmp 매크로 사용을 금지한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_ETC_01</rule>
    <ruleTitle><![CDATA[C 스타일 주석만 사용하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C 소스에서는 C 스타일 주석만 사용하여야 한다. 그렇지 않은 경우 컴파일러에 따라 인식할 수도 있고 인식하지 않을 수 있어서 포팅 이슈가 생긴다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_ETC_02</rule>
    <ruleTitle><![CDATA[comment 비율 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ comment 비율은 50% 이상이어야 한다. comment 비율을 높이면 유지보수가 용이하다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_ETC_03</rule>
    <ruleTitle><![CDATA[컬럼 길이 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 컬럼 길이는 최대 100 이내로 하여 한 화면에서 읽기 좋은 코드가 되도록 작성하는 것이 좋다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_ETC_04</rule>
    <ruleTitle><![CDATA[파일의 제일 앞에는 comment가 있어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 파일의 제일 앞에는 comment가 있어야 함 ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_EXPR_01</rule>
    <ruleTitle><![CDATA[우선 순위가 다른 연산자 혼용 시 괄호를 사용하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 우선 순위가 다른 연산자 혼용 시 괄호를 사용할 것을 권장한다. 연산자의 우선 순위를 완벽히 이해하지 못 한 채로 혼용하는 경우 의도와 다른 결과를 초래할 수 있기 때문이다.  ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_EXPR_02</rule>
    <ruleTitle><![CDATA[floating point 수식은 equality 검사에서 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ floating point 수식은 granularity와 같은 문제를 고려해야 한다. 이는 컴파일러 또는 환경에 따라 다른 결과를 가질 수 있다. 특히 floating point 값이 복잡한 수식을 통해서 계산되는 경우에는 계산 과정상의 오류가 필연적으로 발생하므로 이를 또 다른 계산식의 결과값과 equality 비교를 하는 것은 부적절하다. 부동소수점에 대한 비교 연산을 제공하는 라이브러리 함수를 이용해서 비교하기를 권장한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_EXPR_03</rule>
    <ruleTitle><![CDATA[sizeof()의 인자로 포인터 변수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 특정 타입의 사이즈를 결정할 때 포인터 타입의 사이즈를 사용하면 안된다. 포인터 타입의 사이즈는 포인터가 가리키는 타입의 사이즈가 아니다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_EXPR_04</rule>
    <ruleTitle><![CDATA[sizeof 연산자에 side effect expression 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ sizeof 연산자는 피연산자의 크기를 바이트 단위로 알려준다. 피연산자는 표현식일 수도 있고 괄호로 묶인 타입 이름일 수도 있다. 피연산자의 타입이 가변 배열 타입이 아닌 경우에는 평가되지 않는다. 부수 효과를 가져올 수 있는 표현식이 제공되는 경우에는 표현식이 평가되지 않았다는 사실을 모르는 프로그래머에게는 혼란을 줄 수 있다. 결국 프로그래머는 프로그램의 상태에 대해 유효하지 않은 가정을 하고, 이는 에러나 소프트웨어의 취약성으로 이어진다. 이 룰에서는 function call을 side effect expression으로 판단한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_EXPR_05</rule>
    <ruleTitle><![CDATA[논리연산자 && 과 || 의 오른쪽 피연산자에 side effect 포함금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 논리 AND와 논리 OR 연산자는 단축 평가를 수행한다. 즉 첫 번째 피연산자로 평가가 완료된 경우 두 번째 피연산자는 평가하지 않는다. 따라서 두 번째 연산자가 부수 효과를 갖고 있다면 이 부수 효과가 실제로 발생하는지 보이지 않으므로 주의해야 한다. (sizeof의 내부에서 사용된 것이 아니면서 ++, -- 연산이 수행되거나, lvalue로 사용되거나, volatile qualified type의 object가 사용되거나, 함수가 호출 된 경우에 부수 효과가 있다고 판단함) ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_EXPR_06</rule>
    <ruleTitle><![CDATA[unary minus 연산자는 unsigned type expression 에서 사용금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 단항 마이너스 연산자를 unsigned int 또는 unsigned long type expression에 적용하는 것은 의미 없는 연산이다. 단항 마이너스 연산자를 더 작은 unsigned integer type의 피연산자에 적용하는 것은 integral promotion 때문에 signed type의 결과가 나올 수 있지만, 이것은 좋은 구현이 아니다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_EXPR_07</rule>
    <ruleTitle><![CDATA[bitwise 연산자에 signed type 피연산자 사용금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 비트 연산자(~, <<, <<=, >>, >>=, &, &=, ^, ^=, |, |=)들은 signed 정수에 대해서는 의미있는 연산을 수행하지 못한다. 부호 비트를 숫자 비트로 밀게되어 문제가 발생할 수 있기 때문이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_EXPR_08</rule>
    <ruleTitle><![CDATA[범위를 벗어난 값으로 shift 연산자 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ shift 연산자의 우변에 오는 값은 해당 shift 연산식의 target type의 bit크기보다 1작은 값 범위 안이어야 한다. 단, explicit casting은 허용한다.
shift 연산자의 우변에 오는 값은 좌변에 오는 피연산자의 integral promotion을 고려한 type의 bit크기보다 1작은 값 범위 안이어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_EXPR_09</rule>
    <ruleTitle><![CDATA[Boolean expression에서 대입연산자(=) 사용 금지: && 연산의 피연산자, || 연산의 피연산자, top-level에 assign 연산자 사용금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 결과가 boolean 값을 가지는 표현식의 내부에는 대입 연산자가 사용되면 안된다. 만약 boolean 값을 가지는 표현식에서 대입 연산자가 반드시 필요한 경우라면, 해당 표현식의 외부에서 따로 처리하여 사용하는 것을 권장한다. 그렇게 함으로써 =와 ==가 혼동되지 않도록 확실하게 처리할 수 있을 것이다. 만약 top-level 표현식이 && 연산자나 || 연산자로 이루어진 경우라면 해당 연산자에 대한 각각의 피연산자들도 모두 위의 검사를 수행해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_EXPR_10</rule>
    <ruleTitle><![CDATA[비교 조건식의 연산 결과가 항상 같게 나오는 수식 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Boolean 연산자가 항상 true 혹은 false 값을 가진다면 대부분 프로그래밍 에러라고 볼 수 있다. 다음과 같은 경우를 검출한다.
-변수와 변수타입의 최대/최소값을 넘는 상수 비교, 변수와 경계값 상수 비교의 결과가 항상 참이거나 거짓인 비교
-비교 조건식의 연산 결과가 항상 같게 나오는 관계연산자(논리곱/논리합) 조합 사용 금지
-비교 조건식의 연산 결과가 항상 같게 나오는 상수 사용 금지 ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_EXPR_11</rule>
    <ruleTitle><![CDATA[동적 할당되는 메모리 블록의 크기는 포인터에 의해서 address되는 완전한 하나의 multiple size인지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 동적 할당되는 메모리 블록의 크기는 포인터에 의해서 address되는 완전한 하나의 multiple size여야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_EXPR_12</rule>
    <ruleTitle><![CDATA[integer type 객체에 대하여 데이터 손실이 발생할 수 있는 묵시적인 부호 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 묵시적 integer 변환이 부호의 변동을 가져오면 데이터의 손실이 발생할 수 있다. signed에서 unsigned로 변환하는 경우는 부호가 손실 될 수 있다. 반대로 unsigned에서 signed로 변환되는 경우는 변환된 후의 타입 크기가 변환되기 전보다 작다면 데이터의 손실이 발생할 수 있다. 이런 변환은 배열의 참조자, 포인터 연산, 객체의 사이즈나 길이 등에서 신뢰하지 못하는 코드를 유발할 수 있다. 단, 해당 변환에 대해 미리 인지하고 검사를 완료한 코드는 허용한다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_EXPR_13</rule>
    <ruleTitle><![CDATA[integer 타입과 floating 타입간 묵시적 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ integer 타입과 floating 타입간에 묵시적인 변환이 이루어지면 안된다. 잘못된 truncation 등 의도하지 않은 결과값을 가지게 된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_EXPR_14</rule>
    <ruleTitle><![CDATA[floating type 간에 큰 타입에서 작은 타입으로의 묵시적 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 부동소수점 값이 더 작은 범위나 정밀도를 가진 부동소수점 값으로 변환되는 경우 값이 정확하게 표현되지 않을 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_EXPR_15</rule>
    <ruleTitle><![CDATA[integer 타입 객체에 대해 더 작은 타입으로의 묵시적 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 서로다른 타입에 대해 연산을 처리할 때에는 주의해야 한다. 정수 승계, 정수 변환 순위를 잘 이해하여 정수 변환 규칙에서 발생하는 변환들을 알고 있어야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_EXPR_16</rule>
    <ruleTitle><![CDATA[변환포맷 함수 사용시 변환 포맷과 인자의 타입 지정 에러 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 입력 값과 변환 지정자가 일치하지 않으면 undefined behavior가 발생한다. 많은 컴파일러가 출력 함수 수행 시 포맷 불일치를 진단해낸다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_EXPR_17</rule>
    <ruleTitle><![CDATA[변환 포맷 함수 사용시 변환 포맷과 인자의 개수 일치 여부 검사  ]]></ruleTitle>
    <ruleDesc><![CDATA[ 변환 포맷이 사용되는 함수에서 변환 포맷 문자의 개수와 변환 대상이 되는 인자의 개수가 일치하는지 검사 한다. scanf나 printf 와 같은 변환 포맷을 지정하는 함수에서 변환 포맷과 사용된 인자의 개수가 일치해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_EXPR_18</rule>
    <ruleTitle><![CDATA[scanf 계열 함수(scanf, fscanf, vscanf, vfscanf)에 사용되는 식별자가 pointer type인지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ scanf 계열 함수(scanf, fscanf, vscanf, vfscanf)에 사용되는 식별자는 주소여야 하므로 pointer type이어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_EXPR_19</rule>
    <ruleTitle><![CDATA[함수 호출 시 인자의 개수와 파라미터의 개수가 일치하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 호출 시 인자의 개수와 파라미터의 개수가 일치해야 한다. 함수의 프로토타입이 명시되지 않은 경우에 인자가 사용되는 경우도 검출한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_EXPR_20</rule>
    <ruleTitle><![CDATA[null 값을 가지는 객체에 대해 dereference 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ null 값을 가지는 객체에 대해 dereference 하게 되면 memory access violation이 발생한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_EXPR_21</rule>
    <ruleTitle><![CDATA[배열의 index에 범위를 벗어나는 상수를 사용했는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 배열의 index에 범위를 벗어나는 상수를 사용하는 경우 buffer overflow의 메모리 에러를 발생시킨다. 이는 접근 불가능한 메모리 영역을 접근함으로써 segmentation fault등 crash를 발생시킬 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_FUN_01</rule>
    <ruleTitle><![CDATA[함수의 선언과 정의에서 return type과 파라미터의 type이 일치하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 프로토타입에서의 파라미터와 반환 타입이 정의와 일치해야 한다. typedef의 base 타입이 같은 경우 일치한다고 본다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_FUN_02</rule>
    <ruleTitle><![CDATA[함수의 호출 이전에 선언이 존재하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 원형을 사용하면 컴파일러가 함수 정의와 호출의 완전성을 체크할 수 있다. 함수 원형이 없으면 컴파일러가 함수 호출 시에 잡아야 하는 특정 에러를 잡아낼 수 없다.(argument 수가 다른 에러, type의 mismatch.) 
external 함수를 위해서 추천하는 함수 원형 구현 방법은 함수를 헤더파일에 선언한 후에 헤더파일을 함수원형이 필요한 모든 파일에 include 하는 것이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_FUN_03</rule>
    <ruleTitle><![CDATA[함수의 선언이나 정의 시 return type을 명시하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수의 선언이나 정의시 return type을 명시하지 않으면 기본적으로 int로 인식된다. 하지만 명시적으로 타입을 표기하는 것이 가독성에 좋고 잘못된 인식으로 인한 오류를 방지할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_FUN_04</rule>
    <ruleTitle><![CDATA[external linkage의 함수가 단 하나의 외부 정의를 가지는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ external 함수가 서로 다른 파일에서 여러 개로 정의 되어 있거나, 정의되어있지 않으면 함수 사용시의 동작은 정의되지 않는다. 서로 다른 파일에 여러 개의 정의가 있다면 정의가 같다고 하더라도 허용되지 않으며, 정의가 서로 다르거나 다른 값으로 초기화 한다면 더욱 심각한 문제를 일으킬 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_FUN_05</rule>
    <ruleTitle><![CDATA[함수 복잡도(cyclomatic complexity number) 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 구조적 프로그래밍 원칙에 따라 구조 복잡성을 최소화해야 한다. 함수의 복잡도 값이 50을 넘지 않게 해야 한다. 함수의 복잡도 값이 높다는 것은 내부 제어 흐름 구조가 복잡하다는 것이므로 가독성을 떨어뜨리고 유지보수를 어렵게 한다. 하나의 함수에서 너무 많은 역할을 하고 있는 것이 아닌지 검토가 필요하며 가능하면 기능적 분해를 통해 복잡도가 낮은 함수들로 재구성한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_FUN_06</rule>
    <ruleTitle><![CDATA[함수의 최대 nesting depth 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 구조적 프로그래밍 원칙에 따라 구조 복잡성을 최소화해야 한다. 함수의 최대 nesting depth 값이 5를 넘지 않게 해야 한다. 함수의 최대 nesting depth 값이 높다는 것은 제어문이 중복되어 조합되어 있다는 것으로 내부 제어 흐름 구조가 복잡하다는 것이므로 가독성을 떨어뜨리고 유지보수를 어렵게 한다. 하나의 함수에서 너무 많은 역할을 하고 있는 것이 아닌지 검토가 필요하며 가능하면 기능적 분해를 통해 함수를 재구성한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_FUN_07</rule>
    <ruleTitle><![CDATA[미사용 static 함수 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 사용되지 않는 함수는 코드의 유지보수성을 떨어뜨린다. 또한 검증되지 않은채로 유지되다가 향후에 사용시 문제를 일으킬 수 있다. 따라서 사용되지 않는 함수는 없애는 것이 좋다. 이 룰에서는 static 함수만 검출하도록 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_FUN_08</rule>
    <ruleTitle><![CDATA[헤더파일에 함수 정의 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 헤더파일은 객체, 함수, 매크로등을 선언하는데 사용된다. 헤더파일이 객체나 함수의 정의를 포함하면 안된다. 헤더파일은 #include directive를 통해 어느 파일에든 포함될 수 있기 때문이다. 단 inline 함수는 허용한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_FUN_09</rule>
    <ruleTitle><![CDATA[non-void return type의 함수에서 명시적 return이 존재하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 반환 타입이 void가 아닌 함수에서 마지막 brace가 끝나기 전에 return문이 존재하지 않았다면 해당 함수의 반환 값은 정의되어 있지 않다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_FUN_10</rule>
    <ruleTitle><![CDATA[void 타입 함수에서 값을 가진 return문이 존재하면 안됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 반환 타입이 void인 함수에서 반환 값은 사용되지 않는다. 만약 특정 표현식이나 값을 반환하는 코드가 존재한다면 프로그래머의 착오가 있었을 가능성이 크다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_ID_01</rule>
    <ruleTitle><![CDATA[scope상에서 동일한 identifier 가리는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 한 스코프 영역이 다른 스코프 영역 안에 포함되어 있는 경우 두 스코프에서 동일한 변수 이름을 사용하면 안된다. 변수 이름을 재사용할 경우, 프로그래머 입장에선 어떤 변수가 변경되고 있는지 헷갈린다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_PRE_01</rule>
    <ruleTitle><![CDATA[헤더 파일 중복 금지를 위한 처리가 되어있는지 검사 (#ifndef, #define, #endif) ]]></ruleTitle>
    <ruleDesc><![CDATA[ 컴파일의 단위가 되는 translation unit이 복잡하고 중첩된 헤더 파일 포함 관계를 가지고 있다면 특정 헤더 파일이 여러번 include 될 수 있다. 이것은 중복 정의 혹은 충돌과 같은 문제를 일으켜서 정의되지 않거나 에러가 발생하게 된다. 따라서 헤더 파일 중복 금지를 위한 구문을 추가하여 하나의 헤더 파일이 translation unit 내에서 여러번 포함되지 않도록 하는 것이 좋다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_PRE_02</rule>
    <ruleTitle><![CDATA[함수 정의 내에서 #define, #undef 매크로 정의 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 정의 내에서 #define, #undef를 사용하는 것은 가능하다. 하지만 함수 정의 내에 매크로 정의가 존재할 경우 해당 함수 내에서만 유효한 것으로 착각하기 쉽다. 따라서 함수 내에서 매크로 정의를 금지한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_PRE_03</rule>
    <ruleTitle><![CDATA[매크로의 확장 형태 검사 (괄호초기자, 상수, 괄호수식, type qualifiers, storage class specifier, 또는 do-while(0) 구조에 대해서만 확장) ]]></ruleTitle>
    <ruleDesc><![CDATA[ 매크로의 확장 형태를 제한한다. 다음과 같은 형태만 확장 가능하다.
- 괄호초기자 : { ... }
- 상수 : 문자열 포함
- 괄호수식 : (수식)
- type qualifiers
- storage class specifier
- do-while(0) 구조
이외의 매크로 확장은 가독성이 떨어지고 의도하지 않은 결과를 만들 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_PRE_04</rule>
    <ruleTitle><![CDATA[함수 매크로 사용시 파라미터와 인자의 개수가 일치하는지 여부 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 매크로 사용시 파라미터와 인자의 개수가 일치하지 않는 경우 정의되지 않은 행위를 유발한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_PRE_05</rule>
    <ruleTitle><![CDATA[함수 매크로의 파라미터가 괄호로 감싸졌는지 검사(#나 ##로 연결되는 경우 제외) ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 매크로의 파라미터가 매크로 정의시에 #나 ##로 연결되는 경우를 제외하고는 괄호로 감싸여져서 사용되어야 한다. 그렇게 함으로써 연산자 우선순위의 변경 등의 이유로 의도되지 않는 결과가 발생하는 것을 막을 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_PRE_06</rule>
    <ruleTitle><![CDATA[상수 매크로 정의시 음수값을 괄호로 처리했는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 상수 매크로 정의시 음수값은 반드시 괄호로 감싸야 한다. 그렇지 않은 경우 연산자 우선순위가 흐트러져서 의도하지 않은 값을 만들어 낼 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_PRE_07</rule>
    <ruleTitle><![CDATA[파일의 Preprocessor directive 가 같은 파일 내에서 짝이 맞는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 파일의 Preprocessor directive 가 같은 파일 내에서 짝이 맞게 사용되어야 한다. 즉 #else, #elif, #endif는 같은 파일안에 연관된 #if나 #ifdef가 존재해야만 한다. 이는 좋은 코드 구조를 만들어서 읽기 쉽고 유지보수를 쉽게 만든다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_PRE_08</rule>
    <ruleTitle><![CDATA[매크로 정의시 괄호 및 꺽쇠(brace, parenthesis, bracket) 짝이 맞는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 매크로 정의시 괄호 및 꺽쇠(brace, parenthesis, bracket) 짝이 맞게 사용되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_STMT_01</rule>
    <ruleTitle><![CDATA[switch, while, do-while, for, if 문의 body가 복합문인지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ switch, while, do-while, for, if 문의 body가 복합문이어야 한다. 비록 복합문 내에 하나의 statement만 존재하더라도 가독성을 높이고 유지보수를 위해서는 복합문으로 구성하는 것이 좋다. 이후에 새로운 문장을 추가해야 할 때 indentation만 넣은채 해당 블럭에 포함되는 것처럼 혼돈될 수 있다. 또한 macro등을 사용할 때 여러 문장으로 이루어진 매크로인 경우 복합문으로 구성하지 않으면 의도하지 않은 제어 흐름으로 변할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_STMT_02</rule>
    <ruleTitle><![CDATA[제어문의 brace 위치 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 제어문의 brace 위치를 준수하였는지 검사한다. 첫 번째 brace를 제어문의 바로 뒤에 사용하는 형태(KnR)와 제어문의 다음 줄에 사용하는 형태(BSD)가 있다. 이 룰에서는 두 가지 형태를 모두 허용한다. (단, 탭(tab)은 에디터에서 보이는 것과 상관없이 1컬럼으로 인식된다.) ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_STMT_03</rule>
    <ruleTitle><![CDATA[Switch label(case, default)을 포함하는 가장 가까운 문장이 switch 문인지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Switch label(case, default)을 포함하는 가장 가까운 문장은 switch 문이어야 한다. 모든 case절과 default 절은 같은 switch scope 내에 존재하여 가독성을 높여야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_STMT_04</rule>
    <ruleTitle><![CDATA[범위를 벗어난 값으로 switch label 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ switch의 각 case의 값은 switch 조건의 값의 범위안에 있어야 한다. 범위를 벗어난 값으로 switch label을 사용하면 해당 절은 도달 불가능한 코드가 된다. 대부분의 경우 논리적 오류이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_STMT_05</rule>
    <ruleTitle><![CDATA[문장이 있는 모든 switch 절이 break문으로 끝나는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 문장이 있는 모든 switch 절은 break문으로 끝나야 한다. 만약에 switch 절이 복합문이라면 복합문을 구성하는 마지막 문장이 break여야 한다. 이는 break를 쓰지 않아 fall through되는 오류를 줄여준다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_STMT_06</rule>
    <ruleTitle><![CDATA[switch문의 default절이 마지막에 위치하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ switch문에서 default절은 마지막에 존재해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_STMT_07</rule>
    <ruleTitle><![CDATA[switch문에 default절 존재 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 방어적 프로그래밍의 일환으로 switch문에는 반드시 default절이 존재해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_STMT_08</rule>
    <ruleTitle><![CDATA[else if 가 있다면 else가 반드시 있는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ if 문 뒤에 하나 혹은 여러 개의 else if 문이 따라온다면 마지막에 else 문이 와야 한다. 단순한 if 문의 경우에는 else 문이 포함될 필요는 없다. 마지막 else문의 요구는 defensive programming을 위함이다. 이것은 switch case 문에서 default 절이 필요한 이유와 같은 것이다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_STMT_09</rule>
    <ruleTitle><![CDATA[goto 문장 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 구조화된 프로그래밍을 위해서 goto 문장의 사용을 금지한다. 이런 문장의 사용은 프로그램의 제어 흐름을 복잡하게 만들어 가독성과 유지보수성을 떨어뜨린다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_STMT_10</rule>
    <ruleTitle><![CDATA[함수 내 도달 불가능한 코드 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 이 규칙은 도달할 수 없거나 compile-time에 확인할 수 없는 코드에 관한 규칙이다. 도달할 수 있지만 실행되지 않는 코드는 규칙에서 제외된다(Defensive programming code). 만약 코드의 어떤 부분으로 들어가는 적절한 entry point가 없다면 그 부분에는 도달할 수 없다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_STMT_11</rule>
    <ruleTitle><![CDATA[평가순서에 따라 결과가 달라지는 문장사용금지 (sequence point detection) ]]></ruleTitle>
    <ruleDesc><![CDATA[ 표현식의 평가는 부수 효과를 가져오는데, 이 때 이전 평가 단계에서의 모든 부수 효과가 발생하고 다음 평가 단계에서의 부수 효과가 아무것도 발생하지 않은 지점에 해당하는 시퀀스 포인트라는 샐행 지점이 있다. C99의 6.5절에 따르면, 이전과 다음 시퀀스 포인트 사이의 객체는, 객체에 저장된 값을 표현식 평가로 한 번 수정할 수 있다. 또한 이전 값은 저장될 값을 결정하려는 목적으로만 읽을 수 있다. 이 요구사항은 전체 표현식의 모든 가능한 하위 표현식의 순서에 대해 만족돼야 한다. 그렇지 않다면 어떤 행동을 할지 예측할 수 없다. (sizeof의 내부에서 사용된 것이 아니면서 ++, -- 연산이 수행되거나, lvalue로 사용되거나, volatile qualified type의 object가 사용된 경우에 부수 효과가 있다고 판단함) ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_STMT_12</rule>
    <ruleTitle><![CDATA[함수 선언에서의 return 타입과 실제 반환되는 타입이 일치하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 선언에서의 return 타입과 실제 반환되는 타입이 일치해야 한다. 만약 두 타입이 다른 경우 묵시적인 형 변환이 발생하여 오버플로가 발생하거나 의도한 것과 다른 값을 반환하는 상황이 발생할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_TYPE_01</rule>
    <ruleTitle><![CDATA[문자값의 사용 및 저장 외의 용도로 plain char 타입 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C언어에는 (plain) char, signed char, unsigned char의 세가지 서로 다른 char 타입이 존재한다. 이중 (plain) char는 문자값을 다룰 때 사용하도록 한다. 다른 숫자값을 저장하거나 연산의 결과를 저장하는데 사용하면 안된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_TYPE_02</rule>
    <ruleTitle><![CDATA[숫자값의 사용 및 저장 외의 용도로 signed, unsigend char 타입 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C언어에는 (plain) char, signed char, unsigned char의 세가지 서로 다른 char 타입이 존재한다. 이중 signed char, unsigned char는 작은 숫자값을 다룰 때 사용하도록 한다. 문자값을 저장하기 위해서는 (plain) char를 이용하도록 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_TYPE_03</rule>
    <ruleTitle><![CDATA[signed 타입의 bit 필드의 size가 2이상인지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ signed 타입의 bit 필드는 부호를 위해 하나의 bit를 사용하게 된다. 따라서 signed bit 필드의 size는 2이상이어야 한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_TYPE_04</rule>
    <ruleTitle><![CDATA[포인터와 integer 사이에 assign 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 포인터 타입과 integer 타입 사이에 assign 연산이 존재하면 안된다. 논리적 오류일 가능성이 높다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_TYPE_05</rule>
    <ruleTitle><![CDATA[Character 문자열과 wide character 문자열 혼용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Character 문자열과 wide character 문자열을 concatenation 하면 안된다. C99 ISO/IEC 9899:1999 에 의하면, wide string literal 과 narrow string literal 의 결합은 undefined behavior를 유발한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_TYPE_06</rule>
    <ruleTitle><![CDATA[Boolean Type의 변수에는 Boolean 타입의 변수와 0, 1 이외의 값 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Boolean 타입의 변수에는 Boolean 값(0, 1)만 사용 가능하다. C 언어에서는 Boolean 타입이 없다. 따라서 Boolean 용도의 integral 타입을 사용하게 된다. 이때, 사용자 정의 Boolean 타입에 대해서 Boolean 값이 아닌 산술 연산 값이 사용되면 안된다. 이는 True(1), False(0) 값만 있다고 구현되어 있는 알고리즘에서 해당 값이 아닌 엉뚱한 산술 연산의 값이 할당되어 False(0)가 아닌 True로 판단하여 알고리즘이 구성되는 논리적 오류를 막기 위함이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_VAR_01</rule>
    <ruleTitle><![CDATA[미사용 local/static 변수 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 사용되지 않은 변수의 존재는 중요한 논리적 오류를 나타낼수 있다. 이러한 오류를 방지하기 위해, 사용되지 않은 변수들은 코드로부터 확인되고 제거되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_VAR_02</rule>
    <ruleTitle><![CDATA[변수 선언 시 초기화 여부 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 변수를 선언할 때 초기화를 함께 하는 것이 좋다. 초기화하지 않을 경우 쓰레기값이 존재하여 논리적 오류를 유발할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_VAR_03</rule>
    <ruleTitle><![CDATA[변수의 선언이나 정의 시 type을 명시하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 변수의 선언이나 정의시 type을 명시하지 않으면 기본적으로 int로 인식된다. 하지만 명시적으로 타입을 표기하는 것이 가독성에 좋고 잘못된 인식으로 인한 오류를 방지할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_VAR_04</rule>
    <ruleTitle><![CDATA[배열과 구조체 초기화 시 brace를 통해 구조가 매치되는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ ISO C 표준에 따르면 배열, 구조체, union type을 위한 초기화 구문은 한 쌍의 brace로 둘러 쌓인다. 이 룰에서는 중첩된 구조를 표현하기 위해서 추가적인 brace의 사용을 요구한다. brace를 사용하여 복잡한 구조의 데이터를 명시적으로 초기화하여 가독성을 높이고, 올바르게 초기화하도록 한다. element의 개수도 맞추어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_VAR_05</rule>
    <ruleTitle><![CDATA[external linkage 배열의 사이즈는 명시적으로 표시되거나 초기화를 통해 묵시적으로 표시 되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 배열을 불완전한 타입으로 선언하고 접근하는 것이 가능하다고 하더라도, 명시적으로 사이즈를 표시하는 것이 안전하다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_VAR_06</rule>
    <ruleTitle><![CDATA[String 배열의 초기화에서 배열의 사이즈 검사 (NULL 고려 여부) ]]></ruleTitle>
    <ruleDesc><![CDATA[ String 배열의 초기화에서 배열의 사이즈 검사 (NULL 고려 여부) ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_VAR_07</rule>
    <ruleTitle><![CDATA[지역변수의 주소가 자신의 scope을 넘어서는 변수에 할당금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 지역변수의 주소가 자신의 scope을 넘어서는 변수에 할당되면 해당 스코프를 벗어나는 순간 invalid한 영역이 되어 버려서 잘못된 주소를 접근하는 문제를 발생시킬 수 있다. 이는 메모리 crash의 문제를 발생시킬 수 있다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_VAR_08</rule>
    <ruleTitle><![CDATA[지역변수의 주소는 return 문에 사용금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 지역변수의 주소가 return 문에 사용이 되면 해당 함수를 벗어나는 순간 invalid한 영역이 되어 버려서 잘못된 주소를 접근하는 문제를 발생시킬 수 있다. 이는 메모리 crash의 문제를 발생시킬 수 있다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_VAR_09</rule>
    <ruleTitle><![CDATA[function pointer 변수에 return 타입이 일치하지 않는 function assign 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ function pointer 변수에 return 타입이 일치하지 않는 function assign하였는지 검사한다. function pointer에 대응하는 function의 타입이 compatible하지 않으면, function pointer를 사용시 undefined behavior가 발생한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_VAR_10</rule>
    <ruleTitle><![CDATA[헤더파일에 변수 정의 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 헤더파일은 객체, 함수, 매크로등을 선언하는데 사용된다. 헤더파일이 객체나 함수의 정의를 포함하면 안된다. 헤더파일은 #include directive를 통해 어느 파일에든 포함될 수 있기 때문이다. 하나의 헤더파일이 여러 파일에 포함되는 경우 객체의 정의가 있으면 중복정의 문제가 발생할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_VAR_11</rule>
    <ruleTitle><![CDATA[변수 사용 전 값 할당 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 모든 변수는 사용하기 전에 값이 할당되어 있어야 한다. 이것은 꼭 변수 선언시에 초기화를 해야한다는 것은 아니다. ISO C 표준에 다르면 static 변수의 저장 공간은 초기화 해주지 않으면 자동으로 0으로 초기화가 되지만 일반 변수는 자동으로 초기화가 되지 않는다. 따라서 값이 할당되지 않는 변수를 사용하게 되면 의도하지 않은 쓰레기값을 이용하게 되므로 오류를 유발하게 된다. 이 룰에서는 flow 고려하지 않고 명백히 할당이 되지 않은 변수를 사용할 때 검출한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>CODESCROLL_C</ruleSetName>
    <ruleSetDesc><![CDATA[CodeScroll Essential Recommendation Rule Set for C]]></ruleSetDesc>
    <rule>CSC_VAR_12</rule>
    <ruleTitle><![CDATA[할당되지 않은 채로 사용될 수 있는 변수 사용 금지(Control flow 고려) ]]></ruleTitle>
    <ruleDesc><![CDATA[ 변수는 사용 전에 값이 할당되어 있어야 한다. 분기의 일부에서만 값이 할당 된 경우 분기가 합쳐진 다음에는 값이 할당되지 않았을 수도 있다. 이 룰에서는 이러한 경우까지 검출한다. 포인터의 사용은 값 할당을 목적으로 할 수 있기 때문에 const qualified 포인터로 받는 경우에만 사용으로 인정하며 그 외에는 값을 할당하는 것으로 간주한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>ISO26262</ruleSetName>
    <ruleSetDesc><![CDATA[ISO/DIS 26262 Road vehicles - Functional safety.]]></ruleSetDesc>
    <rule>ISO26262_1a</rule>
    <ruleTitle><![CDATA[함수가 하나의 exit point 를 가졌는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수는 하나의 exit point 를 가져야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>ISO26262</ruleSetName>
    <ruleSetDesc><![CDATA[ISO/DIS 26262 Road vehicles - Functional safety.]]></ruleSetDesc>
    <rule>ISO26262_1b</rule>
    <ruleTitle><![CDATA[동적 메모리 할당 금지 및 동적 할당된 변수에 대한 사용전 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ malloc(), calloc(), realloc(), free() 등 동적 메모리 할당 관련 함수의 사용을 금지한다. 혹은 동적 메모리 할당 관련 함수인 malloc(), calloc(), realloc()를 사용했다면 동적 할당된 변수를 사용하기 전에 문제가 없는지 검사를 해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>ISO26262</ruleSetName>
    <ruleSetDesc><![CDATA[ISO/DIS 26262 Road vehicles - Functional safety.]]></ruleSetDesc>
    <rule>ISO26262_1c</rule>
    <ruleTitle><![CDATA[변수 초기화 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 이 룰은 변수 초기화 관련 사항을 점검한다.
-변수가 선언될 때 초기화가 되어야 한다.
-변수를 사용하기 전에 값이 할당되어 있어야 한다.
-배열과 구조체를 초기화 할 때에는 brace를 통해 구조가 매치되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>ISO26262</ruleSetName>
    <ruleSetDesc><![CDATA[ISO/DIS 26262 Road vehicles - Functional safety.]]></ruleSetDesc>
    <rule>ISO26262_1d</rule>
    <ruleTitle><![CDATA[변수의 이름이 중복되어 사용되면 안됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 변수의 이름이 여러번 중복되게 선언되면 안된다. 이 룰에서는 다음을 검사한다.
-static 변수 이름이 unique identifier인지 검사
-중첩된 scope내에서 바깥 scope의 식별자를 가리는지 검사 ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>ISO26262</ruleSetName>
    <ruleSetDesc><![CDATA[ISO/DIS 26262 Road vehicles - Functional safety.]]></ruleSetDesc>
    <rule>ISO26262_1e</rule>
    <ruleTitle><![CDATA[전역변수 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 전역변수의 사용은 가능한 없어야 한다. 따라서 이 룰에서는 다음을 확인한다.
-전역변수의 정의를 금지한다.
-하나의 함수에서만 사용되는 변수는 local 함수 scope에 정의가 되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>ISO26262</ruleSetName>
    <ruleSetDesc><![CDATA[ISO/DIS 26262 Road vehicles - Functional safety.]]></ruleSetDesc>
    <rule>ISO26262_1f</rule>
    <ruleTitle><![CDATA[포인터 사용 제약 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 오류의 여지가 많은 포인터는 가능한 사용하지 않는 것이 좋다. 이 룰에서는 다음을 검사한다.
-3차원 이상의 포인터 사용 금지
-포인터 사용전 검사 : 조건식으로 검사되지 않은 포인터 사용 금지 ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>ISO26262</ruleSetName>
    <ruleSetDesc><![CDATA[ISO/DIS 26262 Road vehicles - Functional safety.]]></ruleSetDesc>
    <rule>ISO26262_1g</rule>
    <ruleTitle><![CDATA[묵시적인 타입 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 수식에서 묵시적인 타입 변환이 일어나지 않아야 한다. 이 룰에서는 다음과 같은 묵시적 변환을 검출한다.
-integer 타입의 변수에 대한 묵시적인 부호 변환 금지
-integer 타입과 floating 타입간의 묵시적 변환 금지
-integer underlying type을 더 작은 integer 타입으로의 묵시적 변환 금지
-integer underlying type을 더 큰 integer type으로 묵시적 변환 금지
-floating 타입간 큰 floating 타입으로 묵시적 변환 금지
-floating 타입간 작은 floating type으로 묵시적인 변환 금지 ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>ISO26262</ruleSetName>
    <ruleSetDesc><![CDATA[ISO/DIS 26262 Road vehicles - Functional safety.]]></ruleSetDesc>
    <rule>ISO26262_1h</rule>
    <ruleTitle><![CDATA[숨겨진 데이터 흐름이나 제어 흐름 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수내 숨겨진 데이터 흐름이나 제어 흐름이 있으면 안된다. 이 룰에서는 제어 흐름상 함수 내 도달 불가능한 코드가 있는지를 검사하고, 논리 연산자&& 와 || 의 오른쪽 피연산자에 side effect를 포함하는 표현식이 오는지 검사하여 short circuit에 의해 평가되지 않을 수 있는 흐름에 대해 검출한다. 이때 함수 콜은 side effect가 있는 것으로 간주한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>ISO26262</ruleSetName>
    <ruleSetDesc><![CDATA[ISO/DIS 26262 Road vehicles - Functional safety.]]></ruleSetDesc>
    <rule>ISO26262_1i</rule>
    <ruleTitle><![CDATA[무조건 분기 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 설계과 구현의 표준으로 복잡한 분기를 막아야 한다. 특히 조건없이 뛰어 넘는 goto의 사용을 막아야 한다. goto 문장과 continue 문장을 사용하지 않는 것이 좋다. 이런 문장의 사용은 프로그램의 제어 흐름을 복잡하게 만들어 가독성과 유지보수성을 떨어뜨린다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>ISO26262</ruleSetName>
    <ruleSetDesc><![CDATA[ISO/DIS 26262 Road vehicles - Functional safety.]]></ruleSetDesc>
    <rule>ISO26262_1j</rule>
    <ruleTitle><![CDATA[함수의 직간접적인 재귀호출 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 직간접으로 함수는 자신을 호출하면 안 된다. 증명할 수 없고, 검사할 수 없는 서브루틴의 호출을 피하기 위함이다. 만일 재귀를 사용한다면, 재귀의 깊이를 예측할 수 있는 판단 기준이 명확해야 한다. while이나 for 문과 같이 반복 구조를 사용하여 재구성함으로써 재귀 호출을 피할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.11_01</rule>
    <ruleTitle><![CDATA[변수 사용 전 값 할당 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 모든 변수는 사용하기 전에 값이 할당되어 있어야 한다. 이것은 꼭 변수 선언시에 초기화를 해야한다는 것은 아니다. ISO C 표준에 다르면 static 변수의 저장 공간은 초기화 해주지 않으면 자동으로 0으로 초기화가 되지만 일반 변수는 자동으로 초기화가 되지 않는다. 따라서 값이 할당되지 않는 변수를 사용하게 되면 의도하지 않은 쓰레기값을 이용하게 되므로 오류를 유발하게 된다. 이 룰에서는 flow 고려하지 않고 명백히 할당이 되지 않은 변수를 사용할 때 검출한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.11_02</rule>
    <ruleTitle><![CDATA[미사용 변수 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 사용되지 않은 변수의 존재는 중요한 논리적 오류를 나타낼수 있다. 이러한 오류를 방지하기 위해, 사용되지 않은 변수들은 코드로부터 확인되고 제거되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.11_03</rule>
    <ruleTitle><![CDATA[기록한 변수를 읽었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 변수에 대해 읽기 없이 한번 이상 기록한 경우 의미 없는 코드로 생략할 수 있는 코드 영역이다. 혹은 중요한 논리적 오류를 내포하고 있을 수 있다. 이러한 오류를 방지하기 위해 기록한 변수를 읽지 않았다면 필요없는 부분인지, 논리적 오류인지 확인하고 제거되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.15_01</rule>
    <ruleTitle><![CDATA[특정 함수 내에서 특정 파라메터를 사용하기 전 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 방어적 프로그래밍의 일환으로 함수의 파라미터들은 사용전에 유효한 범위의 값인지 확인하고 사용하는 것이 좋다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.15_02</rule>
    <ruleTitle><![CDATA[함수의 모든 파라메터가 읽기 전용인지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수의 모든 파라메터는 읽기 전용이어야 한다. 따라서 쓰기가 불가능하게 const를 통해 접근을 제한해야 한다. 함수 내에서 포인터 파라미터의 역참조를 통한 할당도 사용하지 않아야 한다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.15_03</rule>
    <ruleTitle><![CDATA[문자 상수는 반드시 쓰기 접근이 불가능해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 문자 상수는 반드시 쓰기 접근이 불가능해야 한다. 이를 방지하기 위해서 다음과 같은 항목을 검사한다.
- 문자 상수가 const 가 아닌 파라미터의 인자로 사용되지 말아야 한다.
- named array가 아닌 문자 상수의 원소의 수정을 금지한다.
- 문자 상수는 const가 아닌 변수에 할당이 금지된다.
- 특정 함수가 const인 string에 할당하는 것을 금지한다.
이러한 사항들은 변수의 사용에 있어 잘못된 겹쳐 쓰기 또는 실수를 방지하는데 도움이 된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.15_04</rule>
    <ruleTitle><![CDATA[함수의 반환값이 검증되었는지 검사 (함수 호출 인자로 사용된 경우 검증으로 간주 안함) ]]></ruleTitle>
    <ruleDesc><![CDATA[ 방어적 프로그래밍의 일환으로 함수의 반환값은 검증되고 사용되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.16_01</rule>
    <ruleTitle><![CDATA[goto 문장 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 구조화된 프로그래밍을 위해서 goto 문장의 사용을 금지한다. 이런 문장의 사용은 프로그램의 제어 흐름을 복잡하게 만들어 가독성과 유지보수성을 떨어뜨린다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.16_02</rule>
    <ruleTitle><![CDATA[함수의 직간접적인 재귀호출 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 직간접으로 함수는 자신을 호출하면 안 된다. 증명할 수 없고, 검사할 수 없는 서브루틴의 호출을 피하기 위함이다. 만일 재귀를 사용한다면, 재귀의 깊이를 예측할 수 있는 판단 기준이 명확해야 한다. while이나 for 문과 같이 반복 구조를 사용하여 재구성함으로써 재귀 호출을 피할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.16_03</rule>
    <ruleTitle><![CDATA[comment 비율 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ comment 비율은 50% 이상이어야 한다. comment 비율을 높이면 유지보수가 용이하다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.2_01</rule>
    <ruleTitle><![CDATA[파일의 코드 라인 수(LOC) 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 프로그램이 분석 가능하도록 구조화 규칙에 맞게 작성해야 한다. 이를 위해 모듈을 잘 설계해야 한다. 하나의 파일의 코드 라인수(LOC)가 320 이하가 되도록 하는 것이 좋다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.2_02</rule>
    <ruleTitle><![CDATA[모듈의 수행 가능한 경로의 수 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 구조적 프로그래밍 원칙에 따라 구조 복잡성을 최소화해야 한다. 이를 위해 모듈이 수행되는 가능한 경로의 수는 적어야 한다. 모듈이 수행되는 가능한 경로의 수가 많다는 것은 내부 제어 흐름 구조가 복잡하다는 것이므로 가독성을 떨어뜨리고 유지보수를 어렵게 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.2_04</rule>
    <ruleTitle><![CDATA[함수의 최대 nesting depth 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 구조적 프로그래밍 원칙에 따라 구조 복잡성을 최소화해야 한다. 함수의 최대 nesting depth 값이 5를 넘지 않게 해야 한다. 함수의 최대 nesting depth 값이 높다는 것은 제어문이 중복되어 조합되어 있다는 것으로 내부 제어 흐름 구조가 복잡하다는 것이므로 가독성을 떨어뜨리고 유지보수를 어렵게 한다. 하나의 함수에서 너무 많은 역할을 하고 있는 것이 아닌지 검토가 필요하며 가능하면 기능적 분해를 통해 함수를 재구성한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.42_01</rule>
    <ruleTitle><![CDATA[함수 복잡도(cyclomatic complexity number) 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 구조적 프로그래밍 원칙에 따라 구조 복잡성을 최소화해야 한다. 함수의 복잡도 값이 50을 넘지 않게 해야 한다. 함수의 복잡도 값이 높다는 것은 내부 제어 흐름 구조가 복잡하다는 것이므로 가독성을 떨어뜨리고 유지보수를 어렵게 한다. 하나의 함수에서 너무 많은 역할을 하고 있는 것이 아닌지 검토가 필요하며 가능하면 기능적 분해를 통해 복잡도가 낮은 함수들로 재구성한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.43_01</rule>
    <ruleTitle><![CDATA[함수의 코드 라인 수(LOC) 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 프로그램이 분석 가능하도록 구조화 규칙에 맞게 작성해야 한다. 이를 위해 모듈을 잘 설계해야 한다. 하나의 함수의 코드 라인수(LOC)가 100 이하가 되도록 하는 것이 좋다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.43_02</rule>
    <ruleTitle><![CDATA[함수가 하나의 exit point 를 가졌는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수가 하나의 exit point 를 가지는 것이 모듈화 설계에 있어서 바람직하다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.43_03</rule>
    <ruleTitle><![CDATA[함수의 파라미터 개수 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ IEC62279에 의하면 함수의 파라미터 수의 적합한 제한은 5로 명시되어 있다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.4_01</rule>
    <ruleTitle><![CDATA[division by zero를 방지하기 위한 제수 검증 여부 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 0으로 나누게 되면 소프트웨어 실행시 Exception이 발생된다. 따라서 division by zero를 방지하기 위해 제수가 0이 아닌지 검증 한 후에 사용해야만 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.4_02</rule>
    <ruleTitle><![CDATA[변수의 타입 크기를 벗어나는 상수 할당금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 변수의 타입 크기를 벗어나는 상수를 할당하면 해당 변수는 의도하지 않은 값을 가지게 된다. 이는 이후 프로그램의 논리적 오류를 발생시키므로 주의해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.62_01</rule>
    <ruleTitle><![CDATA[동적 메모리 할당 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 동적 변수와 객체의 수, 그리고 새로운 동적 변수나 객체를 할당하기 위한 기존의 자유 메모리 공간은 할당 시, 시스템 상태에 따라 결정되기 때문에, 그 변수나 객체를 할당 또는 이용할 때 결함이 발생할 수 있다. 예를 들면, 시스템에 의해 할당되는 위치에 있는 자유 메모리의 양이 분하지 못하면,또 다른 변수에 대한 메모리 내용이 실수로 덮어 씌워질 수도 있다. 동적 변수나 객체가 이용되지 않는다면, 이런 결함이 방지된다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.62_02</rule>
    <ruleTitle><![CDATA[반복문에는 loop를 종료하기 위해 최대 하나의 break 문이 사용되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 이 규칙은 잘 구조화된 프로그래밍을 위한 규칙이다. 효율적인 코딩을 위해 하나의 loop에는 하나의 break 문이 허용된다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.62_03</rule>
    <ruleTitle><![CDATA[변수 선언 시 초기화 여부 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 변수를 선언할 때 초기화를 함께 하는 것이 좋다. 초기화하지 않을 경우 쓰레기값이 존재하여 논리적 오류를 유발할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.9_01</rule>
    <ruleTitle><![CDATA[함수 내 도달 불가능한 코드 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 이 규칙은 도달할 수 없거나 compile-time에 확인할 수 없는 코드에 관한 규칙이다. 도달할 수 있지만 실행되지 않는 코드는 규칙에서 제외된다(Defensive programming code). 만약 코드의 어떤 부분으로 들어가는 적절한 entry point가 없다면 그 부분에는 도달할 수 없다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.9_02</rule>
    <ruleTitle><![CDATA[swith문 안에 case, default 절이 아닌 문장이 존재하면 안됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[ swith문은 case, default절로 구성되어야 한다. 잘못 구조화된 코드는 논리적 흐름을 잘못 이해하게 만들어 프로그램 오류를 유발한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.9_03</rule>
    <ruleTitle><![CDATA[Switch label(case, default)을 포함하는 가장 가까운 문장이 switch 문인지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Switch label(case, default)을 포함하는 가장 가까운 문장은 switch 문이어야 한다. 잘못 구조화된 코드는 논리적 흐름을 잘못 이해하게 만들어 프로그램 오류를 유발한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.9_04</rule>
    <ruleTitle><![CDATA[문장이 있는 모든 switch 절이 break문으로 끝나는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 문장이 있는 모든 switch 절은 break문으로 끝나야 한다. 만약에 switch 절이 복합문이라면 복합문을 구성하는 마지막 문장이 break여야 한다. 이는 break를 쓰지 않아 fall through되는 오류를 줄여준다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.9_05</rule>
    <ruleTitle><![CDATA[switch문에 default절 존재 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 방어적 프로그래밍의 일환으로 switch문에는 반드시 default절이 존재해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.9_06</rule>
    <ruleTitle><![CDATA[switch 의 default 절은 마지막 절에 위치하는 지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ switch 구문에서 모든 case를 만족하지 못했을 경우를 처리하는 default 절은 switch의  마지막에 위치해야만 해당 처리를 보장할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.9_07</rule>
    <ruleTitle><![CDATA[switch문이 하나 이상의 case 문을 가졌는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ switch문은 하나 이상의 case 문을 가져야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>IEC62279</ruleSetName>
    <ruleSetDesc><![CDATA[International Electrotechnical Commission 62279 , Railway applications - Communications, signalling and processing systems - Software for railway control and protection systems.]]></ruleSetDesc>
    <rule>IEC62279_B.9_08</rule>
    <ruleTitle><![CDATA[비교 조건식의 연산 결과가 항상 같게 나오는 표현식 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 조건식의 결과가 항상 true 혹은 false 값을 가진다면 대부분 프로그래밍 에러라고 볼 수 있다. 따라서 다음과 같은 경우를 검출한다.
-변수와 변수타입의 최대/최소값을 넘는 상수 비교, 변수와 경계값 상수 비교의 결과가 항상 참이거나 거짓인 비교
-비교 조건식의 연산 결과가 항상 같게 나오는 관계연산자(논리곱/논리합) 조합 사용 금지
-비교 조건식의 연산 결과가 항상 같게 나오는 상수 사용 금지 ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_00_01_01</rule>
    <ruleTitle><![CDATA[도달 불가능한 코드 포함 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>

<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 도달 불가능한 코드(unreachable code)는 코드에 도달할 수 있는 경로가 하나도 없는 코드이다. 이런 코드가 존재할 때, 이것이 의도적인 것인지, 적절한 경로가 우연히 빠진 것인지 확실하지 않다. <br/><br/>
컴파일러는 이러한 구조를 위한 코드를 생성하지 않으며, 의도하여 도달 불가능한 코드를 작성하였더라도 최종 실행 코드에는 반영되지 않는다. 편집 과정에서 빠진 문장(statements)이 보통 도달 불가능한 코드이다. <br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_00_01_02</rule>
    <ruleTitle><![CDATA[실행 불가능한 경로 포함 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
프로그림의 실행 경로에서 어떤 입력 데이터에 의해서도 실행할 수 없는 경로가 있을 수 있다. 실행 불가능한 경로는 다음에 의해서 발생된다.<br /><br />
&nbsp;&nbsp;&nbsp;&nbsp;- if, else문의 구조<br />
&nbsp;&nbsp;&nbsp;&nbsp;- 부적절하게 쓰여진 루프 구조<br /><br />
이러한 구조를 제거하기 위해 코드를 다시 작성할 수 있다. 하지만 이러한 과정은 다른 오류를 유발할 수 있다. <br />
방어적인(protective) 코딩 기술은 실행 불가능한 코드를 만들어낼 가능성이 있다. 이러한 코드는 유닛 테스팅 환경에서 실행 가능하다.<br /><br />
]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_00_01_03</rule>
    <ruleTitle><![CDATA[미사용 변수 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 프로젝트 내에서 선언하고 사용하지 않는 변수는 제거해도 프로그램 동작에 영향이 없으며, 이는 잘못된 변수 이름이 어딘가에서 사용되었다는 것을 가리킨다. 이러한 선언을 제거하는 것은, 정확한 변수 대신에 잘못된 변수가 이후에 사용될 가능성을 줄인다.</br></br>
 비트 필드 내에서 패딩(padding)을 사용했다면 padding 멤버는 사용되지 않을 것이고, 해당 규칙의 검출을 피하기 위하여 unnamed 이어야 한다</br></br> ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_00_01_04</rule>
    <ruleTitle><![CDATA[한 번만 사용하는 volatile아닌 POD 변수 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
volatile 아닌 POD를 선언하면 변수는 두 번 이상 사용되어야 한다. 여기서 POD 변수는 숫자 타입, enum, 포인터, c스타일의 구조체를 뜻하며 변수의 사용은 할당이나 참조를 뜻한다. pod 변수를 선언한 뒤 한 번만 사용하는 것은 프로그램의 실행에 영향이 없으므로 필요가 없고 오히려 개발자의 실수를 유발하기 때문에 제거하는 것이 좋다. </br></br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_00_01_05</rule>
    <ruleTitle><![CDATA[사용되지 않은 타입 선언 포함 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 타입이 선언되었지만 사용하지 않는다면, 리뷰어에게는 타입이 쓸모없는 것인지 또는 실수로 쓰이지 않은 것인지에 대한 여부가 확실하지 않다. 따라서, 사용되지 않은 타입은 삭제하는 것이 좋다.</br></br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_00_01_06</rule>
    <ruleTitle><![CDATA[변수에 값을 할당한 후에 한 번도 사용하지 않는 프로세스 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 변수에 값이 할당되고 이후에 한 번도 사용이 안된 경우를 DU dataflow anomaly라고 한다. DU dataflow anomaly는 비효율적일 뿐만 아니라 문제가 될 수 있다.</br></br>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
Loop control variable ( Section 6.6.5 확인 )은 이 규칙에서 제외한다.</br></br>
]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_00_01_07</rule>
    <ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C++에서 반환 값을 사용하지 않고 함수를 호출하는 것은 가능하지만, 이는 에러일 것이다. 함수의 반환 값은 항상 사용되어야 한다. Overloaded operators는 내장된 operator와 같은 방식으로 행동하기 때문에 제외한다.</br></br>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
함수의 리턴값은 (void) 캐스팅의 사용으로 버려질 수 있다.</br></br>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/><br/>
Rule 5–2–4]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_00_01_08</rule>
    <ruleTitle><![CDATA[external side effect가 없는 void 타입 함수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
값을 반환하지 않고 external side effect가 없는 함수는 단지 시간을 낭비하고, 개발자가 기대하는 어떤 결과물 생성에도 관여하지 않을 것이다.<br />
<br />
 external side effect의 예: <br /><br />
 &nbsp;&nbsp;&nbsp;&nbsp; - 파일, 스트림 등의 읽기 또는 쓰기<br />
 &nbsp;&nbsp;&nbsp;&nbsp; - 지역 변수가 아닌 값의 변경<br />
 &nbsp;&nbsp;&nbsp;&nbsp; - 레퍼런스 타입 인자(argument) 값의 변경<br />
 &nbsp;&nbsp;&nbsp;&nbsp; - Volatile 객체의 사용<br />
 &nbsp;&nbsp;&nbsp;&nbsp; - 예외 발생</br></br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_00_01_09</rule>
    <ruleTitle><![CDATA[dead 코드 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 실행되는 코드를 제거해도 프로그램의 결과에 영향을 미치지 않을 때, 이러한 코드들이 dead 코드를 구성한다(redundant 코드로도 알려져 있다). 이는 reviewer가 보기에 의도한 것인지 실수인지 명확하지 않다. <br /><br />]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_00_01_10</rule>
    <ruleTitle><![CDATA[함수를 정의하고 미사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
호출되지 않는 함수 또는 프로시져는 삭제되도 프로그램의 실행 의미에 전혀 영향을 주지 않는다. 하지만, 이런 함수나 프로시져는 유지보수를 필요하게 만들고 코드를 읽을 때 혼동을 야기시킨다. 따라서 프로그램에서 사용하지 않는 함수나 프로시져는 제거하는 것이 좋다. 
</br></br>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
사용되지 않는 프로토타입에 경우 이 규칙을 위반하지 않는다.</br></br>
]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_00_01_11</rule>
    <ruleTitle><![CDATA[가상 함수가 아닌 함수에서 미사용 파라미터 선언 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
사용하지 않는 파라미터는 디자인 변경으로 인한 것이며, 이로 인해 실제 사용하는 함수 인자가 파라미터에 일치하지 않을 수 있다. 
<br/><br/>

<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
콜백 함수로 사용된 함수의 정의 내 이름없는 파라미터의 경우 이 규칙을 위반하지 않는다.</br></br>

<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/><br/>
Rule 0–1–12]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_00_01_12</rule>
    <ruleTitle><![CDATA[가상 함수와 함수를 오버라이드 한 모든 함수의 미사용 파라미터 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
사용하지 않는 파라미터는 디자인 변경으로 인한 것이며, 이로 인해 실제 사용하는 함수 인자가 파라미터에 일치하지 않을 수 있다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/><br/>
Rule 0–1–11]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_00_02_01</rule>
    <ruleTitle><![CDATA[객체를 자신과 겹쳐지는 객체로 할당 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
물리적 공간을 공유하는 객체들 간에 서로를 할당하면 정의되지 않은 동작을 할 가능성이 있다. 
<br/><br/>

<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/><br/>
Rule 9–5–1]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_00_03_01</rule>
    <ruleTitle><![CDATA[런타임 오류 최소화 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp; Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 런타임 검사는 개발자들이 특별히 신경 써야 하는 부분이다. 특히, C++은 런타임 검사 지원이 취약하기 때문이다. C++ 구현은 안전한 소프트웨어를 위해 필요한 동적인 검사 진행이 요구되지 않는다. 그러므로 C++ 개발자는 런타임 에러가 발생할 수 있는 위치에 동적 검사 코드를 넣는 것을 고민하는 것이 필요하다. <br/><br/>

다음은 동적인 검사를 제공해야할 필요가 있는 영역에 대한 몇가지 지침을 제공한다.<br/><br/>

&nbsp;&nbsp;- 산술연산 에러<br/>
  이는 overflow, underflow, 0으로 나누기 또는 shifting을 통한 비트의 손실과 같은 수식의 평가를 포함한다.<br/><br/>
&nbsp;&nbsp;- 포인터 연산<br/>
 주소가 동적으로 계산될때, 계산된 주소가 올바른지 보장 해야 한다. 특히, 구조체나 배열 내부를 가리키는 포인터인 경우, 포인터가 증가, 감소 또는 변형될 때 포인터는 여전히 그 구조체나 배열을 가리켜야 한다.<br/><br/>
&nbsp;&nbsp;- 배열 경계 에러<br/>
배열의 인덱스 접근 시 그 범위 안에서 접근하는지 확인해야 한다.<br/><br/>
&nbsp;&nbsp;- 함수 인자<br/>
 함수인자는 검증되어야 한다.<br/><br/>
&nbsp;&nbsp;- 포인터 역참조<br/>
포인터를 반환하는 함수와 포인터가 역참조 되는 곳에서는 이 포인터가 NULL이 아닌지 확인해야 한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_00_03_02</rule>
    <ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 함수(표준 라이브러리 부분이거나, third party library 또는 사용자에 의해 정의된 함수)가 에러를 발생시키는 것을 확인할 수 있다. 전역 오류 플래그, 파라미터 오류 플래그, 특별한 반환 값 등으로 확인 할 수 있다. 함수가 제공하는 어떤 메카니즘이던 프로그램은 함수가 반환된 후 가능한 한 빨리 에러가 있는지를 검사해야 한다. 그러나, 에러 예방을 위한 방법으로는 함수 입력 값을 검사하는 것이 함수 호출이 완료된 이후에 에러를 검사하려고 하는 것 보다 더욱 강력한 수단이다. 
<br/><br/>

<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/><br/>
Rule 19–3–1]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_00_04_01</rule>
    <ruleTitle><![CDATA[Scaled-integer나 고정 소수점(fixed point) 연산 문서화 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
가능한 모든 케이스를 고려하면서 scaled-integer 또는 fixed-point 연산을 위한 연산 패키지를 디자인하고 구현하는 것은 굉장히 어려운 일이다. 둘 중 하나를 사용한다면, 이 규칙은 모든 이슈가 구현에 의해 커버된다는 것을 증명하는 문서를 만들기를 요구한다. 
<br/><br/>
]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_00_04_02</rule>
    <ruleTitle><![CDATA[부동소수점(floating point) 연산 문서화 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 Floating-point 연산의 사용은 높은 레벨의 숫자 분석 능력, 컴파일러와 target 하드웨어에 대한 철저한 지식을 요구한다.

<br/>
<br/>
<b>참조 논문</b><br/>
[1] David Goldberg, 'What Every Computer Scientist Should Know about Floating-Point Arithmetic', Xerox Palo Alto Research Center, Palo Alto, CA, 1991
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_00_04_03</rule>
    <ruleTitle><![CDATA[부동소수점(floating point) 연산의 표준 준수 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
Floating-point 연산은 다양한 표준 연산들이 있다. 표준 연산은 [1] 표준에 기술된 방법에 따라 개발되고 테스트 되어야 하며 이것들을 제대로 지키지 않으면  다양한 문제들이 나타날 수 있다. 
<br/>
<br/>
<b>참고 문헌</b><br/>
[1] IEEE Standard for Binary Floating-Point Arithmetic," ANSI/IEEE Std 754-1985 , vol., no., pp.0_1,, 1985
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_01_00_01</rule>
    <ruleTitle><![CDATA[사용하는 코드는  C++ 표준을 준수해야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
MISRA C++ 은 ISO_IEC 14882_2003[1]를 기반으로 한다. 사용하는 C++ 컴파일러가 표준과 다르다면 ISO_IEC 14882_2003[1] 를 통해 다른요소들을 확인하여야 한다.
<br/>
<br/>
<b>참고문헌</b><br/>
[1] ISO/IEC 14882:2003: The C++ Standard Incorporating Technical Corrigendum 1, International Organization For Standardization, 2003
]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_01_00_02</rule>
    <ruleTitle><![CDATA[다중 컴파일러 사용 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 다중 컴파일러는 공통적으로 정의된 인터페이스를 가질 때만 사용한다. 다중 컴파일러는 혼합된 언어, 다른 컴파일러, 같은 컴파일러의 다른 버전이나 같은 컴파일러의 다른 형상을 의미한다. 다중 컴파일러는 C++ 언어의 특성을 이해하고 있어야 한다. 이 규칙은 extern 'C' 의 사용을 포함한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_01_00_03</rule>
    <ruleTitle><![CDATA[컴파일러에서 정수 나눗셈을 문서화해야 함  ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
  ISO를 준수하는 컴파일러는 부호가 서로 다른 signed integer의 나눗셈에서 둘 중 하나의 동작을 할 수 있다. 첫 번째로, 음수 나머지(-5/3 = -1 나머지 -2)로 계산할 수도 있고 양수 나머지(-5/3 = -2 나머지 1)로 계산할 수도 있다. 컴파일러에 의해 실행된 결과를 결정하고 문서화 하는 것이 개발자를 위해 중요하다. 이 규칙은 나눗셈의 정의와 마찬가지로 나머지 계산의 정의도 포함하고 있다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_02_02_01</rule>
    <ruleTitle><![CDATA[character set과 encoding을 문서화해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 소스 코드는 character set으로 이루어진다. character set 을 문서화하면 개발자의 주의를 환기하여, 호환되지 않는 character set을 사용하여 발생하는 문제를 예방할 수 있다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_02_03_01</rule>
    <ruleTitle><![CDATA[trigraph 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
  Trigraph란 '??' 다음에 특정 문자열이 나오는 형태이다. 이 문자를 사용하면 '??' 를 사용하려고 했을 때와 혼동을 유발한다. <br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_02_05_01</rule>
    <ruleTitle><![CDATA[digraph 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
   digraphs는 다음과 같다.<br/><br/>'<%, %>, <:, :>, %:, %:%:'<br/><br/>digraphs는 개발자의 의도와는 다를 수 있다. <br/><br/>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_02_07_01</rule>
    <ruleTitle><![CDATA[C 스타일 주석 안에서 C 스타일 내부 주석 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
    일부 확장을 제외하고 C++에서는 C 스타일 주석 안에서 내부 주석을 지원하지 않는다. '/*' 로 시작한 주석은 첫 번째 '*/'문자를 만날 때까지 유효하다.  <br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_02_07_02</rule>
    <ruleTitle><![CDATA[코드 뭉치를 C 스타일 주석으로 주석 처리 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
     C 스타일 주석은 내부 주석을 지원하지 않기 때문에 이미 주석이 존재하는 코드 뭉치를 주석 처리하면 위험할 수 있다. 주석은 소스에서 제거하지 않은 코드의 상태만 설명해야 한다. 주석 처리한 코드 뭉치는 코드를 관리할 때 혼란을 줄 수 있다. 더 나은 방법은 소스 코드의 변한 기록을 남기는 것이다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/><br/>
Rule 2–7–1, Rule 2–7–3]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_02_07_03</rule>
    <ruleTitle><![CDATA[코드 뭉치를 CPP 스타일 주석으로 주석 처리 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 주석은 소스에서 제거하지 않은 코드의 상태만 설명해야 한다. 주석 처리한 코드 뭉치는 코드를 관리할 때 혼란을 줄 수 있다. 더 나은 방법은 소스 코드의 변한 기록을 남기는 것이다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/><br/>
Rule 2–7–2]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_02_10_01</rule>
    <ruleTitle><![CDATA[서로 다른 식별자에 구별하기 어려운 문자 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 문자를 출력하는 폰트에 따라 다른 문자라도 같은 형태로 보일 수 있다. 이런 경우에 개발자는 식별자를 다른 식별자와 혼동할 수 있다. <br/>
<br>검사 대상:<br/>
<br>&nbsp;&nbsp;&nbsp;&nbsp;1. 대소문자만 다른 경우, 
<br>&nbsp;&nbsp;&nbsp;&nbsp;2. '_'문자의 유무,
<br>&nbsp;&nbsp;&nbsp;&nbsp;3. 'O' 와 '0', 
<br>&nbsp;&nbsp;&nbsp;&nbsp;4. 'I' 와 '1', 
<br>&nbsp;&nbsp;&nbsp;&nbsp;5. 'I' 와 'l'(el),
<br>&nbsp;&nbsp;&nbsp;&nbsp;6. 'l'(el) 과 '1', 
<br>&nbsp;&nbsp;&nbsp;&nbsp;7. 'S' 와 '5', 
<br>&nbsp;&nbsp;&nbsp;&nbsp;8. 'Z' 와 '2', 
<br>&nbsp;&nbsp;&nbsp;&nbsp;9. 'n' 과 'h', 
<br>&nbsp;&nbsp;&nbsp;&nbsp;10. 'B' 와 '8', 
<br>&nbsp;&nbsp;&nbsp;&nbsp;11. 'rn' 과 'm' 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_02_10_02</rule>
    <ruleTitle><![CDATA[식별자는 외부 범위(scope)의 식별자(identifier)를 가리면 안됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 내부에 선언한 식별자의 이름이 외부 scope의 식별자의 이름과 같으면 외부 식별자를 가려서 개발자에게 혼란을 줄 수 있다. <br/><br/>

내부, 외부 scope의 정의는 다음과 같다:<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;- file scope를 가진 식별자가 가장 외부의 scope 이다.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- block scope를 가진 식별자는 더 내부의 scope 이다.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- 연속, 중첩된 block은 더 내부의 scope 이다.<br/><br/>
 ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_02_10_03</rule>
    <ruleTitle><![CDATA[typedef 이름에는 유일한 식별자를 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 class, union이나 enum의 이름을 다른 타입의 이름이나 목적으로 사용하면 개발자에게 혼란을 줄 수 있다. 
<br/><br/>같은 프로젝트 안의 class, union이나 enum 의 이름은 중복 사용해서는 안 된다. <br/><br/>정의가 헤더 파일에 존재하고 헤더 파일을 여러 소스 파일에서 가져다 사용하는 경우는 예외이다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_02_10_04</rule>
    <ruleTitle><![CDATA[class, union 이나 enum의 이름은 유일해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 class, union이나 enum의 이름을 다른 타입의 이름이나 목적으로 사용하면 개발자에게 혼란을 줄 수 있다. 
<br/><br/>같은 프로젝트 안의 class, union이나 enum 의 이름은 중복 사용해서는 안 된다. 
<br/><br/>정의가 헤더 파일에 존재하고 헤더 파일을 여러 소스 파일에서 가져다 사용하는 경우는 예외이다. 

<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_02_10_05</rule>
    <ruleTitle><![CDATA[static 변수나 함수의 이름은 유일해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 scope에 관계 없이 static 식별자의 이름을 같은 프로젝트 안에서 사용하면 안 된다. 대상은 external linkage의 객체나 함수와 static 인 객체나 함수를 포함한다. 컴파일에는 문제가 없지만 개발자에게 혼란을 줄 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_02_10_06</rule>
    <ruleTitle><![CDATA[변수나 함수에 타입과 같은 식별자 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C++에서는 C 호환성 때문에 같은 식별자를 타입과 변수, 혹은 타입과 함수에 사용 가능하다. 이는 개발자에게 혼란을 줄 수 있다. 

<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_02_13_01</rule>
    <ruleTitle><![CDATA[허용한 확장문자열만 사용 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 정의하지 않은 확장 문자열은 정의하지 않은 행위(undefined behaviour)를 유발한다. ISO/IEC 14882:2003에서 정의한 확장문자열만 사용해야 한다.<br/> (\', \?, \\, \t, \v, \f, \a, \b, \n, \r, \0) 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/><br/>
Rule 2-13-2
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_02_13_02</rule>
    <ruleTitle><![CDATA[8진수 확장 문자와 상수를 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
   0으로 시작하는 상수는 8진수로 취급한다. 따라서 개발자가 의도한 10진수와는 다른 값이 들어갈 수 있다. <br/><br/>8진수 확장 문자열의 마지막에 10진수가 들어가거나(8,9) 의도하지 않은 문자가 할당될 수 있다. <br/><br/>정수형 상수 0은 8진수 상수이지만 예외이다. '\0' 만이 유일하게 허락되는 8진수 확장 문자열이다. <br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_02_13_03</rule>
    <ruleTitle><![CDATA[unsigned 타입인 8진수나 16진수 literal에는 접미사를 'U'사용 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 정수 타입은 다음과 같은 복잡한 요소에 의존적이다:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- 상수의 대소, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;- 상수 타입의 구현 크기(The implemented sizes of the integer types), <br/>
&nbsp;&nbsp;&nbsp;&nbsp;- 접미사의 존재 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;- 값이 표현되는 숫자베이스( 10진수, 8준수, 16진수 등 )<br/><br/>
 예를들어, 0x8000은 16비트 환경에서는 unsigned이고, 32비트 환경에서는 signed int이다. unsigned int와 int를 overload했을 때 0x8000은 정수 크기의 구현에 의존한다. unsigned 값이면 'U' 접미사를 붙여야 한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_02_13_04</rule>
    <ruleTitle><![CDATA[literal의 접미사에 소문자 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 literal의 접미사에 대문자를 사용하면'1' 과 'l'(el) 사이의 혼동을 없앨 수 있다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/><br/>
ISO/IEC 14882:2003 [1] §2.13]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_02_13_05</rule>
    <ruleTitle><![CDATA[narrow string과 wide string literal을 연결해서 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 wide string과 narrow string literal 연결은 정의되지 않은 행위(undefined behaviour)를 유발한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_03_01_01</rule>
    <ruleTitle><![CDATA[헤더 파일에 함수나 객체 정의 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
헤더 파일에는 다양한 선언들만 사용해야 하고 객체의 정의나 함수의 정의를 포함하면 안 된다. 
<br/>
C/C++ 은 ODR(one definition rule)에 따라 동일한 함수나 객체는 전체 프로그램에서 유일하게 존재해야 하며, 헤더파일에 이러한 객체 정의나 함수의 정의를 포함하게 되면 미숙한 개발자가 #include 로 해당 헤더를 포함하여 문제를 발생시킬 위험이 있다. 따라서 사전에 이런 위험을 관리하기 위해서는 헤더에는 객체나 함수의 정의를 포함시키지 않는 것이 좋다. 
<br/>
<br/>
성능을 위한 inline 과 static 정의는 이 규칙에서 제외된다.
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_03_01_02</rule>
    <ruleTitle><![CDATA[블럭단위에 함수 선언 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
블럭단위에 함수를 선언하는 것이 필요하지 않으며, 해당 함수의 선언이 필요하다면 함수 밖에 선언하면 된다. 
<br/><br/>
함수안에 선언을 넣게 되면, 아래 예제 처럼 함수 선언과 객체의 정의와 헷갈리는 상황이 발생할 수 있다.
<br/><br/>
<center>
<table>
<tr><td>
<pre>
class A{ };
&nbsp;&nbsp;&nbsp;&nbsp;void b1(){
&nbsp;&nbsp;&nbsp;&nbsp;void f1 ();
&nbsp;&nbsp;&nbsp;&nbsp;A a ();       // function declaration? or object definition?
}
</pre>
</tr></td>
</table>
</center>
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_03_01_03</rule>
    <ruleTitle><![CDATA[배열 크기가 명시적이어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 배열의 크기를 명시적으로 정해주는 것이 안전하다. 명시적으로 배열의 크기를 표시해 주면 컴파일러가 배열의 크기를 확인하고 올바르지 않으면 경고해 줄 수 있다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_03_02_01</rule>
    <ruleTitle><![CDATA[모든 변수나 함수의 선언은 호환되는 타입을 가져야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 다른 두 translation unit에서 객체나 함수 선언이 있다면 함수 선언이 있으면 정의하지 않은 행동(undefined behaviour)이다.
<br/><br/> 객체나 함수 선언의 타입을 호환되게 하는 가장 쉬운 방법은 동일하게 선언하는 것이다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/><br/>
Rule 3–9–1]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_03_02_02</rule>
    <ruleTitle><![CDATA[One Definition Rule을 지켜야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 One Definition Rule을 어기면 정의하지 않은 행위를 유발한다. 일반적으로 프로그램에는 inline이 아닌 함수나 객체는 한 번만 정의해야 한다. <br/><br/>
덧붙여 타입, 템플릿, inline 함수의 정의는 같은 토큰(token)으로 구성되어야 한다. 
<br/><br/>이 규칙에서는 typedef는 타입으로 취급한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_03_02_03</rule>
    <ruleTitle><![CDATA[여러 translation unit에서 사용하는 변수나 함수는 한 파일에서 한 번만 선언해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
한 타입의 단일 선언을 가질때, 컴파일러는 함수 또는 객체에 대하여 같은 요소에 대해서 호환되지 않는지 감지할 수 있다.<br/><br/>
 일반적으로 헤더 파일의 외부 식별자(external identifier)를 선언하고 이를 include하여 정의하거나 사용해야 여러 파일에 동일한 외부 식별자 선언시 컴파일러는 타입이 호환되지 않을 때 오류를 발견하지 못할 수 있다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_03_02_04</rule>
    <ruleTitle><![CDATA[external linkage 식별자의 중복 정의 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 서로 다른 translation unit에서 식별자를 동일하게 혹은 다르게 정의하거나, 정의가 없는 것은 허용하지 않는다.
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
templates와 inline함수는 제외한다.</br></br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_03_03_01</rule>
    <ruleTitle><![CDATA[external linkage 변수나 함수는 헤더 파일에 선언해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 다른 translation unit에서 접근할 수 있도록 의도한 external linkage 변수나 함수 선언은 헤더파일에 있어야 한다. 
<br/><br/>만약 external linkage로 선언할 필요가 없으면 변수나 함수를 static으로 선언하거나 이름없는 namespace안에 선언해야 한다. 
<br/><br/>변수와 함수의 가시성(visibility)를 줄이는 좋은 행동이다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
main 이나 이름없는 namespace의 멤버는 예외이다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_03_03_02</rule>
    <ruleTitle><![CDATA[internal linkage인 함수는 static으로 재 선언해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 static 함수는 internal linkage다. 이런 함수의 재 선언은 static 예약어를 필요로 하지 않지만 여전히 internal linkage이다. 하지만 암시적이라 개발자에게 명확하지 않다. 그러므로 static을 명시적으로 표시하는 것이 좋다
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_03_04_01</rule>
    <ruleTitle><![CDATA[하나의 함수에서만 사용되는 변수는 함수 scope에 정의해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 최소의 block scope에 값을 선언하면 그 값의 가시성을 줄여서 의도하지 않은 사용을 줄일 수 있다. 전역 객체는 둘 이상의 함수에서 사용해야 한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_03_09_01</rule>
    <ruleTitle><![CDATA[객체나 함수의 선언과 정의에서 타입이 일치해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
선언된 객체나 함수의 타입이 원래의 것과 호환되더라도 토큰(token) 단위로 동일하지 않으면 개발자가 쉽게 혼동 할 수 있다. 따라서 이러한 요소는 최대한 배제해야 한다.
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/><br/>
Rule 3–2–1, Rule 3–9–2]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_03_09_02</rule>
    <ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 기본 숫자 타입인 char, int, short, long, float, double, long duble 대신 크기를 표현한 typedef를 사용해야 한다. 개발자는 typedef를 선언할 때, 타입들의 실제 구현을 알아야 한다. <br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
1. wchar_t 타입은 항상 wide character를 지원하는 타입에 매핑되기 때문에 typedef가 필요하지 않다.<br/><br/>
2. 부호 없는 char 타입일 경우 크기와 부호 유무를 typedef에 표시하지 않아도 된다.
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_03_09_03</rule>
    <ruleTitle><![CDATA[실수형을 underlying bit로 표현 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 실수형의 저장 형태는 컴파일러마다 다르므로 값을 직접 저장하는 방법으로 다루면 안 된다. in-built 연산자나 함수는 개발자에게 저장 형태를 숨겨야 한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_04_05_01</rule>
    <ruleTitle><![CDATA[bool 타입 표현식을 특정 built-in 연산자의 피연산자로 사용하면 안 된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
논리 연산자(&&)와 비트 연산자(&)를 자주 혼동하는 경우가 있기 때문에, bool 타입의 피연산자를 대입 연산자, 논리 연산자, 관계 연산자, 참조 연산자나 조건 연산자가 아닌 연산자와 사용하는 것은 개발자의 실수일 수 있으므로 확인이 필요하다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_04_05_02</rule>
    <ruleTitle><![CDATA[enum 타입 표현식을 특정 built-in 연산자의 피연산자로 사용하면 안 된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 enum 타입에는 [], =, ==, != , <, <=, >, >= 외의 연산자는 사용하면 안 된다. enum은 구현에 따라 정의(implementation-defined)되므로 산술 연산에 사용하면 안 된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_04_05_03</rule>
    <ruleTitle><![CDATA[char와 wchar_t 표현식을 특정 연산자의 피연산자로 사용하면 안 된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 = , ==, !=, &, +, -, <, <=, >, >= 외의 연산자를 char나 wcahr_t 에 사용하면 안 된다. character 데이터의 처리는 개발자가 예상하지 못한 결과를 발생시킬 수 있다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
예외적으로, 연관된 제약사항이 있다면, 다음의 연산자는 사용될 수 있다.<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;- 0-9 에서 '0'의 범위 내에서 정수값을 더하기 위해 + 연산자가 사용된 경우<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- 문자 '0'에서 뺄셈을 위해 - 연산자가 사용된 경우<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- 문자가 숫자를 나타내는지 확인하기 위해 관계 연산자 <,<=,>,>= 가 사용된 경우]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_04_10_01</rule>
    <ruleTitle><![CDATA[NULL을 정수로 사용하지 마라. ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C++에서 literal 0은 상수 타입이면서 null-pointer-constant이다. 개발자는 NULL을 null-pointer-constant로도 혹은 정수 0으로 의도하고 사용할 수 있다. NULL은 pointer 타입으로 취급해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_04_10_02</rule>
    <ruleTitle><![CDATA[Literal 0을 null-pointer-constant로 사용하지 마라. ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C++에서 literal 0은 상수 타입이면서 null-pointer-constant이다. 개발자는 NULL을 null-pointer-constant로도 혹은 정수 0으로 의도하고 사용할 수 있다. 0은 정수로 취급해야 한다. 
]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_00_01</rule>
    <ruleTitle><![CDATA[모든 표현식의 계산 값은 표준에 따른 어떤 평가 순서로 평가하여도 그 값이 같아야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 '&&', '||', '? :', ',' 같은 연산자를 제외한 다른 연산자들의 경우 하위 표현식(sub-expression)의 평가 순서는 표준에 의해 정의되지 않았기 때문에, 컴파일러마다 다른 계산 순서를 가질 수 있다. 이는 하위 표현식들의 계산 순서를 신뢰할 수 없다는 것이며 특히 어떠한 부작용(side-effect)이 발생할지 미리 예측하기 어렵다.
<br/><br/>
 평가 순서에 대한 문제는 어떤 것이 먼저 평가되느냐에 대한 문제가 아니기 때문에 괄호를 쓴다고 하여 해결할 수 있는 문제가 아님을 기억해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_00_02</rule>
    <ruleTitle><![CDATA[표현식(expression)에서 C++ 연산자 우선순위 규칙을 변경하고자 할 때에만 괄호를 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
  기본적인 연산자 우선순위와 동일하게 추가적인 괄호를 사용하는 경우, 괄호는 이를 강조하는 의미로 사용될 수 있다. 이는 C++의 복잡한 우선순위 규칙을 사용하여 발생할 수 있는 실수들을 방지할 수 있으며 코드를 읽기 쉽게 만들어준다. 그러나 너무 많은 괄호들은 코드를 읽기 힘들게 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_00_03</rule>
    <ruleTitle><![CDATA[cvalue 표현식(expression)의 근본 타입(underlying type)을 다른 타입으로 묵시적 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 cvalue 는 정의에 의해, 기본 변환이 더 이상 일어나지 않는 값을 의미한다(MISRA C 에서는 complex expression 이라 정의했다). 근본 타입은 이 cvalue 의 것을 따르게 된다. MISRA 에서의 모든 연산은 근본 타입이 바뀌지 않는 상태에서 완료되어야 한다. 서로 다른 타입간의 묵시적 변환은 프로그램의 잠재적인 오류가 될 수 있으며, 일반적인 개발자들은 이것을 발견하기가 어렵다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_00_04</rule>
    <ruleTitle><![CDATA[의도한 타입(underlying type)의 부호를 변경하는 묵시적 정수 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 부호 있는 타입으로부터 부호 없는 타입으로의 변환은 대부분 프로그래머의 실수 이다. 경우에 따라서 이러한 변환은 정상적으로 작동하는 것처럼 보이겠지만 실제로는 컴파일러에 의해 정의된 동작(implementation-defined behavior) 이 발생되는 것임을 알아야 한다. 이 것은 개발자의 예상과 다를 수 있으므로 매우 위험하다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_00_05</rule>
    <ruleTitle><![CDATA[부동소수 타입과 정수 타입 사이의 묵시적 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>

<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 부동 소수점 타입을 정수형 타입으로 변환하면 값이 부정확해지며, 만약 변환 후의 값을 정수형 타입으로 표현할 수 없는 경우, 정의되지 않은 행동(undefined behavior)을 발생시킨다. <br/><br/>정수형으로의 변환이 꼭 필요한 경우라면 캐스팅연산자를 사용하여 명시적으로 변환해서 사용할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_00_06</rule>
    <ruleTitle><![CDATA[정수형이나 부동소수형의 근본 타입(underlying type)의 크기를 줄이는 묵시적 형변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 타입의 크기가 줄어들게 되면, 값의 정확도가 손실되므로 개발자가 원하는 값을 얻을 수 없게 된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_00_07</rule>
    <ruleTitle><![CDATA[cvalue 표현식(expression)의 근본타입(underlying type)이 변하는 부동소수형과 정수형간의 명시적 변환금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 대부분의 경우, cvalue 표현식에 적용된 명시적 변환은 cvalue 자체의 계산에는 영향을 미치지 않는다. 따라서 이러한 명시적 변환은 불필요하다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_00_08</rule>
    <ruleTitle><![CDATA[cvalue 표현식(expression)의 근본타입(underlying type)의 크기를 증가시키는 정수형과 부동소수형간의 명시적 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 대부분의 경우, cvalue 표현식에 적용된 명시적 변환은 cvalue 자체의 계산에는 영향을 미치지 않는다. 따라서 이러한 명시적 변환은 불필요하다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_00_09</rule>
    <ruleTitle><![CDATA[cvalue 표현식(expression)의 정수형 근본타입(underlying type)의 부호를 변경하는 명시적 정수 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 부호 있는 타입으로부터 부호 없는 타입으로의 변환은 대부분 프로그래머의 실수 이거나 개발자의 예상과 다를 수 있으므로 사용을 자제한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_00_10</rule>
    <ruleTitle><![CDATA[비트 연산자 ~ 와 << 를 unsigned char 또는 unsigned short 을 근본타입(underlying type)으로 갖는 피연산자에 사용하면 결과를 반드시 원래의 근본타입으로 명시적 변환해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 ~와 <<가 작은 정수 타입에 사용된 경우 이 연산은 정수 승격(integer promotion) 변환에 의해 signed int 환경에서 사용되고 그 결과값은 예상치 못한 높은 차수의 bits들을 포함할 수 있다. 따라서 개발자가 의도하지 않은 값이 될 수 있다. 
<br/><br/>
 <span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
unsigned char 또는 unsigned short 타입을 피연산자로 가지는 ~ 연산 또는 << 연산에 의해 얻는 결과 값을 같은 underlying type으로 바로 할당하는 경우(함수의 인자 또는 리턴값을 포함)는 그 변환이 묵시적이더라도 허용한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_00_11</rule>
    <ruleTitle><![CDATA[plain char 타입은 문자들을 위한 공간 이외의 목적으로 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 plain char 타입의 부호 여부는 컴파일러마다 다르며, 이 타입에 표준에 정의된 문자가 아닌 정수 값을 저장하는 것은 원래의 목적을 위배한다. 8비트의 저장공간이 필요한 경우 명시적인 부호 여부를 포함하여 적절한 타입 재정의를 통해 새로운 타입을 도입하여 사용하는 것이 더 낫다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 3-9-2, Rule 5-0-12]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_00_12</rule>
    <ruleTitle><![CDATA[부호 있는 char 타입은 숫자들을 위한 공간 이외의 목적으로 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 이 규칙은 MISRA_CPP_05_00_11 와 비슷하지만 만약 문자 대신 숫자를 저장하기 위한 용도로 사용하기 위해서는 부호 있는 char 타입을 사용하길 권고한다. plain char 타입의 부호 여부는 컴파일러마다 다르며, 이 타입에 표준에 정의된 문자가 아닌 정수 값을 저장하는 것은 원래의 목적을 위배한다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 3-9-2, Rule 5-0-11]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_00_13</rule>
    <ruleTitle><![CDATA[조건문과 반복문 등에 사용된 조건들의 최종 결과타입은 bool 이어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C 와는 다르게 C++ 은 bool 타입이 새로 추가되었다. 하지만 legacy 코드와의 호환성을 위해 조건문은 bool 타입 대신에 정수형 타입의 값을 0 과 비교하는 방식을 사용할 수도 있다. 조건문에 bool 타입을 사용하면 코드 읽기와 유지보수가 수월해진다.
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
조건식에 단일 값을 할당하는 식이 들어있는 경우는 이 규칙에서 검출하지 않는다. 
]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_00_14</rule>
    <ruleTitle><![CDATA[연산자의 첫번째 피연산자는 bool 타입만 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C 와는 다르게 C++ 은 bool 타입이 새로 추가되었다. 하지만 legacy 코드와의 호환성을 위해 조건문은 bool 타입 대신에 정수형 타입의 값을 0 과 비교하는 방식을 사용할 수도 있다. 연산자의 조건문에 bool 타입을 사용하면 코드 읽기와 유지보수가 수월해진다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_00_15</rule>
    <ruleTitle><![CDATA[포인터에 대한 명시적 산술연산 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
이 규칙은 포인터에 대한 명시적 산술연산을 금지하는 것이다. 배열 인덱스를 통해 접근하는 것은 포인터 조작에 비해 더 명확하므로 에러를 적게 발생시킬 수 있다.
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
배열을 가리키는 포인터에 대한 iterator의 경우 증감 연산자 사용은 허용한다.
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 0-3-1, Rule 5-0-16
]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_00_16</rule>
    <ruleTitle><![CDATA[포인터 피연산자와 포인터 산술의 결과로 생긴 피연산자를 가리키는 포인터는 배열의 범위안의 원소를 가리켜야함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 이 규칙은 다음과 같은 표현식에 적용된다 :<br/><br/>
 &nbsp;&nbsp;&nbsp;&nbsp;- integer_expression + pointer_expression<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;- pointer_expression + integer_expression<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;- integer_expression + pointer_expression<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;- ++pointer_expression<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;- pointer_expression++<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;- --pointer_expression<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;- pointer_expression--<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;- pointer_expression [ integer_expression ]
<br/><br/>
 포인터가 배열 범위를 벗어나 가리키면 예기치 않은 오류가 발생할 수 있고, 이는 정의되지 않은 행동이다.
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 5-0-15]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_00_17</rule>
    <ruleTitle><![CDATA[포인터 차감 연산은 같은 배열에 대한 요소간에 이루어져야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
이 규칙은 다음의 표현식에 적용한다:<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;pointer_expression_1 - pointer_expression_2<br/><br/>
pointer_expression_1 와 pointer_expression_2 는 배열 요소를 가리킨다.<br/><br/>
pointer_expression_1 와 pointer_expression_2 가 같은 배열의 요소를 가리키지 않거나 배열의 끝을 넘어서 가리키는 경우, 이는 정의되지 않은 행동이다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_00_18</rule>
    <ruleTitle><![CDATA[포인터간의 대소 비교는 같은 배열에 대한 요소 간에 이루어져야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 포인터간의 대소 비교 시에 같은 배열을 참조하지 않는 경우 결과값이 실행마다 달라질 수 있다. 따라서 이러한 방법으로 목적한 결과를 얻으려는 시도는 지양해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_00_19</rule>
    <ruleTitle><![CDATA[3차원 이상의 포인터 선언 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 2차원을 초과 하는 포인터 선언은 가독성과 유지보수성을 심히 해치므로 사용하지 않는 것이 좋다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_00_20</rule>
    <ruleTitle><![CDATA[이항 비트 연산의 상수가 아닌 피연산자들은 모두 같은 근본타입(underlying type)을 가져야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 비트 연산은 보통의 경우 같은 비트수를 같은 피연산자간에 이루어진다. 이것을 보장하기 위해 상수가 아닌 피연산자가 비트 연산에 사용될 때에는 반드시 근본타입이 동일하게 유지해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_00_21</rule>
    <ruleTitle><![CDATA[이항 비트 연산의 피연산자들은 모두 같은 부호 없는(unsigned) 근본타입(underlying type)을 가져야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 비트 연산은 보통의 경우 부호 비트를 다루는 연산을 수행하지 않는다. 또한 표준에서 언급한 것처럼 음수 값에 대한 >> 연산은 컴파일러마다 그 결과가 다르다. 따라서 비트 연산자를 사용할 때 반드시 근본타입이 부호가 없는 타입만 사용해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_02_01</rule>
    <ruleTitle><![CDATA[논리연산자(&&, ||)의 각 피연산자는 괄호를 사용하여 후위 표현식임을 명확히 해야함.]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 괄호를 사용하는 것은 코드 가독성에도 좋고, 코드를 작성한 개발자의 의도를 알아차리는 데에도 중요한 역할을 한다.
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
표현식이 logical &&, 또는 logical ||만으로 이루어져있다면 추가적인 괄호는 필요하지 않다. (후위 표현식(postfix-expression): 일차식(primary-expression) 또는 일차식에 후위 연산자가 붙은 표현식) ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_02_02</rule>
    <ruleTitle><![CDATA[Virtual 상위(base) 클래스를 가리키는 포인터는 dynamic_cast를 이용해서 하위(derived) 클래스를 가리키는 포인터로의 변환해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 Virtual 상위 클래스에서 하위 클래스로의 변환에서, dynamic_cast 이외의 방법은 정의하지 않은 동작을 할 가능성이 있다. dynamic_cast의 동작은 정의되어 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_02_03</rule>
    <ruleTitle><![CDATA[상위(base) 클래스를 하위(derived) 클래스로 변환하는 것은 다형(polymorphic) 타입 간에 이루어져서는 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 하위 변환(downcast)은 자신이 하위 클래스 타입으로 변환될 때 이루어진다. 다형성은 계층(hierarchy)의 인터페이스와 구현 사이에 강한 추상화를 가능하게 한다. 명시적인 변환은 이러한 추상화 계층을 무시하기 때문에 높은 수준의 결합성(coupling)과 종속성(dependency)을 갖는다. 즉, 추상화를 해치기 때문에 좋은 코드가 아니다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_02_04</rule>
    <ruleTitle><![CDATA[C-스타일 변환과 함수형 표기(functional notation) 변환은 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C-스타일 변환과, 변환 생성자를 호출하지 않는 함수형 표기 변환은 관련 없는 타입 간의 변환을 가능하게 하기 때문에 사용하면 안 된다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
void로의 C-스타일 변환은 non-void 함수 호출의 반환 값이 무시된다는 것을 확인하기 위해 쓰일 수 있다. 그리고 explicit 생성자 호출 또한 허용한다.
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 14882:2003 [1] §5.2.3, §5.4]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_02_05</rule>
    <ruleTitle><![CDATA[변환 하면서 포인터나 참조형의 const 또는 volatile이 누락되면 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 타입에서 const 또는 volatile이 누락되면 개발자가 의도하지 않은 undefined behaviour가 발생할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_02_06</rule>
    <ruleTitle><![CDATA[함수 포인터에서 다른 포인터 타입으로(다른 함수 포인터 포함) 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 함수 포인터에서 함수가 아닌 포인터 타입으로의 변환은 undefined behavior를 발생시킨다. Undefined behaviour는 함수 호출이 함수 포인터 변환의 결과인 포인터를 사용해서 이루어질 때 또한 발생할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_02_07</rule>
    <ruleTitle><![CDATA[포인터 타입 객체는 관련 없는 포인터 타입으로 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 포인터 타입 객체는 관련 없는 포인터 타입으로 직, 간접적 변환하면 안 된다. 포인터에서 관련 없는 타입으로의 변환 결과는 정의되어 있지 않다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_02_08</rule>
    <ruleTitle><![CDATA[정수 타입 또는 void 타입을 가리키는 포인터를 포인터 타입 객체로 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 일반적으로, 정수 또는 void 타입을 가리키는 포인터를 객체로 변환하는 것은 unspecified behavior를 발생시킨다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_02_09</rule>
    <ruleTitle><![CDATA[포인터 타입에서 정수 타입으로 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 포인터가 정수로 변환될 때 요구되는 정수의 크기는 implementation-defined 이다. 포인터와 정수형 타입 간의 변환은 가능하면 피하는 것이 좋다. 단, 메모리 mapped 레지스터 또는 다른 하드웨어에서는 피할 수 없다. 또한, C++은 포인터에서 어떤 소수점 타입으로도 변환을 허용하지 않는다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_02_10</rule>
    <ruleTitle><![CDATA[표현식(expression)에서 ++과 -- 연산자는 다른 연산자와 혼용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 ++, -- 연산자가 다른 산술 연산자와 혼용되는 것은 추천하지 않는다. 왜냐하면 코드의 가독성을 해칠 수 있으며, 잠재적인 undefined behaviour를 가져서, 연산자를 포함한 문장(statement)에 추가적인 side effect를 가져올 수 있다. 이러한 연산자는 다른 산술 연산자로부터 독립적으로 쓰이는 것이 안전하다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 14882:2003 [1] §5.2.6, §5.3.2]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_02_11</rule>
    <ruleTitle><![CDATA[comma, &&, || 연산자는 연산자 오버로딩 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 comma와 논리 결합 연산자의 오버로드된 버전은 그 시퀀스 포인트와 문법의 순서가 기존 버전과 다를 수 있다. 그리고 사용하는 시점에서 이 연산자가 오버로드 되었는지 명확하지 않은 경우가 있다. 따라서 개발자는 어떤 의미로 쓰였는지 혼동할 수 있으므로 오버로딩하지 않는 것이 안전하다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 14882:2003 [1] §5.14, §5.15, §5.18]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_02_12</rule>
    <ruleTitle><![CDATA[함수 인자로 들어온 배열 타입의 식별자는 포인터로 망가지면(decay) 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 배열 타입 변수가 포인터로 망가지면, 그 범위 값을 잃는다. 만약, 디자인이 다른 길이의 배열을 요구한다면, 클래스는 배열 객체를 감싸고, 차원 수가 유지되도록 해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_03_01</rule>
    <ruleTitle><![CDATA[!, && 또는 || 연산자 각각의 피연산자는 bool 타입을 가져야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 이러한 연산자들의 피연산자 타입이 bool이 아닌 경우, 그 의미가 의도와 다를 수 있다. &, |, ~ 연산자와 &&, ||, ! 연산자는 쉽게 혼동할 수 있기 때문에 이러한 규칙이 필요하다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 14882:2003 [1] §5.14, §5.15]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_03_02</rule>
    <ruleTitle><![CDATA[unary minus 연산자는 표현식의 underlying type이 unsigned 일 때 사용하면 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 unsigned int, unsigned long, unsigned long long 타입의 expression에 unary minus 연산자를 적용하는 것은 그 결과 타입도 같은 것으로 각각 생성하며, 의미있는 연산이 아니다. Unary minus를 충분히 작은 unsigned 정수 타입의 피연산자에 적용하는 것은 integral promotion에 의해 올바른 signed 결과를 가져오지만, 이것은 좋은 예가 아니다.  
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >See also</span></span> &nbsp; <br/><br/>
섹션 6.5.0의 underlying type 참고]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_03_03</rule>
    <ruleTitle><![CDATA[unary & 연산자 오버로딩 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 Complete 타입이 유저가 선언한 연산자 &를 포함할 때, incomplete 타입의 객체 주소를 가져오는 것은 undefined behaviour를 가져온다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 14882:2003 [1] §5.3.1(4)]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_03_04</rule>
    <ruleTitle><![CDATA[sizeof 연산의 피연산자는 side effect를 포함하지 않아야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>

<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/>
 C++에서 가능한 프로그래밍 에러는 sizeof 연산을 표현식에 적용하고 그 표현식이 실행되기를 기대하는 것이다. 그러나, sizeof는 표현식의 타입만을 대상으로 계산하기 때문에 그 표현식은 실행되지 않는다. 이러한 에러를 피하기 위해서, sizeof는 side effect를 포함하는 표현식을 사용하면 안 된다. <br/>
예를 들면, 40000은 32 비트 환경에서는 signed int 이지만 16 비트 환경에서는 signed long 이다. 0x8000은 16비트 환경에서는 unsigned int 이지만 32비트 환경에서는 signed int 이다.<br/><br/>

<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/>
sizeof ( i )에서 피연산자 i가 volatile 이면 허용된다.</br></br>

<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span><br/>
ISO/IEC 14882:2003 [1] §3.2(2)]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_08_01</rule>
    <ruleTitle><![CDATA[shift 연산자의 오른쪽 피연산자가 적절한 값을 가지는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 shift 연산자의 오른쪽 피연산자는, 0과 왼쪽 피연산자의 underlying type의 bit 너비보다 1 작은 수 사이의 값을 가져야 한다.<br/><br/>
 그 값을 벗어나면 undefined behavior가 발생한다. 예를 들어, left-shift 또는 right-shift 연산자의 왼쪽 피연산자가 16-bit 정수형(integer)이라면, 0에서 15 사이의 값으로 shift 되는지 확인하는 것이 중요하다. 
<br/><br/>이 규칙을 따르는지 확인하는 다양한 방법이 있다. 가장 단순한 방법은 오른쪽 피연산자가 상수가 되는 경우이다. Unsigned integer 타입의 사용은 음수 값이 아니라는 것을 확인하고, 그러므로 최대 제한 값만을 확인하면 된다. 그렇지 않은 경우에는 양쪽 제한 값을 모두 확인해야 한다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >See also</span></span> &nbsp; <br/><br/>
섹션 6.5.0의 underlying type 참고]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_14_01</rule>
    <ruleTitle><![CDATA[&& 또는 || 연산자의 오른쪽 피연산자는 side effect를 가지면 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C++ 에서 표현식의 어떤 부분이 실행되지 않는 경우가 있다. 만약 이러한 하위 표현식이 side effect를 가진다면, 이들은 다른 하위 표현식의 값에 의존되어 실행이 될 수도 되지 않을 수도 있다. 이러한 문제를 일으키는 연산자는 && 와 || 이다. 여기서 오른쪽 피연산자의 실행은 왼쪽 피연산자의 값에 따라 달라진다. 논리 연산자 중 하나에서 오른쪽 피연산자의 조건적 실행은 개발자가 side effect가 발생하는 표현식을 사용한다면 쉽게 문제를 일으킨다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 5–2–11<br/>ISO/IEC 14882:2003 [1] §3.2(2), §5.14, §5.15]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_17_01</rule>
    <ruleTitle><![CDATA[이진 연산과 그 할당 연산은 의미가 동일해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 연산자들이 오버로드 되었을 때, 해당 연산자의 결과는 개발자의 예상대로 나와야 한다. 예를 들어, + 연산자를 사용해서 얻은 값과 += 연산자를 사용해서 얻은 값은 같아야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_18_01</rule>
    <ruleTitle><![CDATA[comma 연산자 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 comma 연산자의 사용은 일반적으로 가독성을 해친다. 같은 동작을 하는 다른 방법이 존재하기 때문에 사용하지 않는 것이 좋다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_05_19_01</rule>
    <ruleTitle><![CDATA[Unsigned integer 타입 상수 식의 평가가 wrap-around를 일으키면 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 Unsigned integer 표현식은 overflow가 생기지 않기 때문에, (대신에 모듈 방식으로 wrap around가 발생한다.) 오버플로우를 발생시키는 어떤 unsigned integer 상수 식도 컴파일러가 발견할 수 없다. 따라서 unsigned integer 상수 식에서 일어나는 wrapping around의 경우 프로그래밍 에러를 나타내는 경향이 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_06_02_01</rule>
    <ruleTitle><![CDATA[하위 표현식에서 할당 연산자 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 하위 표현식에서 할당 연산자를 사용하면 전체 표현식에 side effect를 유발할 수 있다. 잠재적으로 개발자가 기대하지 않은 결과값이 나올 수 있다. 또한 = 와 == 를 혼동하지 않도록 한다. <br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_06_02_02</rule>
    <ruleTitle><![CDATA[실수 표현식에 동등 비교 연산자 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 실수형 타입끼리 비교 연산을 하면 기대한 것과 다른 결과가 발생할 수 있다. 또한 이런 비교는 결과를 예측할 수도 없으며 구현에 따라 달라진다. 미리 정의한 실수 타입에 맞는 비교 연산을 라이브러리로 구현하여 사용하는 것이 좋다.  라이브러리는 반드시 실수 타입의 최소 오차(std::numeric_limits<float>::epsilon())와 비교할 숫자의 범위를 고려해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_06_02_03</rule>
    <ruleTitle><![CDATA[전처리 전에, null statement는 다른 statement와 혼용 금지. null 문장 뒤에 주석이 올 때는 문장 바로 다음에 공백이 있어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 일반적으로 null 문장을 의도하여 사용하지 않아야 하지만, 사용할 경우에는 한줄씩 나타내야 한다.  null 문장 이전에 들여쓰기에 사용한 공백 문자가 있을 수 있다. null 문장 뒤에 주석이 따를 경우에는 공백문자가 있어야 한다.  코드를 보는 사람에게 표시해 주기 위해서 null 문장 다음에 공백 문자가 있고 주석이 있어야 한다. 이 규칙을 따르면 정적 분석 도구에서 null 문장과 다른 문자열이 같은 줄에 있을 때 프로그래밍의 오류를 경고해 줄 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_06_03_01</rule>
    <ruleTitle><![CDATA[switch, while, do while 이나 for 문장의 body는 복합문이어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 switch, while, do while이나 for 문장의 body가 복합문(compound statement)이 아니면, 개발자가 한 문장인 body를 여러 문장인 body로 바꾸려 할 때 괄호를 사용하지 않아 오류가 발생할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_06_04_01</rule>
    <ruleTitle><![CDATA[ if, else if, else 문장의 body는 복합문이어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 if, else if, else 문장의 body가 복합문(compound statement)이 아니면, 개발자가 한 문장인 body를 여러 문장인 body로 바꾸려 할 때 괄호를 사용하지 않아 오류가 발생할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_06_04_02</rule>
    <ruleTitle><![CDATA[모든 if, else if 문장은 else 절로 끝나야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 if 문에 하나 이상의 else if 문이 존재하면 반드시 else 절로 끝나야 한다. simple if 문의 경우는 else 문이 없어도 된다. 방어적으로 프로그래밍하려면 마지막 else 절에서는 적절한 동작이 있거나 동작이 없으면 알맞은 주석이 있어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_06_04_03</rule>
    <ruleTitle><![CDATA[switch 문의 형태는 잘 쓰여야(well-formed) 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C++ 표준의 switch 구문은 제약이 적어 복잡한 코드를 만들고 문장 사이의 구조가 깨질 수 있다.  MISRA C++ 에서 정의한 switch 구문 형식을 따르면 문장이 간단하고 일관된 구조를 가진다.. switch문에서 goto 문을 사용할 때는 goto문과 label이 같은 scope에 있어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_06_04_04</rule>
    <ruleTitle><![CDATA[switch-label은 switch 문장의 body의 block scope에 있어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 switch-label이 switch 문장 body의 아무 곳에나 있으면 코드의 구조가 깨질 수 있다. case-label 이나 default-label의 scope가 switch 문장의 body 이면 방지할 수 있다. 모든 case-clauses와 default-clause는 같은 scope이어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_06_04_05</rule>
    <ruleTitle><![CDATA[비어 있지 않은 switch-clause는 throw나 break로 종료되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 개발자가 switch-clause의 끝에 break를 넣지 않으면 다음 switch-clause를 진행한다(fall through). 가끔 이것이 오류인 경우도 있다. 이런 행동이 오류인 경우에는 모든 switch-clause 는 break이어야 하고 switch-clause가 복합문이면 마지막 문장은 break이어야 한다. 여러 절이 같은 문장으로 구성될 때는 빈 switch-clause를 사용하는 경우는 예외이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_06_04_06</rule>
    <ruleTitle><![CDATA[switch 문의 마지막 절은 default이어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 마지막에 default-clause 를 사용하여 방어적으로 프로그래밍해야 한다. 또한 이 절에서는 적절한 행동이 있어야 하고 없는 경우에는 주석으로 이유를 명시해야 한다.  
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
switch 문의 조건식이 enum 타입이고 모든 enum 타입을 case label에 명시했으면 default-clause는 필요하지 않다. 이 경우에도 default-clause를 쓰는 것은 방어적 프로그래밍이므로 괜찮다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_06_04_07</rule>
    <ruleTitle><![CDATA[switch문의 조건식에 boolean expression 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 boolean expression은 switch 문보다 if 문에 쓰는 것이 낫다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_06_04_08</rule>
    <ruleTitle><![CDATA[모든 switch 문에는 적어도 하나의 case-clause가 있어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
  case 절이 없는 switch 문장은 불필요한 코드다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_06_05_01</rule>
    <ruleTitle><![CDATA[for 루프의 loop-counter는 하나이고 실수형이 아니어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 loop-counter를 하나만 사용하는 for문을 사용하는 것이 아니라면, while문을 사용하는 것이 더 낫다. loop-counter는 초기화, 조건체크, 증감연산 Statement에 모두 사용된 변수를 의미한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_06_05_02</rule>
    <ruleTitle><![CDATA[loop-counter가 증감연산자로 값이 변하지 않을 때 조건식 안의 loop-counter는 ==, != 의 피연산자로 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 loop-counter는 증감 연산자로 값이 변하지 않을 때 조건식에서 ==, != 연산자를 사용하면 안 된다. 루프가 끝나지 않거나 개발자가 기대하지 않은 결과가 발생할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_06_05_03</rule>
    <ruleTitle><![CDATA[loop-counter를 condition이나 statement에서 변경 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 for 루프의 expression이 아닌 곳에서 loop-counter가 변하면 좋은 형태가 아니다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_06_05_04</rule>
    <ruleTitle><![CDATA[loop-counter의 값을 잘못된 형태로 증감 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 loop-counter의 값은 --, ++ 연산자를 사용하거나 -=n, +=n 형태로만 바꿔야 한다. n은 루프에서 상수이어야 한다. 이런 형태만이 유한한 루프를 보장한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_06_05_05</rule>
    <ruleTitle><![CDATA[loop-counter가 아닌 loop-control-variable은 condition이나 expression에서 변경 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 loop-control-variable은 loop-counter나 루프 종료를 위한 flag이다. 이 값이 condition이나 expression에서 변하지 않으면 코드를 이해하기 쉽다. volatile인 loop-control-variable은 statement 밖에서 값을 바뀔 수 있다. 이런 변화는 이 규칙을 위배하지 않는다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_06_05_06</rule>
    <ruleTitle><![CDATA[bool 타입이 아니고 loop-counter가 아닌 loop-control-variable은 for의 body에서 변경 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 loop-counter가 아닌 loop-control-variable은 loop-counter나 루프 종료를 위한 flag이다.  Boolean 값을 사용해야 코드를 이해하기 쉽다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_06_06_01</rule>
    <ruleTitle><![CDATA[goto 문장이 참조하는 label은 같은 block이나 goto 문장을 포함한 block에 선언해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 goto를 분별 없이 사용한 프로그램은 이해하고 분석하기 어렵다. C++에서는 unspecified behaviour를 유발할 수 있다. 하지만 goto를 사용하지 않으면 flag를 사용해야 하는 제어 흐름이 있고 goto를 대체해서 사용한 flag가 오히려 더 명확하지 않을 수 있다. <br/><br/>그러므로 goto를 제한적으로 사용하여 개발자의 기대하는 결과를 얻을 수 있으면 허용한다. 복잡한 제어 흐름을 유발하기 때문에 내부 block으로 도약하면 안 된다 ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_06_06_02</rule>
    <ruleTitle><![CDATA[함수 body안의 label 선언은 goto보다 나중에 있어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 goto를 분별 없이 사용한 프로그램은 이해하고 분석하기 어렵다. C++에서는 unspecified behaviour를 유발할 수 있다. 하지만 goto를 아예 사용하지 않기에는 flag를 사용해야 하는 제어 흐름이 있고 goto를 대체해서 사용한 flag가 오히려 더 명확하지 않을 수 있다. 그러므로 goto를 제한적으로 사용하여 개발자의 기대하는 결과를 얻을 수 있으면 허용한다. 반복문이 잘 정의된 언어에서 반복을 위해 뒤로 도약하면 안 된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_06_06_03</rule>
    <ruleTitle><![CDATA[continue 문장은 잘 쓰여진(well-formed) for 루프에서만 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
과도한 continue 사용은 코드의 복잡도를 증가시킨다. 그러므로 continue는 잘 쓰인 for문(well-formed for statement)에서만 사용해야 한다. 
잘 쓰인 for문은 06_05_01 ~ 06_05_06까지 만족해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_06_06_04</rule>
    <ruleTitle><![CDATA[반복문은 하나의 break나 goto로만 종료해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 구조화된 프로그램을 만들려면 루프의 종료문의 수를 제한해야 한다. 두 결과가 나올 수 있는 루프나 최적화 코딩을 위해 루프에서 break나 goto 문은 하나만 허용한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_06_06_05</rule>
    <ruleTitle><![CDATA[함수는 하나의 종료 지점만 함수의 끝에 있어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 구조화된 프로그램을 만들려면 함수의 종료 지점 수를 제한해야 한다. IEC 61508[12]에서 모듈화를 위해 요구한다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
function-try-block으로 구현되어 try block와 catch 핸들러에 각 종료 지점이 여러개 있는 경우는 허용한다.
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>IEC 61508 [12] Part 3 Table B.9]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_07_01_01</rule>
    <ruleTitle><![CDATA[값이 변경되지 않는 변수는 const로 선언되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 만약 어떤 변수의 값이 수정될 필요가 없다면 const 키워드를 명시하여 수정되지 않도록 선언해야 한다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 14882:2003 [1] §7.1.5.1]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_07_01_02</rule>
    <ruleTitle><![CDATA[포인터, 참조형 파라미터는 그 객체의 값이 변경되지 않는 경우 const 타입 객체를 가리켜야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 객체의 값이 수정될 필요가 없다면 const 타입의 객체를 가리키는 포인터, 참조형 파라미터를 사용해서 함수의 인터페이스를 명확히 해야 한다. typedef 타입에 const를 사용하는 경우 아래와 같다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
파라미터 객체가 오버라이딩 된 함수에 의해 변경된 경우 적용하지 않는다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_07_02_01</rule>
    <ruleTitle><![CDATA[underlying type이 enum인 수식은 해당 enum에 속한 값들만 가져야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 underlying type이 enum인 수식이 해당 enum에 속하지 않은 값을 가지는 경우는 표준에 명시되지 않은 동작을 하게 된다. 따라서 enum 타입에 속하지 않은 값을 가지면 안 된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_07_03_01</rule>
    <ruleTitle><![CDATA[전역 namespace에는 main, namespace, extern C 선언만 있어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 namespace를 이용하여 함수, 변수 등을 관리하면 lookup하는 동안 검사해봐야 하는 엔티티의 수를 줄여 주고, 개발자가 기대한 이름을 찾는 것을 보장할 수 있도록 도와 준다. 따라서 main함수, namespace 선언들, extern C를 제외한 다른 선언은 전역에 존재하지 않아야 한다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
규칙 3-9-2를 준수하는 정의된 타입은 전역 namespace에 존재할 수 있다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_07_03_02</rule>
    <ruleTitle><![CDATA[main이란 이름을 갖는 함수는 오로지 전역에만 존재해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 main 함수는 프로그램의 시작 지점으로 사용되며 반드시 전역 namespace에 유일하게 존재해야 하는 함수이다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_07_03_03</rule>
    <ruleTitle><![CDATA[헤더 파일에는 unnamed namespace가 존재하면 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 unnamed namespace는 각 translation unit(TU)마다 unique하다. 따라서 헤더 파일에 있는 unnamed namespace에 있는 선언들은 각 TU마다 다른 엔티티들을 가리키게 된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_07_03_04</rule>
    <ruleTitle><![CDATA[using-directive를 사용하면 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 using-directive를 사용하면 name lookup시 살펴봐야 할 scope이 많아지게 되고 이는 잦은 오류를 발생시킬 수 있다. using-declaration을 사용하거나 fully qualified name을 사용하는 것이 더 안전하다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 14882:2003 [1] §7.3.4]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_07_03_05</rule>
    <ruleTitle><![CDATA[using-declaration 이후에 동일한 식별자에 대한 선언이 있으면 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 using-declaration은 순서상 이후에 선언되는 동일한 식별자를 갖는 선언까지 introduce하지는 않는다. 이는 개발자의 의도와 다를 수 있다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 14882:2003 [1] §7.3.3]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_07_03_06</rule>
    <ruleTitle><![CDATA[using-directive, using-declaration은 헤더 파일에서 사용하면 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 using-directive, using-declaration을 헤더 파일에서 사용하면 헤더 파일의 include 순서에 따라 동작이 달라질 수 있다. 따라서 헤더 파일에서는 사용하면 안 된다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 14882:2003 [1] §7.3.3, §7.3.4]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_07_04_01</rule>
    <ruleTitle><![CDATA[모든 어셈블러 사용은 문서화되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/> 어셈블리어 코드는 구현체마다 동작이 다르므로 사용하지 않아야 한다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_07_04_02</rule>
    <ruleTitle><![CDATA[어셈블러 명령어는 asm 선언을 통해서만 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 언어 표준에 있는 asm 선언을 통하여 어셈블러 명령어를 사용해야 한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_07_04_03</rule>
    <ruleTitle><![CDATA[어셈블리 코드는 캡슐화되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 어셈블리 코드를 캡슐화하면 프로그램의 이식성을 증대시킬 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_07_05_01</rule>
    <ruleTitle><![CDATA[함수는 함수 내 정의된 변수에 대한 참조나 포인터를 반환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 이러한 자동 변수들은 함수 호출이 끝날 때 소멸되게 된다. 이 변수들에 대한 포인터나 참조를 반환하면 해당 변수들이 소멸된 이후에 사용될 수 있으므로 오류가 발생할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_07_05_02</rule>
    <ruleTitle><![CDATA[자동 변수의 주소는 그 변수가 소멸된 이후에도 지속되는 다른 변수에 할당 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 자동 변수의 주소가 더 큰 scope의 자동 변수, 또는 static 변수에 할당되거나 함수에서 반환되면 그 주소를 갖고 있는 객체는 원본 객체가 소멸된 시점 이후에 사용될 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_07_05_03</rule>
    <ruleTitle><![CDATA[함수는 입력으로 전달된 const 참조나 참조 타입 변수를 포인터나 참조 타입으로 반환 금지.]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 참조형 파라미터가 임시 객체를 가리킬지 아니면 파라미터로 전달받은 그 객체를 가리킬지에 대한 동작은 구현체마다 다르다. 만약 어떠한 구현체에서 이 참조형 파라미터가 전달받은 파라미터의 임시 객체를 가리키고 있는 경우, 이를 반환할 때 해당 객체가 소멸하여 잘못된 값을 전달하게 될 것이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_07_05_04</rule>
    <ruleTitle><![CDATA[함수의 직, 간접적 재귀 호출은 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 제한되지 않은 재귀 호출은 stack overflow를 발생시킬 수 있다. 모든 재귀 호출은 반복 알고리즘으로 구현할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_08_00_01</rule>
    <ruleTitle><![CDATA[하나의 declaration에 declarator 하나만 쓰는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 하나의 declaration에 declarator가 여러 개 있으면 그 식별자의 타입이 개발자의 생각과 다를 수 있다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 14882:2003 [1] §9.2]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_08_03_01</rule>
    <ruleTitle><![CDATA[Overriding 함수가 Overridden 함수와 동일한 default argument를 사용하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 Default argument는 객체의 정적 타입에 의해 결정된다. 만일 default argument 가 overriding 함수에서 다른 경우, base 객체로 호출할 때와 derived 객체로 호출할 때 결과가 달라진다. 이는 개발자의 생각과 다를 수 있다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 14882:2003 [1] §8.3.6(10)]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_08_04_01</rule>
    <ruleTitle><![CDATA[가변인자를 갖는 함수 정의 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 가변인자를 사용하면 컴파일러 타입 검사를 건너 뛴다. 게다가 non-POD 타입 인자를 전달하면 undefined behaviour가 발생한다. 이 규칙은 "정의"("선언"이 아님) 라고 명시하고 있다. 따라서 라이브러리 함수들은 규칙의 대상에서 제외한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_08_04_02</rule>
    <ruleTitle><![CDATA[함수 재 선언 시 이전 선언과 동일한 식별자를 갖는 파라미터를 써야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 파라미터 이름은 그 함수 정의에서 파라미터의 목적을 설명하는데 도움을 준다. 만일 함수 파라미터의 재 선언 시 다른 이름으로 선언되면 개발자가 혼란스러워 할 수 있다. 이 규칙은 overriding set(virtual 함수와 모든 overriding 함수들)에 대해서도 적용된다.
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
선언 또는 재 선언 시 unnamed 파라미터를 포함한 경우 위배가 아니다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_08_04_03</rule>
    <ruleTitle><![CDATA[Non-void 함수의 모든 exit path에는 명시적인 반환 수식이 있어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 Non-void 함수에 반환 수식이 없으면 undefined behaviour이다. (컴파일러는 대부분 오류를 내지 않는다.) 보통의 경우 path 상에 마지막으로 실행된 문장의 계산 결과가 반환된다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
이 규칙은 예외 핸들링으로 끝나는 경우( 즉, throw 문 )에는 적용하지 않는다.
]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_08_04_04</rule>
    <ruleTitle><![CDATA[함수 이름은 호출이나 & 다음에 쓸 때만 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 함수 이름(식별자)는 함수 포인터로 묵시적 변환 가능하다. 특정 상황에서 문제가 발생하지 않으면 개발자의 생각과 반대일 수 있다. 예를 들어 만일 개발자가 if (f) 라고 썼을 때, 이게 함수 f의 주소가 NULL인지 검사하기 위한 코드인지, 아니면 f()를 호출하려고 했는데 실수로 괄호가 빠진 것인지가 명확하지 않다. & 연산자를 쓰면 이렇게 모호한 경우가 해결된다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
함수를 참조로 전달하거나 참조 객체에 할당하는 것은 위배가 아니다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_08_05_01</rule>
    <ruleTitle><![CDATA[모든 변수는 사용되기 전에 값이 할당되어 있어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 이 규칙의 의도는 모든 변수가 읽히기 전에 쓰여야 한다는 것이다. 반드시 선언 시 초기화를 해야 하는 건 아니다.
<br/><br/> ISO/IEC 14882:2003[1]에 의하면, static storage duration을 갖는 변수들은 명시적 초기화가 없으면 자동으로 0으로 초기화된다고 한다. 그런데 현실적으로는 많은 임베디드 환경들이 이렇게 구현되어있지 않다. static storage duration은 static storage 클래스 명시자로 선언된 혹은 external linkage를 갖는 모든 변수들의 속성이다. automatic storage duration을 갖는 변수들은 보통 자동으로 초기화되지 않는다. <br/><br/>각 클래스 생성자는 모든 non-static 멤버를 초기화해야 한다. <br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_08_05_02</rule>
    <ruleTitle><![CDATA[배열과 구조체의 non-zero 초기화에는 구조에 맞게 {}를 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 ISO/IEC 14882:2003[1]에서는 배열, 구조체, union 타입의 초기화 리스트에 {} 한 쌍을 사용하라고 기술되어 있다(그렇게 안 쓰는 경우엔 undefined behaviour 가 발생한다.). 이 규칙은 중첩된 구조인 경우 추가로 {} 를 더 쓰라고 한다. 이렇게 하면 개발자가 복잡한 데이터 타입에 대해 각 element가 어떤 순서로 초기화되는지 명확하게 알 수 있다.
<br/><br/> 배열이나 구조체의 zero 초기화는 top-level에만 적용한다(표준에서는 허용함). 배열이나 구조체의 non-zero 초기화는 각 element에 대한 명시적인 초기화가 되어야 한다. 배열이나 구조체의 모든 element가 첫 번째 element만 명시하면 나머지는 0 또는 NULL로 초기화 된다. 만일 이 방법을 선택하면, 첫 번째 element는 0 또는 NULL이어야 하고 중첩된 {}는 필요 없다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_08_05_03</rule>
    <ruleTitle><![CDATA[enumerator list 에서 초기화가 있다면, 첫 번째 멤버만 초기화 하거나 혹은 모든 멤버를 다 해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 enumerator list 가 명시적 멤버 초기화가 없으면 C++은 0부터 연속적인 정수 값을 할당한다. 첫 번째 멤버에 명시적 초기화를 하면 그 값부터 시작해서 할당하게 된다. 이렇게 하려면, 첫 번째 멤버의 초기화 값이 충분히 작아야 한다.
<br/><br/> 모든 멤버에 대한 명시적 초기화를 사용하면 개발자는 직접 부여한 값이 의도적으로 중복되었는지 쉽게 판단할 수 있다. 이런 경우 개발자는 모든 값을 적절하게 명시적으로 초기화를 수행하였는지 확인해야 한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_09_03_01</rule>
    <ruleTitle><![CDATA[const member 함수에서 클래스 데이터를 가리키는 non-const pointer나 reference 반환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 기본적으로 const member 함수는 해당 함수의 호출로 인해 객체의 상태가 변경되지 않다는 것을 보장한다. 그러나 const member 함수에서 클래스 데이터를 가리키는 non-const pointer나 reference가 반환된다면 이렇게 얻어진 클래스 내부의 상태를 프로그램의 다른 부분에서 언제든 수정할 수 있기 때문에 안전하지 않다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_09_03_02</rule>
    <ruleTitle><![CDATA[member 함수에서 클래스 데이터의 const가 아닌 핸들 반환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 member 함수들과 같은 클래스 인터페이스를 구현함으로써 객체의 상태가 어떻게 변경되는지를 명확히 조절할 수 있게 된다. 그러나 클래스 데이터에 대한 핸들을 반환하는 것은 해당 객체의 상태를 클래스 인터페이스를 통하지 않고도 변경할 수 있기 때문에 바람직하지 않다.
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
포인터 타입인데 해당 변수가 다른 리소스를 가리키고 있는 경우에는 외부에서 반환받을 수 있다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_09_03_03</rule>
    <ruleTitle><![CDATA[static 또는 const로 선언할 수 있는 member 함수들은 static 또는 const로 선언해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 static으로 선언할 수 있는 member 함수는 해당 함수를 static으로 한정하여 non-static data member에 접근하는 것을 막고 const로 선언할 수 있는 member 함수는 const로 선언하여 데이터의 값이 의도치 않게 변경되는 것을 막아야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_09_05_01</rule>
    <ruleTitle><![CDATA[union을 사용하지 않아야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 union은 경우에 따라 적절치 못한 값으로 해석될 수 있고 이는 큰 문제를 야기할 수 있다. 따라서 union을 사용하지 않아야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_09_06_01</rule>
    <ruleTitle><![CDATA[bit들의 절대적인 위치를 표현하는 bit-field가 필요할 때에는 이것의 동작 및 packing이 문서화되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 bit-field의 몇몇 부분들은 implementation-defined이다. 특히 개발자는 다음의 내용이 implementation-defined임을 알아야 한다.<br>
<br> &nbsp;&nbsp;&nbsp;&nbsp;- bit-field가 저장될 때 높은 차수의 bit가 먼저 할당이 될지, 혹은 낮은 차수의 bit가 먼저 할당이 될지의 여부
<br> &nbsp;&nbsp;&nbsp;&nbsp;- bit-field끼리 storage unit boundary에 overlap  될수 있는지의 여부
<br> &nbsp;&nbsp;&nbsp;&nbsp;- 6-bit bit-field와 4-bit bit field를 순서대로 선언하였을 때 4-bit bit-field가 새로운 byte에서 시작할지, 아니면 앞의 선언에서 남은 2bit를 채워서 사용할지의 여부
<br><br> 이것들은 대부분(짧은 길이의 데이터를 저장할 때 공간을 효율적으로 쓰기 위한 경우들) 문제가 없으나 만약 bit-field의 정확한 위치가 중요하다면(하드웨어 레지스터에 접근하는 경우) 에러를 발생시킬 수 있다.<br>
<br> structure의 element에 접근은 오직 이름으로만 해야 하며 개발자는 구조체에서 bit-field가 저장되는 방법에 대한 가정을 하면 안 된다.<br> 규칙 3-9-2는 bit-field의 길이가 명시적으로 기록되어 있지 않는 한 bit-field를 정의하는 데 적용되지 않아도 된다.<br><br>
 만약 컴파일러가 bit-field를 특정 layout에 따라서 저장할 수 있게끔 하는 옵션이 있다면 이 옵션은 필히 문서화 되어야 한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_09_06_02</rule>
    <ruleTitle><![CDATA[bit 필드들은 bool, unsigned 또는 signed int의 타입들로만 구성되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 bit 필드들은 bool, unsigned 또는 signed int의 타입들로만 구성되어야 한다. bit 필드에서 부호 여부가 명시되지 않은 int 타입은 signed int, unsigned int 중 어떠한 타입을 사용해야 할지 모호한 데다가 구현체마다 사용되는 타입이 다르기 때문이다. 마찬가지로 plain char 타입 또한 부호 여부가 명확하지 않으므로 사용치 않아야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_09_06_03</rule>
    <ruleTitle><![CDATA[bit 필드에는 enum 타입의 변수가 포함되면 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 enum 타입은 ISO/IEC 14882:2003에 부호 여부가 명시되어 있지 않다. 따라서 어떠한 enum 타입의 값을 표현하는데 몇 개의 bit가 필요한지를 결정할 수가 없기 때문에 이를 bit 필드에 사용하면 안 된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_09_06_04</rule>
    <ruleTitle><![CDATA[부호 있는 integer 타입의 이름 있는 bit 필드의 크기는 1bit 이상이어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 1bit 크기의 signed int bit 필드는 실제로는 어떠한 값도 저장할 수 없기 때문에 개발자의 의도와 다르게 구현된 코드일 것이다. anonymous(이름 없는) 필드는 그 자체를 개발자가 의도하였을 수 있기 때문에 무시한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_10_01_01</rule>
    <ruleTitle><![CDATA[클래스는 다른 클래스를 virtual로 상속받지 않아야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 클래스를 virtual로 상속받는 것은 다수의 undefined behavior를 발생시킬 수 있으며 따라서 잠재적으로 혼동을 주는 동작을 할 수 있다. 따라서 다른 클래스를 virtual로 상속하는 것은 권장되지 않는다. 

<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 5–2–2, Rule 10–1–2, Rule 12–1–2]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_10_01_02</rule>
    <ruleTitle><![CDATA[클래스는 다이아몬드 상속 관계일 때에만 다른 클래스를 virtual로 상속받아야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 클래스를 virtual로 상속받는 것은 다수의 undefined behavior를 발생시킬 수 있다. 따라서 이를 사용하지 말아야 하되 예외적으로 다이아몬드 상속 관계에서 공통된 base로 사용되는 클래스만 virtual로 상속받아 사용하는 것을 허용한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_10_01_03</rule>
    <ruleTitle><![CDATA[접근 가능한 상위 클래스가 다중 상속 계층에서 virtual, non-virtual로 함께 존재하면 안됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 만약 상위 클래스가 다중 상속 관계에서 virtual, non-virtual로 각각 존재할 때, 상속된 객체에는 해당 상위 클래스의 객체 사본이 최소한 두 개 이상 존재하게 된다. 이는 개발자의 의도와 다를 수 있다.
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_10_02_01</rule>
    <ruleTitle><![CDATA[다중 상속 계층 구조에서 접근 가능한 모든 엔티티의 이름은 유일해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 만약 이름이 모호하다면 컴파일러는 이 이름 충돌을 보고해야 하고 임의의, 그리고 예상치 못하게 resolve된 코드를 생성하지 않아야 한다. 그러나 이 모호성은 개발자에게 명확하지 않을 수 있다. 그러나 member function이 virtual이라면 base class를 명시적으로 참조함으로써 함수의 virtual 동작을 제거하여 모호성을 해결할 수 있다. 따라서 overload set을 구성하는 함수들은 검출하지 않는다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
이 규칙의 목적에 부합하기 위해, 오버로드 된 형태의 함수 식별자들은 같은 요소로 고려해야 한다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_10_03_01</rule>
    <ruleTitle><![CDATA[상속 계층을 따라 각 virtual function의 정의는 하나씩만 존재해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 이 규칙의 주 목적은 유지보수자와 리뷰어들에게 명확성을 제공하는 데 있다. 클래스 상속의 어떤 지점에서도 한 클래스의 function이 수행됨을 보장함으로써 애매함을 없앨 수 있다. 부수적으로, 클래스들이 다이아몬드 상속관계를 가지고 있다면, call by dominance에 의해 개발자의 의도와 다른 함수를 호출할 수 있기에 위험하지만 이 규칙을 통해 이러한 call by dominance를 방지한다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
소멸자는 클래스 계층 구조의 여러 멤버 내에서 virtual로 선언될 것이다.<br/>
만약 함수가 순수 함수로 선언되어있고 같은 클래스 내에 정의되어 있다면, 이 규칙에서 그 정의는 무시된다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_10_03_02</rule>
    <ruleTitle><![CDATA[virtual 함수를 상속받은 함수에 virtual 속성을 명시해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 virtual 함수를 하위 클래스가 상속받는 경우 virtual 키워드를 명시하지 않아도 결과에는 아무런 차이가 없다. 그러나, virtual 함수를 상속받을 때에는 virtual 키워드를 사용하여 해당 함수가 virtual이었는지 상위위 클래스를 확인해보아야 하는 필요성을 없애야 한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_10_03_03</rule>
    <ruleTitle><![CDATA[재선언되는 base 클래스의 함수가 pure virtual일 때만 pure virtual 함수로 재선언할 수 있음 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 어떠한 함수를 pure virtual로 다시 선언하는 것은 개발자의 의도에 부합되지 않을 수 있다.
<br/><br/>
 클래스 A에서 함수 foo가 pure function으로 선언된 후, 클래스 B에서 foo에 대한 오버라이딩(Overriding)이 이루어졌다고 하자. 이후, 클래스 B의 하위 클래스인 클래스 C에서 그 함수가 다시 pure function으로 재선언될 경우, 개발자의 의도와 부합하지 않는 결과를 초래할 수 있기 때문에 이는 허용되지 않는다.
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_11_00_01</rule>
    <ruleTitle><![CDATA[POD가 아닌 class에서의 member data는 private이어야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 멤버 함수 등의 클래스 인터페이스를 구현함으로써, 객체의 상태가 변경되는 것에 대해 더욱 명확히 조절할 수 있게 된다. 또한, 이는 해당 클래스로 하여금 클라이언트에 영향을 주지 않고 유지될 수 있게 해준다.
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_12_01_01</rule>
    <ruleTitle><![CDATA[객체의 동적 타입은 생성자나 소멸자 안에서 사용되지 않아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 어떤 객체의 생성이나 소멸 중에 해당 객체의 최종 타입이 완전히 생성된 객체의 것과 다를 수 있다. 이 결과 객체의 동적 타입을 생성자 또는 소멸자에서 사용하는 것이 개발자의 의도와 다르게 될 수 있다.<br/>
객체의 동적 타입은 다음의 구조에서 사용된다 :<br/><br/>
 &nbsp;&nbsp;&nbsp;&nbsp;- 가상함수를 가진 클래스에서의 typeid <br/>
 &nbsp;&nbsp;&nbsp;&nbsp;- dynamic cast<br/>
 &nbsp;&nbsp;&nbsp;&nbsp;- 가상 함수의 가상 호출<br/><br/>
또한 이 규칙은 생성자 또는 소멸내 내에서 순수 가상함수가 호출되는 경우도 금지한다. 이 호출 또한 정의되지 않은 행동이다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_12_01_02</rule>
    <ruleTitle><![CDATA[클래스의 모든 생성자는 명시적으로 바로 위 상위 클래스의 생성자를 호출해야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 이 규칙은 어떠한 생성자가 사용되어야 하는지, 그리고 어떠한 매개 변수가 사용되어야 하는지에 대한 혼동을 줄여준다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_12_01_03</rule>
    <ruleTitle><![CDATA[하나의 기본 타입의 매개변수를 갖는 호출 가능한 생성자들은 explicit으로 선언되어야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 explicit 키워드는 생성자가 기본 타입을 클래스 타입으로 암시적으로 변경하는 것을 막는다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_12_08_01</rule>
    <ruleTitle><![CDATA[복사 생성자는 기본 클래스들과 그 클래스들의 non-static 멤버들만 초기화해야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 복사 생성자가 어떤 객체의 사본을 만드는 것 외에 다른 동작을 하더라도 컴파일러가 복사 생성자의 호출이 필요 없다고 판단될 때 컴파일러는 해당 호출을 무시할 수 있다.  이를 copy elision이라 한다. 이러한 값의 변경들이 애매하기 때문에 복사 생성자는 필히 프로그램의 상태를 변경하지 않도록 해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_12_08_02</rule>
    <ruleTitle><![CDATA[추상 클래스에서 복사 대입 연산자는 protected 또는 private으로 선언되어야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 추상 클래스는 상속에서 인터페이스 부분을 표현한다. 이런 상속 관계에서 최상위 복사 생성자를 호출하게 된다면 그 하위 클래스들에서 구현해 놓은 구현체들은 무시한 채 기본 클래스의 객체만 복사되게 된다. 

※ 컴파일러에 의해 자동적으로 생성되는 추상 클래스의 디폴트 복사 대입 연산자는 public으로 선언된다. 따라서, 명시적으로 접근 권한을 제한하기 위해 private이나 protected로 변경해야 한다.
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_14_05_01</rule>
    <ruleTitle><![CDATA[non-member 제네릭 함수는 associated namespace 가 아닌 namespace 에서 선언되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 Argument-dependent lookup (ADL) 은 함수 호출을 처리할 때, 함수를 찾기 위한 찾기-범위(search-scope) 이외에도 associated namespaces 를 추가로 포함한다. 때문에 이 추가 namespace 가 오버로드 식별(overload resolution) 결과에 영향을 줄 수 있다. 이것이 개발자의 의도와는 다를 수 있다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_14_05_02</rule>
    <ruleTitle><![CDATA[템플릿으로 작성된 생성자가 하나의 제네릭 파라미터를 갖는 경우, 복사 생성자가 명시적으로 선언되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 일반적으로 복사 생성자가 있는 경우, 컴파일러에 의해 자동으로 복사 생성자가 생성되지 않는다.
<br/><br/>
 개발자가 복사 생성자를 정의하지 않았을 경우, 컴파일러는 자동으로 생성자를 만드는데 이를 디폴트 복사 생성자라고 한다. 이러한 경우 얕은 복사(shallow copy) 방식이 사용되기 때문에 한 메모리 공간을 2번 이상 접근할 수 있어 문제가 발생할 가능성이 존재한다. 특히, 동적 할당(dynamic allocation)을 사용했을 경우 이러한 문제를 피하기 위해 깊은 복사(deep copy)를 수반하는 복사 생성자를 개발자가 구현하여야 한다.
<br/><br/>
 그러나, 템플릿 생성자의 경우에는 여전히 복사 생성자가 자동으로 생성되기 때문에 개발자의 의도와는 다른 결과가 발생하게 된다. 따라서 템플릿으로 작성된 생성자가 하나의 제네릭 파라미터를 갖는 경우, 복사 생성자가 명시적으로 선언되어야 한다.
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_14_05_03</rule>
    <ruleTitle><![CDATA[템플릿으로 작성된 복사 대입 연산자가 하나의 제네릭 파라미터를 갖는 경우, 복사 대입 연산자가 명시적으로 선언되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 일반적으로 복사 대입 연산자가 있는 경우, 컴파일러에 의해 자동으로 복사 대입 연산자가 생성되지 않는다. 그러나, 템플릿으로 생성된 복사 대입 연산자의 경우에는 여전히 자동으로 생성되기 때문에 개발자의 의도와는 다른 결과가 발생하게 된다. 따라서 템플릿으로 작성된 복사 대입 연산자가 하나의 제네릭 파라미터를 갖는 경우, 복사 대입 연산자가 명시적으로 선언되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_14_06_01</rule>
    <ruleTitle><![CDATA[클래스 내에서 식별자 사용 형식 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 클래스 템플릿이 다른 클래스를 상속받는 경우, 상위 클래스에 있는 모든 식별자는 qualified-id 또는 this-> 를 이용해서 불러야 한다. Qualified-id나 this-> 를 이용하는 것이 개발자의 의도에 대한 일관성 있는 엔티티 참조를 보장한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_14_06_02</rule>
    <ruleTitle><![CDATA[Overload resolution이 식별하는 함수 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 Argument-dependent lookup (ADL) 은 함수 호출을 처리할 때, 함수를 찾기 위한 찾기-범위(search-scope) 이외에도 associated 네임스페이스를 추가로 포함한다. 때문에 이 추가 네임스페이스가 overload resolution 결과에 영향을 줄 수 있다. 특히, 함수 템플릿인 경우 ADL 은 함수 템플릿의 instantiation 이 일어나는 시점에 작동하게 된다. 때문에, 템플릿 이후에 선언된 함수가 호출될 수 있다. 이것을 피하려면, 호출하려는 함수를 qualified name 으로 호출하거나 함수 이름을 괄호로 묶어서 호출해야 한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_14_07_01</rule>
    <ruleTitle><![CDATA[모든 템플릿과 관련된 선언들은 최소 한번은 instantiation 이 되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 호출되지 않은 함수와 마찬가지로, un-instantiated 클래스나 함수들은 잠재적으로 필요 없는 코드들이다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_14_07_02</rule>
    <ruleTitle><![CDATA[어떠한 템플릿 특수화(specialization)가 일어난 후에도 ill-formed 프로그램 작성 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 묵시적 템플릿 특수화는 템플릿의 모든 멤버를 instantiate 하지 않는다. 반면에 주어진 템플릿-인자(template argument)의 결과가 사용되는지 명확하지 않을 때에도 멤버에 대한 instantiation 은 ill-formed 를 일으킬 수 있다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_14_07_03</rule>
    <ruleTitle><![CDATA[모든 부분 특수화와 명시적 특수화는 템플릿 선언과 같은 파일에 있어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 컴파일러에 의해 생성된 묵시적 instantiation 이 프로그램의 다른 부분에서 부분적 또는 명시적으로 특수화되면 undefined behavior 이다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_14_08_01</rule>
    <ruleTitle><![CDATA[오버로드된 함수 템플릿의 명시적 특수화 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 명시적 특수화는 오버로드된 함수 식별(overload resolution) 이후에 고려되기 때문에 개발자의 의도와는 다른 결과를 초래한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_14_08_02</rule>
    <ruleTitle><![CDATA[호출 가능한(viable) 함수 집합, 즉 최종 호출 함수를 선택하기 위한 집합에는 함수 템플릿 특수화가 포함되어 있지 않거나, 함수 템플릿 특수화로만 구성되어 있어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 일반 함수와 특수화된 템플릿 함수의 시그니처가 동일한 경우, 일반 함수의 우선순위가 더 높다. 이것은 개발자의 의도와는 다를 수 있다.
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Exception</span></span><br/><br/>
이 규칙은 복사 생성자 또는 복사 할당 연산자에는 적용하지 않는다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_15_00_01</rule>
    <ruleTitle><![CDATA[예외는 에러 핸들링을 위해서만 사용되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 (문서화) 예외는 에러핸들링으로만 사용해야 한다. 예외는 호출 트리 상의 제어를 이동시키므로 코드를 더욱 읽기 힘들게 만든다. 따라서, 예상치 못한 상황에서만 예외를 사용하고, 제대로 동작하는 프로그램에서는 나타나지 말아야 한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_15_00_02</rule>
    <ruleTitle><![CDATA[예외 오브젝트는 포인터 타입이면 안됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 동적으로 할당된 예외 오브젝트와 그것을 가리키는 포인터가 전달되는 경우, 그것을 처리하는 책임이 불확실해 진다. 값이나 레퍼런스인 경우에는 이러한 모호한 처리가 아예 존재하지 않으므로 훨씬 안전하다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_15_00_03</rule>
    <ruleTitle><![CDATA[goto 나 switch 문장을 이용해 제어를 try 나 catch 내로 이동하면 안됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 goto 나 switch 문장을 이용해 제어를 try 나 catch 로 이동하면 문법오류이다. 하지만, 모든 컴파일러가 이것을 에러로 처리하진 않는다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_15_01_01</rule>
    <ruleTitle><![CDATA[throws 문장의 표현식 자체가 예외를 던지면 안됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 예외 오브젝트를 생성하는 중에 예외를 던지거나, 예외 오브젝트의 초기화하는 표현식을 계산하는 중에 예외가 던져지면, 원래의 예외 오브젝트보다 여기에서 던져진 예외가 우선적으로 전파된다. 이로 인해 개발자의 의도와는 다른 예외가 전파될 수 있다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_15_01_02</rule>
    <ruleTitle><![CDATA[명시적으로 NULL 을 던지면 안됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 throw(NULL) 또는 throw(0) 은 포인터 형태로 던져지지 않고 int 핸들러로만 잡을 수 있다. 때문에, 개발자로 하여금 혼란을 야기시키며 포인터 타입의 예외만 핸들링하는 프로그램에서는 특히 더 헷갈리게 된다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_15_01_03</rule>
    <ruleTitle><![CDATA[빈 throw(throw;) 는 catch 핸들러에서만 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 빈 throw 는 예외 오브젝트로 표현된 임시 오브젝트에 대해 예외를 다시 던질 때 사용되며, 두 개 이상의 핸들러에 예외를 전파할 수 있게 한다. 그러나 C++ 언어의 구문상 throw; 를 catch 핸들러 외에 사용하는 것을 막을 방법이 없다. 이 경우 컴파일러마다 다른 결과가 나타난다(implementation-defined). 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_15_03_01</rule>
    <ruleTitle><![CDATA[예외는 start-up(main) 다음 위치와 프로그램이 끝 바로 전에만 일으켜야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 start-up 또는 종료 시에 예외를 던지는 것은 컴파일러마다 다른 결과를 나타낸다.(implementation-defined) main이 시작되기 전에 static 오브젝트를 초기화하거나, main이 반환된 후에 static 오브젝트가 소멸되는 것이 문제가 된다. 표준에도 언급되어 있지만, 그렇다고 main을 function-try-block 으로 만들어도 이 문제는 해결되지 않으며, catch 할 수 있는 방법이 없다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 15–3–3, Rule 15–3–4, Rule 15–5–1, Rule 15–5–3]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_15_03_02</rule>
    <ruleTitle><![CDATA[핸들링되지 않은 예외들을 처리하는 예외핸들러가 최소한 하나는 있어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
  프로그램이 핸들링되지 않은 예외를 던지며 종료되는 경우, 컴파일러마다 다른 결과를 나타낸다(implementation-defined). 특히, 스택이 종료직전에 풀려서 자동 생성된 변수들의 소멸자가 호출되지 않는 상황이 생길 수 있다. 이런 상황을 대비하기 위해 최후의 방어(last-ditch catch-all) 수단을 구축해야 한다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 15–3–4, Rule 15–5–3]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_15_03_03</rule>
    <ruleTitle><![CDATA[생성자나 소멸자를 function-try-block 으로 구현하는 경우, 핸들러에서 이 클래스나 상위 클래스의 비정적(non-static) 멤버를 참조하면 안됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
   프로그램이 핸들링되지 않은 예외를 던지며 종료되는 경우, 컴파일러마다 다른 결과를 나타낸다(implementation-defined). 특히, 스택이 종료직전에 풀려서 자동 생성된 변수들의 소멸자가 호출되지 않는 상황이 생길 수 있다. 이런 상황을 대비하기 위해 최후의 방어(last-ditch catch-all) 수단을 구축해야 한다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 15–3–1, Rule 15–5–1]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_15_03_04</rule>
    <ruleTitle><![CDATA[코드 내에서 명시적으로 예외를 발생시키는 경우, 이 함수의 호출 경로 상에 호환되는 타입의 핸들러가 있어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 처리되지 않은 예외가 있는 상태로 프로그램이 종료되면, 컴파일러마다 다른 결과를 나타낸다(implementation-defined). 특히, 스택이 종료직전에 풀려서 자동 생성된 변수들의 소멸자가 호출되지 않는 상황이 생길 수 있다. 상속관계에 있는 예외가 던져지는 경우, 상위 클래스나 호환되는 다른 타입으로 핸들링할 수 있다. 이 규칙의 목적은 예상되는 모든 예외들을 모두 핸들링해야 한다는 것이다. 또한 예상하지 못한 예외는 MISRA_CPP_15_03_02 규칙을 적용하면 핸들링 할 수 있다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 15–3–2, Rule 15–5–3]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_15_03_05</rule>
    <ruleTitle><![CDATA[클래스 타입의 예외는 항상 레퍼런스 방식으로 핸들링 해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 만약, 클래스 타입의 예외 오브젝트를 값으로 핸들링하게 되면, 잘림(slicing)이 발생한다. 만약, 상속관계에 있는 하위(derived) 타입의 예외가 발생하고, 핸들링은 상위(base) 타입으로 하게 되면, 상위타입의 함수(virtual 포함) 만 호출할 수 있고, 추가적인 멤버 데이터는 잘리기 때문에 사용할 수 없다. 이 경우 예외를 레퍼런스로 핸들링하면, 잘림현상은 나타나지 않는다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_15_03_06</rule>
    <ruleTitle><![CDATA[상속관계에 있는 클래스에 대한 try-catch 문장이나 function-try-block 에서 핸들링할 때는 가장 하위 타입부터 상위타입 순서로 핸들러를 배치해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 핸들러에 상위 타입이 먼저 배치되는 경우, 타입 계층구조상에 있는 다른 하위 타입들은 상위타입으로 up-casting 이 될 수 있으므로 이 후의 하위 타입에 대한 핸들러는 도달 불가능한 핸들러가 된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_15_03_07</rule>
    <ruleTitle><![CDATA[try-catch 문장이나 function-try-block 에서 다중의 예외를 핸들링할 때는 catch-all 핸들러는 가장 마지막에 나타나야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 catch-all 핸들러는 예외의 계층구조와 타입에 상관없이 모든 예외를 핸들링할 수 있기 때문에, 순서에 따라 이후의 핸들러가 도달 불가능한 코드가 될 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_15_04_01</rule>
    <ruleTitle><![CDATA[함수의 선언이 예외 기술절(exception-specification)을 갖는 경우에, 동일한 함수 선언은 동일한 예외 기술절을 가져야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 소스코드간의 다른 예외 기술절을 갖는 함수는 함수 호출 시 어떠한 동작이 발생될지 예측할 수 없다(undefined behavior). 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_15_05_01</rule>
    <ruleTitle><![CDATA[클래스 소멸자는 예외를 발생하며 끝나면 안됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 프로그램이 핸들링되지 않은 예외를 던지며 종료되는 경우, 컴파일러 마다 다른 결과를 나타낸다.(implementation-defined) 특히, 스택이 종료직전에 풀려 자동 생성된 변수들의 소멸자가 호출되지 않는 상황이 생길 수 있다. 소멸자안에서 예외가 발생되고 역시 그 안에서 핸들링할 수 있는 경우는 허용된다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 15–3–1, Rule 15–3–3, Rule 15–5–3]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_15_05_02</rule>
    <ruleTitle><![CDATA[함수의 선언이 예외 기술절(exception-specification) 을 포함하면, 해당 함수는 이 예외 기술절에 언급된 타입의 예외만 발생시켜야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
  예외 기술절을 가진 함수가 해당 기술절에 포함되지 않은 예외를 발생시킬 경우, unexpected( ) 함수가 호출된다. 이 함수는 프로그램 내에서 특정한 행동을 하도록 오버라이드되어 있을 수도 있지만, 기본적으로는 std::bad_exception을 발생시킨다. 만약 예외 기술절에 std::bad_exception이 없을 경우, terminate( )가 호출된다. 이는 프로그램이 implementation-defined한 종료를 하게 만든다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_15_05_03</rule>
    <ruleTitle><![CDATA[terminate() 함수는 묵시적으로 호출되면 안됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 terminate() 함수가 호출되기 전에 스택이 풀리지 않으면, 자동 변수들의 메모리 소멸이 일어나지 않은 채로 종료된다. 
<br/><br/>
 ※ 자동 변수(automatic variable): 프로그램 흐름이 변수의 영역(scope)에 들어가고 나올 때 자동으로 할당, 해제되는 지역 변수
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 15–3–1, Rule 15–3–2, Rule 15–3–4, Rule 15–5–1. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_16_00_01</rule>
    <ruleTitle><![CDATA[파일 내에서 #include 앞에는 다른 전처리 지시자 또는 주석만 허용 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 코드 가독성을 위해서 모든 #include 지시자는 파일의 첫 부분에 그룹화 되어야 한다. #include 앞에 위치할 수 있는 코드는 다른 전처리 지시자 또는 주석뿐이다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_16_00_02</rule>
    <ruleTitle><![CDATA[매크로는 전역 네임스페이스에 #define 되거나 #undef 되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 #define 또는 #undef 지시자가 소스파일 어디에 위치해도 에러가 발생하지는 않지만, 전역 네임스페이스가 아닌 곳에 위치하는 것은 보기와 달리 그들의 범위를 제한하지 않기 때문에 가독성을 해친다. 이는 개발자의 예상과 다를 수 있다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 16-0-3]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_16_00_03</rule>
    <ruleTitle><![CDATA[#undef는 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 #undef는 일반적인 상황에서 필요하지 않다. #undef는 해당 매크로가 코드에서 사용되었을 때, 매크로가 존재하는지 또는 그 의미가 무엇인지 혼란을 가져올 수 있다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_16_00_04</rule>
    <ruleTitle><![CDATA[함수형 매크로 정의 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 매크로가 함수보다 빠르다는 이점이 있지만, 함수가 더욱 안전하고 튼튼한(robust) 메커니즘을 제공한다. 왜냐하면 함수는 파라미터의 타입을 검사하기 때문이다. 함수형 매크로의 문제는 파라미터를 잠재적으로 여러 번 evaluating 하는 것이다.  
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_16_00_05</rule>
    <ruleTitle><![CDATA[함수 매크로의 인자는 전처리 지시자처럼 보이는 토큰을 포함하면 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 어떤 인자라도 전처리 지시자처럼 사용한다면, 매크로로 대체되었을 때의 동작은 예상할 수 없다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_16_00_06</rule>
    <ruleTitle><![CDATA[함수형 매크로의 정의에서, 인자의 각 인스턴스는 괄호로 둘러싸여야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 괄호가 사용되지 않으면, 프로세서가 매크로를 코드로 대체했을 때, 연산자 우선순위 때문에 개발자가 예상한대로 동작하지 않을 수 있다. 따라서 함수 매크로의 정의 내에서 인자는 괄호로 둘러싸여야 한다. (단, # 또는 ##의 피연산자는 예외) ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_16_00_07</rule>
    <ruleTitle><![CDATA[정의되지 않은 매크로 식별자는 #if 또는 #elif 전처리 지시자 내에서 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 전처리 지시자 내에서 식별자를 사용하려고 했을 때, 그 식별자가 정의되지 않았다면 전처리자는 그 값을 0으로 가정한다. 단, #ifdef, #ifndef 그리고 #if defined는 매크로의 존재를 확인하기 위해 제공되므로 이러한 경우에 사용하는 것은 허용한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_16_00_08</rule>
    <ruleTitle><![CDATA[# 토큰이 코드 라인의 첫 번째 토큰이라면, 곧 전처리 토큰이 따라와야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 소스코드의 어떤 부분이 전처리 지시자에 의해 제외된다면, 해당 문장들은 #else, #elif 또는 #endif를 만날 때까지 무시된다(문맥에 따라 다름). 만약 이렇게 제외된 지시자 중 하나가 잘못된 형식을 갖는다면, 컴파일러에 의한 warning도 없이 무시된다. 이 규칙이 요구하는 것은 비록 제외된 코드의 블록 내에 존재하더라도 모든 전처리지시자는 문법적으로 올바르게 사용되어야 한다는 것이다. 특히, #else 와 #endif 지시자의 뒤에 공백이 아닌 다른 문자가 붙은 것이 아닌지 주의해야 한다. 컴파일러가 항상 이를 체크하는 것은 아니다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_16_01_01</rule>
    <ruleTitle><![CDATA[defined 전처리 연산자는 두 가지 표준 형태 중 한 가지로 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 define(identifier), defined identifier 의 두 가지 defined 연산만 허용한다. 다른 형태는 제한되는 위배사항이지만 모든 컴파일러가 잡아내는 것은 아니다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_16_01_02</rule>
    <ruleTitle><![CDATA[#else, #elif, #endif 모두 #if 또는 #ifdef와 같은 파일에 위치해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 문장의 포함과 제외가 전처리 지시자로 제어될 때, 모든 관련 있는 지시자가 한 파일에 존재하지 않으면 개발자가 혼동할 수 있다. 이 규칙은 #if/#ifdef ... #elif ... #else ... #endif 형태의 모든 전처리 지시자는 같은 파일에 존재하기를 요구한다. 이 규칙을 준수하면 좋은 코드 구조를 지킬 수 있고 유지보수 문제를 피할 수 있다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_16_02_01</rule>
    <ruleTitle><![CDATA[전처리자는 파일의 include와 include guard로만 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C++은 인라인 함수나 상수 선언 등을 이용하면, 기존 C언어에서 전처리자를 이용하던 것보다 더욱 안전하다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 16-2-2]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_16_02_02</rule>
    <ruleTitle><![CDATA[C++ 매크로는 include guard, type qualifier, storage class specifier로만 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C++에서 매크로는 include guard, type qualifier, storage class specifier로만 사용해야 한다. C++은 전처리자의 type-safe 대안으로 const 변수와 함수 템플릿을 제공한다. Type qualifier와 storage specifier로의 매크로 사용은 규칙 16-2-1을 위배함을 확인하라. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 16-2-1]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_16_02_03</rule>
    <ruleTitle><![CDATA[Include guard를 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 Translation Unit이 중첩된 헤더 파일의 복잡한 구조를 가질 때, 특정 헤더 파일이 중복되어 include 될 수 있다. 이는 혼란을 가져올 수 있다. 만약 이러한 다수의 include가 충돌되는 정의를 가져온다면, 이것은 정의되지 않은 행동을 하거나 오류가 있을 수 있다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_16_02_04</rule>
    <ruleTitle><![CDATA[', ", /*, // 문자는 헤더파일 이름에 포함 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 헤더 이름에 '(홑따옴표), "(쌍따옴표), /*(slash asterisk) 또는 // 문자가 < 와 > 사이에 들어가거나, ', /* 또는 // 문자가 " 사이에 들어간다면 정의되지 않은 행동을 할 수 있다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_16_02_05</rule>
    <ruleTitle><![CDATA[\ 문자는 헤더파일 이름에 포함 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 헤더 이름에 \ 문자가 < 와 > 사이에 들어가거나 " 사이에 들어간다면 정의되지 않은 동작을 할 수 있다. 어떤 환경에서는 \를 파일 이름 구분자로 사용하기 때문에 이 규칙은 심각도가 낮다. 이런 환경의 컴파일러는 종종 #include 지시자로 \의 사용을 지원한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_16_02_06</rule>
    <ruleTitle><![CDATA[#include 다음에는 <파일이름> 또는 "파일이름"이 따라와야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 표준 ISO/IEC 14882:2003 1 에 의해 허가된 #include 지시자로는 <파일이름> 또는 "파일이름"만이 허용된다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_16_03_01</rule>
    <ruleTitle><![CDATA[단일 매크로 정의에서 # 또는 ## 연산자는 최대 한 개만 존재해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 #과 ## 전처리 연산자의 evaluation 순서는 명시되어있지 않다. 어떤 단일 매크로 정의에서도 한 번만 사용한다면 이 문제는 발생하지 않는다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_16_03_02</rule>
    <ruleTitle><![CDATA[#과 ## 연산자 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Advisory<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 #과 ## 전처리 연산자의 evaluation 순서는 명시되어 있지 않다. 컴파일러는 이러한 연산자를 일관되게 실행하지 않으므로, 사용하지 않는다면 이러한 문제를 피할 수 있다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_16_06_01</rule>
    <ruleTitle><![CDATA[#pragma 지시자의 모든 사용은 기록되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 #pragma 지시자는 implementation-defined이기 때문에, 모든 사용이 정확함을 증명하는 것이 중요하다. 이 규칙은 사용된 pragma 지시자의 리스트를 만들고 문서화 하기를 요구한다. 이 리스트는 pragma의 동작과 그 영향을 이해할 수 있도록 설명해주는 정도면 충분하다. pragma는 가능한 한 최소한만 사용하며, 지역화, 캡슐화가 되어있어야 한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_17_00_01</rule>
    <ruleTitle><![CDATA[표준 라이브러리에 예약된 식별자, 매크로, 함수는 define, redefine, 또는 undefine 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 표준 라이브러리에 정의된 매크로를 undef 하는 것은 일반적으로 나쁜 습관이다. 또한 C++에 예약된 식별자, C++ 키워드 또는 표준 라이브러리에 예약된 이름의 다른 매크로, 객체, 함수 이름으로 #define 하는 것도 마찬가지이다. 예를 들면 defined, __LINE__, __FILE__, __DATE__, __TIME__, __STDC__, errno 그리고 assert 처럼 재정의 또는 undefine 하면 정의되지 않은 행동을 하는 몇몇의 예약된 특정 단어와 함수 이름이 있다. 이 규칙은 헤더 파일이 실제로 include 되었는지 여부와는 상관 없다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 16-0-3]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_17_00_02</rule>
    <ruleTitle><![CDATA[표준 라이브러리 매크로, 객체 이름의 재사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 개발자가 표준 라이브러리 매크로 또는 객체의 새 버전을 사용하면(기능성 강화 또는 입력 값 검사를 위해), 수정된 매크로 또는 객체는 새로운 이름을 가져야 한다. 왜냐하면 표준 매크로나 객체인지 아니면 수정된 버전인지 혼란을 피해야 하기 때문이다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_17_00_03</rule>
    <ruleTitle><![CDATA[표준 라이브러리 함수와 같은 이름의 함수 재선언 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 개발자가 표준 라이브러리 함수의 새로운 버전을 사용한다면(기능성 강화 또는 입력 값 검사를 위해), 수정된 함수는 새로운 이름을 가져야 한다. 그러나 기능이 기존 함수와 같다면, 새로운 파라미터를 추가해서 overload를 하는 것은 허용한다. 이는 함수의 이름과 기능이 일관되도록 한다. 예를 들어, sqrt 함수의 새로운 버전은 입력 값이 음수가 아님을 검사할 때, 이름을 sqrt라고 지으면 안된다. 그러나 overload는 허용한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_17_00_04</rule>
    <ruleTitle><![CDATA[모든 라이브러리 코드는 MISRA C++을 따라야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Document<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 라이브러리의 품질은 나머지 프로젝트 코드들과 최소한 같은 표준을 따라야 한다. 라이브러리 코드는 소스코드 또는 객체코드로 존재할 수 있다. 각각의 라이브러리는 코드가 어떻게 MISRA C++를 준수하는지 증명하는 문서를 포함해야 한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_17_00_05</rule>
    <ruleTitle><![CDATA[setjmp 매크로와 longjmp 함수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 setjmp와 longjmp는 코드를 우회하기(bypass) 위한 함수 호출 메커니즘이다. 그러나 try-catch-finally 가 더욱 잘 정의된 메커니즘을 제공하기 때문에 setjmp와 longjmp는 사용하면 안 된다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_18_00_01</rule>
    <ruleTitle><![CDATA[C 라이브러리 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 몇몇의 C++ 라이브러리(<cstdio> 등...)는 C 버전<stdio.h> 에 해당한다. 이 규칙에서는 C++ 버전을 사용할 것을 요구한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_18_00_02</rule>
    <ruleTitle><![CDATA[라이브러리 <cstdlib>의 함수 atof, atoi 그리고 atol은 사용하면 안 된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 이 함수들은 string을 변환할 수 없을 때, 정의되지 않은 행동을 한다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>ISO/IEC 9899:1990 [16] §7.10.1]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_18_00_03</rule>
    <ruleTitle><![CDATA[라이브러리 <cstdlib>의 함수 abort, exit, getenv, system은 사용하면 안 된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 이러한 함수의 사용은 implementation-defined behaviour을 가져온다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_18_00_04</rule>
    <ruleTitle><![CDATA[라이브러리 <ctime>의 시간 핸들링 함수는 사용하면 안 된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 시간의 포멧 같은 various aspects는 implementation-defined 또는 unspecified 이다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_18_00_05</rule>
    <ruleTitle><![CDATA[라이브러리 <cstring>의 unbounded 함수는 사용하면 안 된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 &lt;cstring&gt; 라이브러리의 strcpy, strcmp, strcat, strchr, strspn, strcspn, strpbrk, strrchr, strstr, strtok, strlen 함수들은 버퍼의 끝을 넘어서 읽거나 쓸 수 있기 때문에 정의되지 않은 행동을 할 수 있다. 안전한 string 핸들링 라이브러리를 사용해야 한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_18_02_01</rule>
    <ruleTitle><![CDATA[시스템 매크로 offsetof 는 사용하면 안 된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 피연산자의 타입이 호환 불가능하거나 비트필드가 사용되었을 때, 이 매크로를 사용하면 정의되지 않은 행동을 할 수 있다. (offsetof 함수: 자신의 부모 구조체의 시작 주소에서 멤버 주소까지의 거리(offset)을 반환하는 함수.) 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_18_04_01</rule>
    <ruleTitle><![CDATA[동적 힙 메모리 할당은 사용하면 안 된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 동적 메모리의 사용은 out-of-storage 런타임 실패를 가져온다. 대체된 버전이 아닌 built-in new, delete 연산자는 동적 힙 메모리를 사용한다. 함수 calloc, malloc, realloc, free 또한 동적 힙 메모리를 사용한다. 동적 메모리 할당과 관련된 unspecified, undefined, implementation-defined behavior의 범위가 있다. 동적 힙 메모리 할당은 메모리 누수, 데이터의 불일치, 메모리 고갈, 결정되지 않은 행동 등을 가져올 수 있다. 어떤 구현들에서는 다른 함수(예를 들면, cstring 라이브러리의 함수들)를 사용할 때 동적 힙 메모리 할당을 사용한다. 만약 이런 경우라면 이러한 함수들은 사용을 피해야 한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_18_07_01</rule>
    <ruleTitle><![CDATA[라이브러리 <csignal>의 신호 핸들링 기능은 사용하면 안 된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 신호 핸들링은 implementation-defined이며, 정의되지 않은 행동을 포함한다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_19_03_01</rule>
    <ruleTitle><![CDATA[에러 표시자(indicator) errno는 사용하면 안 된다 ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 C++의 기능인 errno는 이론적으로 유용하나 실질적으로는 표준에 따라 잘 정의되지 않았다. 0이 아닌 값이 어떤 문제를 가리킬 수도 가리키지 않을 수도 있기 때문에 errno는 사용하면 안 된다. 비록 이러한 함수들에서 errno의 행동을 잘 구현했다고 하더라도, errno가 에러를 잡아내는데 의존하기 보다는 함수 호출 전에 입력 값을 체크하기를 권장한다. 
<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">See also</span></span> <br/><br/>Rule 0-3-2]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_CPP_2008</ruleSetName>
    <ruleSetDesc><![CDATA[Guidelines for the use of the C++ language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_CPP_27_00_01</rule>
    <ruleTitle><![CDATA[스트림 입력/출력 라이브러리 <cstdio>는 사용하면 안 된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="font-weight:bold" ><span style="color:#4B63AE" style="font-weight:bold" >Category</span></span> &nbsp;Required<br/><br/>
<span style="font-weight:bold" ><span style="color:#4B63AE">Rationale</span></span><br/><br/>
 이 규칙은 파일과 입력 출력 함수들 fgetpos, fopen, ftell, gets, perror, remove, rename 등을 포함한다. 스트림과 파일 입력 출력은 그와 관련된 수많은 unspecified, undefined, implementation-defined behavior를 가져온다. 
<br/><br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_01_01</rule>
    <ruleTitle><![CDATA[소스파일이 ANSI C 표준을 준수해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 모든 코드는 ISO 9899:1990 을 준수해야 한다. 표준이상으로 확장된 컴파일러의 구문의 사용은 일반적인 C 언어 표준과 다르고 종종 개발자에게 혼동을 야기한다. C 언어 표준을 따르는 구현은 이식성 높은 코드 작성에도 도움이 된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_01_02</rule>
    <ruleTitle><![CDATA[정의되지 않았거나 서술되지 않은 특성을 신뢰하여 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 표준에서 정의되지 않거나 서술되지 않은 특성을 신뢰하여 사용하지 않도록 한다. 대부분의 경우는 정상적으로 작동하지만, 컴파일러 제작회사마다 다른 특성을 가진다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_01_03</rule>
    <ruleTitle><![CDATA[다양한 언어 (그리고/또는) 컴파일러는 오브젝트 코드를 위해서 공통적으로 정의된 인터페이스 표준이 있을 때 사용해야 함]]></ruleTitle>
    <ruleDesc><![CDATA[  모듈이 C가 아닌 다른 언어로 구현되거나, 다른 C 컴파일러로 컴파일 되었다면, 모듈이 다른 모듈들과 정확히 통합될 것인지 확인하는 것이 필수적이다. C언어 동작의 일부 측면은 컴파일러에 의존하고 있으며, 따라서 사용되는 컴파일러의 특성을 알고 있어야 한다. 알고 있어야 할 특성의 예로는 스택 사용, 파라미터 통과, 데이터 값이 저장되는 방식 등이다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_01_04</rule>
    <ruleTitle><![CDATA[컴파일러와 링커는 외부 식별자에 대해 31자가 넘지 않음을 체크해야함]]></ruleTitle>
    <ruleDesc><![CDATA[ ISO 표준에서는 외부 식별자를 처음 여섯 자로 구분 가능하도록 요구한다. 그러나 이렇게 도움 안 되는 제약을 따르는 것은 불필요한 제한으로 간주한다. 왜냐하면, 대부분의 컴파일러와 링커는 적어도 31자까지는 의미있는 것으로 허용하기 때문이다. 따라서 31자를 넘는 식별자에 대해 정확한 진단을 수행하는 컴파일러와 링커를 사용하는 것을 권장한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_01_05</rule>
    <ruleTitle><![CDATA[부동 소수 구현은 정의된 부동 소수 표준을 따라야 함]]></ruleTitle>
    <ruleDesc><![CDATA[ 부동 소수 계산에 관련된 많은 문제점들이 있다. 대부분의 문제들은 표준을 따르는 것으로 어느정도 극복이 가능하다. 규칙 6.3에 따라 부동 소수점 타입을 정의하는 것은, 사용하는 부동 소수 표준을 쉽게 알 수 있도록 한다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_02_01</rule>
    <ruleTitle><![CDATA[어셈블리 코드는 캡슐화 되고 분리(isolated)되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 어셈블리 코드는 캡슐화되고 분리되야 한다. 어셈블리어 명령이 필요하다면, 어셈블리 함수, C 함수 또는 매크로 중 어느 한 가지로 캡슐화 또는 분리시킬 것을 권장한다. 효율성을 근거로, 때로는 간단한 어셈블리 명령어를 포함시켜야할 때가 있다(예: 인터럽트를 사용하거나 사용하지 않도록 설정할 때). 이러한 경우 매크로를 사용하도록 권장한다. 추가적으로, 인라인 어셈블리 언어의 사용은 표준 C 의 확장이므로, MISRA 1.1 규칙에 위배된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_02_02</rule>
    <ruleTitle><![CDATA[C 스타일 주석만 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 주석이 필요한 경우, C 언어 주석인 /*  */ 형태만 사용해야 한다. C99는 C++와의 호환성을 위해 // 형태의 주석을 지원하지만, C90 을 엄격하게 따르는 컴파일러들은 이를 지원하지 못한다. // 형태의 주석은 전처리기 단계에서 해석이 달라질 수 있고, 컴파일러마다 다른 동작을 보인다. 또한 /*  */ 형태와 // 형태의 주석을 혼용하는 것은 프로그램의 일관성을 해치게 된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_02_03</rule>
    <ruleTitle><![CDATA[중첩된 C 스타일 주석 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 몇몇 컴파일러는 언어의 확장으로 주석의 중첩을 허용하기도 하지만, C언어 표준에서는 이를 허용하지 않는다. 주석은 /*로 시작해서 처음으로 만나는 */에서 끝나는데, 주석 안에 /*가 있으면 주석의 끝이 생략되었다고 잘못 인식될 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_02_04</rule>
    <ruleTitle><![CDATA[코드 섹션은 주석처리 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 특정 소스코드의 섹션이 컴파일 되지 않는 것을 요구할 때, 조건부 컴파일을 사용하는 것을 권장한다(주석과 함께 사용되는 #if 또는 #ifdef 구조). C 표준은 중첩 주석을 지원하지 않는다. 이러한 목적을 위한 주석 시작과 끝 표시의 사용은 위험하다. 왜냐하면 C가 중첩 주석을 지원하지 않고, 코드 섹션 내에 다른 주석이 있다면 프로그램 흐름이 바뀔 수 있기 때문이다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_03_01</rule>
    <ruleTitle><![CDATA[모든 구현 시 정의되는 행동은 문서화해야 함]]></ruleTitle>
    <ruleDesc><![CDATA[ 모든 구현 시 정의되는 행동은 다른 규칙에서 검출하는 것 외에는 모두 문서화 되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_03_02</rule>
    <ruleTitle><![CDATA[문자 집합과 그 해당 인코딩은 문서화 되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[ ISO 10646 표준에서는 문자 집합과 숫자 집합에 대한 매핑을 표준화하고 있다. 이식성을 위해 문자 상수(character-constant) 와 문자열 상수(string-literal)는 문서에 기록된 문자의 일부만을 사용해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_03_03</rule>
    <ruleTitle><![CDATA[정수 나눗셈의 구현은 반드시 주어진 컴파일러에서 결정되고 문서화 되며, 고려되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[ ISO 표준의 컴파일러는 부호있는 정수 나눗셈에 대해 두 가지 특성을 가질 수 있다. 몫을 올림하고 나머지는 음수를 취하는 것과, 몫을 내림하고 나머지는 양수를 취하는 것이다. <br/>예를 들면 -5/3 의 몫을 -1, 나머지를 -2 를 취하는 것과, 몫을 -2 를, 나머지를 +1 을 취하는 것이다. 이러한 상황을 어떻게 처리하도록 컴파일러를 구현할지 결정하고, 프로그래머를 위해서 문서화하는 것이 중요하다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_03_04</rule>
    <ruleTitle><![CDATA[모든 #pragma 지시자는 기록되고 설명되어 있어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[  이 규칙은 프로그램에서 사용할 #pragma 들이 모두 문서화 되어 있도록 요구한다. 문서에는 pragma의 동작이 완전히 이해되었음을 입증할 수 있는 충분한 지원설명이 있어야 한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_03_05</rule>
    <ruleTitle><![CDATA[의존성이 있는 경우, 구현시 정의된 동작과 비트 필드의 패킹은 문서화 되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[  이것은 규칙 6.4, 6.5에 설명된 잘못 정의된 비트필드의 사용 때문에 생기는 문제이다. C에서 비트필드는 가장 잘못 정의된 부분 중 하나이다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_03_06</rule>
    <ruleTitle><![CDATA[모든 라이브러리도 MISRA 표준을 준수하고 검증되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[시스템 라이브러리, 3rd party 라이브러리 혹은 직접 개발한 라이브러리들도 MISRA 표준을 준수하고 검증되어야 한다. IEC 61508 Part 3에서 권고하는 사항이다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_04_01</rule>
    <ruleTitle><![CDATA[ISO C 표준에 정의된 escape 문자만 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ escape 문자(문자 앞에 '\'가 들어간 문자)는 ISO C 표준에서 허용한 것만 가능하다. 특정 컴파일러에 의해 지원되어도 개발자마다 혼동할 여지가 있으므로 사용하지 않는 것이 바람직하다. <br/><br/>허용 가능한 escape 문자(\', \?, \\, \t, \v, \f, \a, \b, \n, \r, \0) ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_04_02</rule>
    <ruleTitle><![CDATA[삼중자(trigraph) 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 삼중자는 "~"를 나타내는 ??_ 처럼 두 개의 물음표 뒤에 특정 문자가 오는 형태로 사용한다. 삼중자는 일반적으로 필요하지 않으며, 두 개의 물음표를 사용하는 다른 경우와 혼동이 있을 수 있다. <br/>예를 들어 "(Date should be in the from ??-??-??)"은 실제로 컴파일러에 의해 "(Date should be in the from ~~]"로 해석된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_05_01</rule>
    <ruleTitle><![CDATA[식별자(외부연결과 내부연결)가 31자 안에서 구분 가능한지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ ISO 표준에서는 이식성을 보장하기 위해 내부연결(internal linkage) 식별자(static 함수 및 변수, 지역변수)가 31자 안에서 구분이 가능해야 한다고 명시하고 있다. 실제로 일부 오래된 링커들은 31자를 넘어가는 식별자를 31자까지만 비교한다. <br/><br/><b>이 규칙은 모든 이름공간(name space)에 걸쳐서 적용해야 한다. 매크로 이름 또한 31자 안에서 구분 가능해야 한다.</b> ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_05_02</rule>
    <ruleTitle><![CDATA[외부 범위(extern scope) 의 식별자와 같은 이름의 식별자를 내부 범위(internal scope) 에서 선언 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 서로 다른 scope에서 같은 이름의 식별자를 쓰는 것은 혼동을 가져온다. <br/> 외부/내부 범위는 다음과 같이 정의된다. <ul><li>파일 범위(file scope)를 가지는 식별자는 가장 바깥쪽의 scope를 갖는다.</li><li>블럭 범위(block scope)를 가지는 식별자는 더욱 안쪽의 범위를 갖는다.</li><li>연속적으로, 중첩된 블럭은 더욱 안쪽의 범위를 가진다.</li></ul><p>규칙은 안쪽의 정의가 바깥쪽의 정의를 가리면 안 된다는 것이다. 안쪽의 정의가 바깥쪽의 정의를 가리지 않으면 규칙에 위배되지 않는다.</p> ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_05_03</rule>
    <ruleTitle><![CDATA[typedef 이름은 유일한 식별자여야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ typedef로 선언한 타입 이름은 프로그램 내의 다른 어떤 이름으로도 사용하면 안 된다. <br/>타입은 프로그램을 바르게 이해하는데 중요한 요소이고, 프로그램의 유지 보수 측면에서 가독성을 증진시키기 위한 목적으로 사용된다. 따라서 한 번 선언한 이름을 다른 용도로 사용하지 않는 것이 좋다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_05_04</rule>
    <ruleTitle><![CDATA[태그 이름은 유일한 식별자이어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 태그(tag) 이름은 프로그램 내에서 다른 태크를 정의하거나 또는 다른 목적으로 재사용해서는 안 된다.<br/> ISO 표준에서는 합성(aggregate)타입 선언에서 다른 타입에서 이미 사용된 태그를 사용할 때의 행동을 정의하고 있지 않다.<br/><br/>타입 정의가 헤더 파일에서 이루어지고, 이 헤더 파일을 여러 소스 파일에서 포함하는 경우에는 규칙 위배가 아니다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_05_05</rule>
    <ruleTitle><![CDATA[정적 변수와 정적 함수 이름은 시스템 내에서 유일해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 범위(scope)에 관계 없이, 정적인 선언에 사용된 식별자는 시스템(입력으로 주어진 프로그램)내에서도 재사용해서는 안 된다. 이는 외부(extern) 연결을 포함한 오브젝트나 함수에도 적용된다.<br/> 컴파일러는 이것을 정확히 구분할 수 있지만, 프로그래머가 관계 없는 변수를 같은 이름으로 지정할 가능성이 있기 때문에 유지보수성을 해칠 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_05_06</rule>
    <ruleTitle><![CDATA[서로 다른 이름 공간(name space)에서 같은 이름의 식별자를 정의해서는 안됨 (단, 구조체와 유니온의 멤버 이름은 제외) ]]></ruleTitle>
    <ruleDesc><![CDATA[ 이름 공간과 범위(scope)는 다른 개념이다. <br/><br/><b>이 규칙에서는 범위는 고려하지 않는다.</b> ISO C 표준은 수많은 이름 공간을 정의한다.<br/> 서로 다른 이름 공간에서 완전히 다른 목적으로 같은 이름을 사용하는 것은 기술적으로 가능하지만, 이는 프로그래머로 하여금 혼란을 가져올 수 있기 때문에 서로 다른 이름 공간에서도 같은 이름을 재사용하면 안 된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_05_07</rule>
    <ruleTitle><![CDATA[식별자 이름의 재사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Scope에 관계 없이, 식별자는 시스템 내의 어떤 파일에서도 재사용해서는 안 된다.<br/> 식별자 이름이 헤더 파일에서 사용되고 그 헤더 파일이 여러 소스파일에 포함된다면, 이 규칙은 위반되지 않는다.<br/><br/><b>엄격한 명명 규칙을 사용하는 것이 이 규칙을 구현하는데 도움이 될 수 있다.</b> ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_06_01</rule>
    <ruleTitle><![CDATA[문자 값의 사용 및 저장 이외의 용도로 plain char 타입 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C언어에는 (plain)char, signed char, unsigned char의 세 가지 서로 다른 문자 타입이 존재한다. 문자 타입은 기본적으로 정수 타입과 혼용이 가능하지만, (plain) char는 문자 데이터에만 사용해야 한다. <br/>plain char 타입의 부호는 컴파일러 마다 다르게 정의되므로 이 타입을 다른 타입으로 변환하는 것이 프로그램 오류에 잠재적인 영향을 줄 수 있다.<br/><br/>일반적으로 plain char 타입에서 허용되는 연산자는 대입과 등호이다.(=, ==, !=) ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_06_02</rule>
    <ruleTitle><![CDATA[숫자 값의 사용 및 저장 외의 용도로 signed, unsigned char 타입 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C 언어에는 (plain)char, signed char, unsigned char의 세 가지 서로 다른 문자 타입이 존재한다. signed char와 unsigned char는 숫자로 의미가 있는 데이터에만 사용해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_06_03</rule>
    <ruleTitle><![CDATA[기본 타입 대신 typedef 로 재정의되어 크기와 부호를 알 수 있는 타입을 사용해야 함]]></ruleTitle>
    <ruleDesc><![CDATA[ char, int, short, long, float 그리고 double 등의 기본 타입은 사용하지 말아야 하며, 대신 크기와 부호를 나타내는 typedef 로 재 정의된 타입을 사용해야 한다. <br/>실제 구현에서 기본 int 크기를 이해하는 것은 매우 중요하다. 프로그래머는 아래의 정의와 같이 typedef 로 타입을 재정의 하는 방법을 숙지하고 이를 따라야 한다. <br/><br/>int 사이즈가 32bit 인 환경에서 다음과 같이 구현한다.<br/><center><table><tr><td align='left'><pre>typedef		char	char_t;
typedef	signed	char	int8_t;
typedef	signed	short	int16_t;
typedef	signed	int	int32_t;
typedef	signed	long	int64_t;
typedef	unsigned	char	uint8_t;
typedef	unsigned	short	uint16_t;
typedef	unsigned	int	uint32_t;
typedef	unsigned	long	uint64_t;
typedef		float	float32_t;
typedef		double	float64_t;
typedef	long	double	float128_t;</pre></td></tr></table></center> ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_06_04</rule>
    <ruleTitle><![CDATA[비트 필드(bit-field)는 unsigned int 또는 signed int 타입으로 정의해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 비트 필드에서 int 타입을 사용하려면 비트 필드 선언시 부호 유무를 결정해야 한다. <br/>int 타입의 bit 필드는 signed 일수도 unsigned 일수도 있기 때문이다. 비트 필드를 위해 enum, short 또는 char 타입을 사용하는 것은 표준에 의해 정의되지 않아 컴파일러 마다 구현이 다를 수 있으므로 허용하지 않는다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_06_05</rule>
    <ruleTitle><![CDATA[signed int 타입의 비트 필드의 비트 사이즈 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 1 bit 길이의 signed 비트 필드는 의미가 없다. signed int bit 필드의 사이즈는 최소 2 이상이어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_07_01</rule>
    <ruleTitle><![CDATA[0이 아닌 8진수 상수와 8진수 escape 문자열 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 0으로 시작하는 정수 상수는 8진수로 인식한다. <br/>이것은 위험할 수 있는데, 하나의 예로 고정 길이 상수를 사용 할 때이다. 52를 세 자리 정수로 표현하면 052의 형태가 되는데, 이것을 8진수로 인식하여 문제가 생긴다. <br/>8진수 escape 문자열은 컴파일러마다 다르게 인식하여 문제를 일으킬 수 있다.  ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_08_01</rule>
    <ruleTitle><![CDATA[함수의 정의와 호출 전에 함수의 원형을 선언해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 원형을 사용하면 컴파일러에 의해 함수 정의와 호출의 완전성을 체크할 수 있으며 함수 원형이 없으면 컴파일러가 함수 호출 시에 잡아야 하는 특정 에러를 잡아낼 수 없다.(예: 인자수가 다른 에러, 타입이 다른 경우) <br/>외부 연결(external linkage) 함수를 위해서 추천하는 함수 원형 구현 방법은 함수를 헤더파일에 선언한 후 헤더파일을 함수 원형이 필요한 모든 파일에 포함하는 것이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_08_02</rule>
    <ruleTitle><![CDATA[객체나 함수의 선언 또는 정의 시 타입을 명시해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C 언어는 오래된 코드와의 호환성을 위해 타입을 명시하지 않은 경우에 기본 타입 int로 인식한다. <br/>타입을 명시적으로 작성하는 것이 코드 읽기에 도움이 된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_08_03</rule>
    <ruleTitle><![CDATA[함수의 선언과 정의에서 사용된 반환 타입과 형식인자의 타입이 동일해야 함]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수를 정의와 선언을 나눠둔 경우에 정의에 나타난 형식 인자의 타입과 반환 타입은 선언에서 사용한 타입과 동일한 타입이어야 한다. 뿐만 아니라 typedef 된 타입 이름이라면, 이름과 qualifier 까지 동일해야 한다.<br/><b>이 규칙은 잠재적으로 타입을 혼동할 여지를 줄여주어 개발자가 실수하는 것을 방지할 수 있게 한다.</b> ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_08_04</rule>
    <ruleTitle><![CDATA[객체나 함수가 한번 이상 선언된다면, 타입은 모두 호환 가능해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C 언어 표준은 타입간의 호환가능성에 대해 자세히 설명하고 있다(ISO/IEC 9899:1990, Section 6.1.2.6). <br/><br/>호환가능한 대표적인 예는 다음과 같다. <br/><center><table><tr><td align='left'><pre>signed int  - int
char[5] - char []
unsigned short int - unsigned short</pre></td></tr></table></center> ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_08_05</rule>
    <ruleTitle><![CDATA[헤더파일에 객체나 함수 정의 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 헤더 파일에는 객체, 함수, typedef, 그리고 매크로의 선언만 사용해야 한다. 헤더파일은 저장공간을 사용하는 객체나 함수의 정의를 포함해서는 안 된다. 오직 .c 파일에만 실행 가능한 소스 코드가 포함되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_08_06</rule>
    <ruleTitle><![CDATA[함수는 파일 범위(file scope)에 선언되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 블럭 범위(block scope)에 함수 선언을 하는 것은 혼동을 가져올 수 있고, 정의되지 않은 동작이 발생할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_08_07</rule>
    <ruleTitle><![CDATA[하나의 함수에서만 접근하는 객체는 해당 함수의 블럭 범위(block scope)에 정의되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 객체의 유효범위는 이용 가능한 함수 내로 제한된다. 파일 범위(file scope)는 객체가 내부 연결(internal linkage) 또는 외부 연결(external linkage)를 가지는 경우에만 사용된다. <br/>프로젝트 내에 하나 또는 여러 개의 헤더파일이 존재할 수 있지만, 각각의 외부 연결 객체 또는 함수는 오직 하나의 헤더 파일에만 선언되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_08_08</rule>
    <ruleTitle><![CDATA[외부 연결(external linkage)을 갖는 객체나 함수는 오직 하나의 파일에서만 선언되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 외부 연결(external linkage) 식별자는 일반적으로 헤더파일에 선언해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_08_09</rule>
    <ruleTitle><![CDATA[외부 연결(external linkage)를 포함하는 식별자는 정확히 하나의 외부 연결 정의을 가져야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 식별자가 서로 다른 파일에서 여러 개로 중복 정의 되어 있거나, 아예 정의되어있지 않으면 해당 식별자의 사용은 보통의 경우 링크에러로 나타난다.<br/>또한 중복으로 정의가 있다면 정의의 형태가 완전히 같다고 하더라도 링크시에 에러가 발생하며, 정의의 내용이 다른 경우 개발자의 의도와는 다른 결과를 나타낼 가능성이 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_08_10</rule>
    <ruleTitle><![CDATA[하나의 파일에서 객체와 함수의 모든 선언과 정의가 외부 연결(external linkage)일 필요가 없다면 내부 연결(internal linkage)를 가져야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 변수가 같은 파일 내에서 함수에 의해 사용된다면 static을 사용해야 한다. 비슷하게 만약 함수가 같은 파일 내에서만 호출된다면 static을 사용해야 한다. static의 사용은 식별자가 선언된 파일 내에서만 볼 수 있다는 것을 보장한다. 그리고 다른 파일이나 라이브러리의 동일한 식별자와 혼동할 가능성도 없앨 수 있다.  이 규칙은 변수나 함수를 함께 검사하는 파일에서 사용하는지 확인하기 때문에 검사 대상을 정확하게 선택해야 한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_08_11</rule>
    <ruleTitle><![CDATA[내부 연결(internal linkage)를 가지는 객체나 함수의 선언과 정의에서 static을 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ static 과 extern 은 종종 개발자를 혼동스럽게 하지만, 내부 연결을 가지는 모든 객체나 함수의 선언에 static 키워드를 지속적으로 적용하는 것이 프로그래머에게 좋은 연습이 될 수 있다.<br/>선언과 정의에서 static/extern 여부가 일치해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_08_12</rule>
    <ruleTitle><![CDATA[외부 연결(external linkage) 배열의 사이즈는 명시적으로 표시되거나 초기화를 통해 묵시적으로 정의 되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 배열을 불완전한 타입으로 선언하고 접근하는 것이 가능하더라도, 명시적으로 사이즈를 표시하는 것이 안전하다. <b>이 규칙은 extern 선언한 배열에 대해서만 검사한다.</b> ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_09_01</rule>
    <ruleTitle><![CDATA[모든 변수는 사용하기 전에 값이 할당되어 있어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 모든 변수는 읽어오기 전에 변수에 값이 쓰여져야 한다. 이것이 꼭 변수 선언 시 초기화를 해야한다는 것은 아니다.<br/> ISO C 표준에 따르면 static 변수의 저장 공간은 초기화 해주지 않으면 자동으로 0으로 초기화가 된다. 하지만 일반 변수는 자동으로 초기화가 되지 않는다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_09_02</rule>
    <ruleTitle><![CDATA[배열과 구조체를 0이 아닌 값으로 초기화 시 brace는 저장 공간의 구조와 일치하도록 사용되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ ISO C 표준에 따르면 배열, 구조체, 유니온 타입을 위한 초기화 구문은 한 쌍의 brace로 둘러 쌓인다. <br/><br/><b>이 규칙에서는 중첩된 구조를 표현하기 위해서 추가적인 brace의 사용을 요구한다. <br/>프로그래머는 복잡한 데이터 타입의 요소를 고려해서 명시적으로 초기화를 해야 한다.</b> ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_09_03</rule>
    <ruleTitle><![CDATA[Enumerator 리스트에서 모든 멤버가 명시적 초기화가 되지 않았다면, "="은 첫 번째가 아닌 멤버의 명시적 초기화에 사용되서는 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Enumerator 리스트에서 멤버의 명시적 초기화가 되지 않았다면, C는 0부터 1씩 증가하며 순서대로 멤버에 값을 할당한다. <br/>이 규칙에서 허용한 대로 첫 멤버의 명시적 초기화는 주어진 값을 시작 값으로 지정한다. 이렇게 시작 값을 지정할 때 enumeration 상수가 사용되는 int 저장 공간이 초과되지 않도록, 사용되는 초기 값이 충분히 작은지 확인하는 것이 필요하다.<br/> 리스트 내 모든 멤버의 명시적 초기화는 자동적, 수동적 할당이 함께 쓰이는 것을 방지해서 에러를 예방한다. 그러나 이렇게 사용할 때는 프로그래머가 모든 값들을 보고 요구하는 범위가 맞는지, 의도하지 않은 값의 중복이 있는지 확인해야 한다.  ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_10_01</rule>
    <ruleTitle><![CDATA[정수형 타입의 표현식의 값을 다른 근본 타입(underlying type)으로 묵시적 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 다음과 같은 경우에 정수형 타입 수식의 값은 다른 근본 타입으로 묵시적 변환하면 안 된다.<br/><ul><li>a) 동일한 부호의 더욱 큰 범위의 정수형 타입으로 변환하는 것이 아닌 경우,</li><li>b) 표현식이 complex인 경우, </li><li>c) 표현식이 상수가 아닌 함수의 인자인 경우,</li><li>d) 표현식이 상수가 아닌 return 표현식인 경우</li></ul> ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_10_02</rule>
    <ruleTitle><![CDATA[실수형 타입(floating type)의 표현식의 값을 다른 타입으로 묵시적 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 다음과 같은 경우에 실수형 타입 수식의 값은 다른 타입으로 묵시적 변환하면 안 된다. <br/><ul><li>a) 더욱 큰 범위의 실수형 타입으로 변환하는 것이 아닌 경우, </li><li>b) 표현식이 complex인 경우, </li><li>c) 표현식이 함수의 인자인 경우, </li><li>d) 표현식이 return 표현식인 경우</li></ul> ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_10_03</rule>
    <ruleTitle><![CDATA[정수형 타입의 complex 표현식의 값은 표현식의 근본 타입(underlying type)보다 작고 부호가 같은 타입으로만 cast를 허용함]]></ruleTitle>
    <ruleDesc><![CDATA[ cast가 어떤 complex 표현식에도 사용된다면, 적용할 수 있는 cast의 타입은 굉장히 제한적일 것이다. Complex 표현식의 변환은 혼동을 가져오므로 조심하는 것이 좋다. <br/><br/><b>이 규칙에 따르기 위하여 임시 변수 또는 추가적인 문장(statement)이 필요할 수 있다.</b>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_10_04</rule>
    <ruleTitle><![CDATA[실수형 타입(floating type)의 complex 표현식의 값은 작거나 같은 실수형 타입으로만 cast 되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ cast가 어떤 complex 표현식에도 사용된다면, 적용할 수 있는 cast의 타입은 굉장히 제한적일 것이다. Complex 표현식의 변환은 혼동을 가져오므로 조심하는 것이 좋다. <br/><br/><b>이 규칙에 따르기 위하여 임시 변수 또는 추가적인 문장(statement)이 필요할 수 있다.</b> ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_10_05</rule>
    <ruleTitle><![CDATA[Bitwise 연산자인 ~와 <<가 unsigned char 또는 unsigned short 타입에 적용될 경우, 그 결과는 즉시 피연산자의 근본 타입(underlying type)으로 cast되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[ (~ 와 <<) 연산자가 small 정수형 타입(unsigned char or unsigned short)에 적용될 경우 integer promotion 이 진행되고, 그 결과는 예측하지 못한 최상위 비트를 포함할 수 있다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_10_06</rule>
    <ruleTitle><![CDATA[모든 unsigned 타입의 상수에는 U 접미사를 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 정수 상수의 타입은 잠재적 혼동을 가져온다. 예를 들어 정수 상수 40000은 32bit 환경에서는 int 타입이지만, 16bit 환경에서는 long 타입이다. 정수 타입은 다음 요소들의 복잡한 조합에 의존한다.<ul><li>- 상수의 크기</li><li>- 정수형 타입의 구현된 크기</li><li>- 접미사의 표현</li><li>- 값이 표현된 number base(decimal, octal or hexadecimal)</li></ul> ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_11_01</rule>
    <ruleTitle><![CDATA[함수 포인터 타입과는 정수형 타입을 제외한 어떤 타입 간에도 변환이 일어나선 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 포인터를 다른 포인터의 타입으로 변환하는 것은 정의되지 않은 행동이다. 예를 들어 함수을 가리키는 포인터는 함수의 다른 타입을 가리키도록 변환할 수 없다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_11_02</rule>
    <ruleTitle><![CDATA[오브젝트의 포인터와는 정수형 타입, 다른 오브젝트의 포인터 또는 void 포인터를 제외한 어떤 타입간에도 변환이 일어나선 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 오브젝트의 포인터와는 정수형 타입, 다른 오브젝트의 포인터 또는 void 포인터를 제외한 어떤 타입간에도 변환이 일어나선 안된다. 이와 같은 변환은 정의되지 않은 변환이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_11_03</rule>
    <ruleTitle><![CDATA[포인터 타입과 정수형 타입간에 cast 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 포인터가 정수로 변환될 때 요구되는 정수의 크기는 구현 시 정의된다. 포인터와 정수형 타입간의 casting은 가능한한 피하는 것이 좋지만, 메모리 레지스터에 주소를 매핑할 때 또는 하드웨어의 특정 기능에 의해 피할 수 없는 경우도 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_11_04</rule>
    <ruleTitle><![CDATA[특정 타입을 갖는 오브젝트를 가리키는 포인터를 다른 오브젝트 포인터 타입으로 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 이러한 타입의 변환은 새로운 포인터 타입이 엄격한 alignment를 요구하면 무효할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_11_05</rule>
    <ruleTitle><![CDATA[포인터로 다뤄지는 const나 volatile을 제거하는 casting 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 포인터로 다뤄지는 타입은 const나 volatile 을 제거하는 캐스팅을 하면 안 된다.<br/>const나 volatile은 타입의 불변성이나 휘발성을 지정할 때 사용한다. 포인터로 다뤄지는 타입에 const나 volatile을 제거하는 캐스팅을 하게 되면 이러한 속성이 제거 되어 원래의 개체가 가지고 있는 불변성이나 휘발성을 보장할 수 없게 된다. <br/><br/>즉, 값을 수정하지 못하게 하기 위해 const로 지정한 타입에 const를 제거하는 캐스팅을 하면 값을 수정할 수 있는 동작을 컴파일러가 검사해 주지 못하게 되므로 의도하지 못한 실수 등에 의해 값이 변경되는 경우를 미리 방지할 수 없다. <br/>volatile의 경우, 이를 제거하는 캐스팅을 하면 다른 환경에 의해 개체의 값이 바뀌는 것이 반영되지 않을 수 있어 실행시간에 의도했던 외부 환경에 의한 값의 변경이 나타나지 않을 수 있으므로 실행 시간에 의도하지 않은 동작을 보일 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_12_01</rule>
    <ruleTitle><![CDATA[C 연산자의 우선순위에 의존하지 말고 연산 우선순위를 명시적으로 표현해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 괄호는 기본 연산자 우선순위 대로 계산되는 것을 방지하기 위해서 사용할 뿐 아니라 기존 연산 우선순위를 강조하기 위해서도 사용되어야 한다. C 언어는 복잡한 우선순위 때문에 실수 하기가 쉬우므로, 괄호를 사용하여 에러를 방지하고 가독성을 높일 수 있다. 그러나 너무 많은 괄호를 집어넣어 코드를 어수선하게 만들고 가독성을 떨어뜨려서는 안 된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_12_02</rule>
    <ruleTitle><![CDATA[표현식의 값들은 표준이 허용하는 어떠한 평가순서대로 평가해도 결과가 같아야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 표준에 따르면 몇몇 연산자(함수 호출 연산자 (), &&, ||, ? :, ,(comma))내의 부분-표현식(sub-expression)의 평가 순서는 달라질 수 있다. <br/>이것은 부분-표현식의 평가 순서가 개발자가 생각하는 것과 다를 수 있음을 의미한다. 마찬가지로 부작용(side-effect)의 발생 순서도 개발자의 의도와 다를 수 있다. <br/>따라서, 우선순위가 확실하지 않은 표현식을 다룰 때는, 특별히 더 조심하거나 다른 방식으로 프로그래밍 하기를 권고한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_12_03</rule>
    <ruleTitle><![CDATA[Sizeof 연산자에 부작용(side-effect)을 포함하는 표현식 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C에서 가능한 프로그래밍 에러는 sizeof 연산자를 표현식에 적용하고 표현식이 진행되기를 기대하는 것이다. 그러나 표현식은 진행되지 않는다(sizeof는 단지 표현식의 타입에만 정확한 결과를 출력한다). 이러한 에러를 피하기 위하여 sizeof는 부작용을 포함하는 표현식에 사용되서는 안 되며 부작용은 진행되지 않는다. <br/><br/><b>이 규칙에서는 모든 함수의 호출에서 부작용가 발생한다고 가정한다.</b> ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_12_04</rule>
    <ruleTitle><![CDATA[논리 연산자 && 와 || 의 오른쪽 피연산자에 부작용(side-effect) 포함 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C 코드에서 표현식의 어떤 부분은 실행되지 않는 경우가 있다. <br/>만약 부분-표현식(sub-expression)들이 부작용을 포함한다면, 다른 부분-표현식의 값에 따라 부작용은 발생 할 수도 하지 않을 수도 있다.<br/>이러한 문제를 발생시키는 연산자는 &&, ||, 그리고 ? : 이다. <br/>앞의 두 가지의 경우, 오른쪽 피연산자의 실행은 왼쪽 피연산자의 값에 따라 결정된다. ? : 연산자의 경우 두 번째 또는 세 번째 피연산자가 실행되지만 둘 다 실행되지는 않는다. <br/>논리 연산자 중 하나에서 오른쪽 피연산자의 실행은 프로그래머가 부작용을 포함시킨다면 문제를 일으킨다. ? : 연산자는 두 개의 부분-표현식 중 하나를 실행하기 때문에 실수를 하는 경우가 적다. <br/><br/><b>이 규칙에서는 모든 함수의 호출에서 부작용이 발생하지 않는다고 가정한다.</b> ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_12_05</rule>
    <ruleTitle><![CDATA[&& 과 || 의 피연산자가 primary-expression 이어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Primary-expression은 단일 식별자이거나 상수이거나 괄호 안에 들어가 있는 표현식이다. <br/><br/><b>이 규칙은 피연산자가 단일 식별자 또는 상수가 아니면 괄호 안에 들어가 있어야 한다는 것이다. 이러한 상황에서 가독성의 측면이나 프로그래머가 의도한 행동을 보장하는 측면에서 괄호는 중요하다. <br/>단지 &&의 연속 또는 ||의 연속으로 이루어진 표현식 에서는 추가적인 괄호가 필요하지 않다.</b> ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_12_06</rule>
    <ruleTitle><![CDATA[&&와 ||와 ! 연산자의 피연산자는 effectively boolean 이어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Effectively boolean은 &&와 ||와 !를 제외한 연산자의 피연산자로 사용하면 안 된다. 논리적 연산자인 &&와 ||와 !는 bitwise 연산자인 &, | 그리고 ~와 혼동하기 쉽다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_12_07</rule>
    <ruleTitle><![CDATA[피연산자의 근본 타입(underlying type)이 signed라면 bitwise 연산자 적용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Bitwise 연산자(~, <<, <<=, >>, >>=, &, &=, ^, ^=, |, |=)들은 부호있는 정수에 대해서는 의미있는 연산을 수행하지 못한다. 예를 들어, 만약 오른쪽 shift move로 부호 비트가 숫자 비트로 움직인다면 또는 왼쪽 shift move로 숫자 비트가 부호 비트로 움직인다면 문제가 발생 할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_12_08</rule>
    <ruleTitle><![CDATA[Shift 연산자의 오른쪽 피연산자는 왼쪽 피연산자의 근본 타입(underlying type)의 비트 길이 보다 작아야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ left-shift 또는 right-shift의 왼쪽 피연산자가 16-bit 정수라면, 이 shift가 0에서 15 사이의 수 만큼 이루어 지는지 확인하여 에러 발생을 미리 방지하는 것을 권고한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_12_09</rule>
    <ruleTitle><![CDATA[단항 마이너스 연산자는 unsigned 근본 타입(underlying type) 표현식 에서 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 단항 마이너스 연산자를 unsigned int 또는 unsigned long 타입 표현식에 적용하는 것은 의미 없는 연산이다. 단항 마이너스 연산자를 더 작은 부호없는 정수형 타입의 피연산자에 적용하는 것은 integer promotion 때문에 signed 타입의 결과가 나올 수 있지만, 이것은 좋은 구현이 아니다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_12_10</rule>
    <ruleTitle><![CDATA[Comma 연산자 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 일반적으로 comma 연산자의 사용은 코드의 가독성을 해친다. 다른 코드를 사용해서 같은 결과를 얻을 수 있으므로 사용하지 않는 것이 좋다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_12_11</rule>
    <ruleTitle><![CDATA[부호없는 정수 타입 상수 식의 평가가 wrap-around를 일으키면 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 부호없는 정수 표현식은 overflow 대신에 나눗셈 방식의 wrap-around가 발생한다. wrap-around 는 경우에 따라서, bit 를 삭제하는 용도로 사용되기도 하기 때문에, 컴파일러에 의해 에러로 보고되지 않는다. 하지만 의도한 경우가 아닌경우 대부분 프로그래밍 에러를 나타내는 경향이 있으므로 피하는 것이 좋다.<br/><br/><b>overflow 발생시 그 행동은 표준에서 언급하지 않고 있지만, wrap-around의 경우는 명확한 의미를 정의하고 있다.</b> ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_12_12</rule>
    <ruleTitle><![CDATA[부동 소수점 값의 bit 표현 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 부동 소수점 값의 비트 표현 방식이 컴파일러마다 다를 수 있기 때문에, 부동 소수점은 직접 다루지 말아야 한다. In-built operator 또는 세부적인 저장공간을 프로그래머로부터 숨기는 함수 등이 사용되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_12_13</rule>
    <ruleTitle><![CDATA[Increment(++), decrement(--) 연산자는 수식 내에서 다른 연산자와 혼용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ increment와 decrement 연산자를 다른 연산자와 사용하는 것은 권유하지 않는다. 왜냐하면 가독성을 상당히 해치고, 문장(statement)에 부작용(side-effect)을 집어넣어 정의하지 않은 행위를 일으킬 가능성이 있기 때문이다. 따라서 이러한 연산자는 독립적으로 사용하는 것이 안전하다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_13_01</rule>
    <ruleTitle><![CDATA[Boolean 값을 가지는 표현식의 내부에 대입 연산자 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 결과가 boolean 값을 가지는 표현 식의 내부에는 대입 연산자를 사용하면 안 된다. 여기서 말하는 대입 연산자는 단순한 대입 연산자와 복합 대입 연산자를 모두 일컫는다. 단, 변수에 boolean 값을 대입하는 경우는 예외다. 만약 boolean 값을 가지는 표현식에서 대입 연산자가 반드시 필요한 경우라면, 해당 표현식의 외부에서 따로 처리하여 사용하는 것을 권장한다. 그렇게 함으로써 '='와 '=='가 혼동되지 않도록 확실하게 처리할 수 있을 것이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_13_02</rule>
    <ruleTitle><![CDATA[피연산자가 effectively boolean 타입이 아니라면 값이 0인지 검사는 명시적으로 이루어져야 함  ]]></ruleTitle>
    <ruleDesc><![CDATA[ 데이터 값이 0인지 검사하는 것은 명시적으로 이루어져야 한다. 비록 C에서는 논리값이 정수형 타입으로 사용되지만. <br/><br/><b>이 규칙을 위배하지 않으면 명확한 코드를 작성할 수 있다. 또한, 정수값과 논리값을 구별하는데 명확한 도움을 준다.</b> ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_13_03</rule>
    <ruleTitle><![CDATA[부동 소수점 표현식은 equality 또는 inequality 검사에 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 부동 소수점 타입으로 equality를 비교할 때 true를 예상하더라도 실제로 결과가 잘못 나오는 경우가 있다. 게다가 어떤 비교의 결과는 실행 전에 예측할 수 없고, 구현 마다 달라질 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_13_04</rule>
    <ruleTitle><![CDATA[for 문의 제어 표현식에 실수 타입의 객체 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 제어문은 loop counter를 포함할 수 있는데, 프로그래머는 loop를 빠져 나갈지 결정하기 위해 loop counter를 검사한다. 이러한 loop counter 를 실수 타입 변수로 사용되선 안 된다. <br/>loop를 반복하면서 loop에 있을 것이냐 나갈 것이냐가 정확하게 진행되지 않을 수 있고, loop 변수가 부정확해 질 수 있으며, 검사가 실행되었을 때 기대하지 않은 결과가 나올 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_13_05</rule>
    <ruleTitle><![CDATA[For 문장(statement)의 초기화, 제어, 증감 표현식이 모두 loop 제어와 관련 있는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ For 문장의 세 가지 표현식은 다음의 목적으로만 사용되어야 한다. <ul><li>첫번째 표현식: loop counter의 초기화</li><li>두번째 표현식: loop counter를 검사하는 부분이 포함되어야 하고, 추가적으로 다른 loop control 변수를 검사할 수 있음</li><li>세번째 표현식: loop counter의 증가 혹은 감소.</li></ul ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_13_06</rule>
    <ruleTitle><![CDATA[반복 횟수를 세기 위해 for문 내에 사용된 정수 변수는 loop 내에서 수정 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Loop counter는 loop 내에서 수정하면 안 된다. 그러나 다른 loop control 변수(무언가가 완료 되었을때를 가리키고, for문 내에서 검사되는 flag)는 수정할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_13_07</rule>
    <ruleTitle><![CDATA[값이 항상 같은 boolean operation 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Boolean 연산자가 항상 "true" 혹은 "false"를 갖는다면 대부분 프로그래밍 에러라고 볼 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_14_01</rule>
    <ruleTitle><![CDATA[도달 불가능한 코드 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 이 규칙은 컴파일시에 도달할 수 없거나 확인할 수 없는 코드에 관한 규칙이다. 도달할 수 있지만 실행되지 않는 코드는 규칙에서 제외된다(방어적 프로그래밍). 만약 코드의 특정 부분으로 들어가는 적절한 entry point가 없다면 그 부분에는 도달할 수 없다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Dead Code</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_14_02</rule>
    <ruleTitle><![CDATA[부작용(side-effect)이 없고 제어흐름의 변화를 일으키지 않는 문장(statement) 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Null이 아니면서 부작용이 없고 제어 흐름의 변화를 일으키지 않는 문장은 보통 프로그래밍 에러로 가정하므로, 정적인 검사를 수행해야 한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_14_03</rule>
    <ruleTitle><![CDATA[전처리 전에 사용되는 null 문장(statement)은 다른 문장와 혼용 금지. null 문장 뒤의 첫번째 문자는 공백이어야 하고 그 뒤에 주석이 올 수 있음 ]]></ruleTitle>
    <ruleDesc><![CDATA[ null 문장은 보통 의도적으로 포함되지 않지만, 한 라인에 오직 null 문장만 사용하는 경우가 있다. 공백 문자가 들여쓰기를 위해 null 문장 앞에 올 수도 있다. 공백 문자의 사용은 null 문장와 주석을 구분해 준다.<br/>보통의 정적분석 도구들은 null 문장이 다른 문장과 혼용되는 경우 잠재적으로 에러가 있을 수도 있다고 경고를 출력한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_14_04</rule>
    <ruleTitle><![CDATA[Goto 문장(statement) 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 일반적으로 조건없는 점프 문장은 구조적인 프로그램을 방해한다. 프로그램을 구조적으로 작성하길 권고한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_14_05</rule>
    <ruleTitle><![CDATA[Continue 문장(statement) 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 일반적으로 조건없는 점프 문장은 구조적인 프로그램을 방해한다. 프로그램을 구조적으로 작성하길 권고한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_14_06</rule>
    <ruleTitle><![CDATA[반복문에는 loop를 종료하기 위해 최대 하나의 break 문이 사용되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 이 규칙은 잘 구조화된 프로그래밍을 위한 규칙이다. 효율적인 코딩을 위해 하나의 loop에는 하나의 break 문이 허용된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_14_07</rule>
    <ruleTitle><![CDATA[하나의 함수는 함수의 끝에 하나의 exit point를 가져야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ IEC 61508 표준에 의한 규칙으로, 이는 좋은 프로그래밍 스타일을 위한 것이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_14_08</rule>
    <ruleTitle><![CDATA[switch, while, do ... while, for 문장(statement)의 body는 복합문이어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 비록 복합문 내에 하나의 문장만 존재하더라도 switch, while, do ... while, for 문은 복합문이어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_14_09</rule>
    <ruleTitle><![CDATA[if 문(else if 또는 else 포함)의 body는 복합문이어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 복합문을 위한 layout과 괄호는 style guideline에서 결정되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_14_10</rule>
    <ruleTitle><![CDATA[모든 if ... else if 문은 반드시 else 문으로 끝나야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ If문 뒤에 하나 혹은 여러 개의 else if 문이 따라온다면 마지막에 else 문이 와야 한다. 단순한 if 문의 경우에는 else 문이 포함될 필요는 없다. 마지막 else문의 요구는 방어적 프로그래밍을 위함이다. else 문에서 적절한 행동을 취하거나 아무 행동을 취하지 않으면 적절한 주석을 달아야 한다. 이것은 switch case 문에서 default 절이 필요한 이유와 같은 것이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_15_00</rule>
    <ruleTitle><![CDATA[switch 문 안에 case, default 절이 아닌 문장(statement)은 존재하면 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C언어에서 switch 문을 위한 문법은 취약하고, 복잡하며, 구조화 되어있지 않다. 따라서 이를 대체하기 위해 MISRA-C에 의해 정의된 switch 문을 위한 문법이 존재한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_15_01</rule>
    <ruleTitle><![CDATA[switch label(case, default)을 포함하는 가장 가까운 문장(statement)은 switch 문이어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ case 또는 default label의 scope는 switch 문의 body 로써 복합문이어야 한다. 모든 case 절과 default 절은 같은 scope 에 있어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_15_02</rule>
    <ruleTitle><![CDATA[문장(statement)이 있는 모든 case 또는 default 구문은 조건문이 없는 break문으로 끝나야 함]]></ruleTitle>
    <ruleDesc><![CDATA[ 모든 case 또는 default 구문의 마지막에는 break 문이 있어야 한다. 만약 case 또는 default 구문이 복합문이라면 복합문 내의 마지막 문장이 break 문이어야 한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_15_03</rule>
    <ruleTitle><![CDATA[switch 문의 마지막 절이 default 절이어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 마지막 절에 default가 오는 것은 방어적 프로그래밍을 위함이다. default 절에서는 적절한 행동을 취하거나 아무 행동을 하지 않으면 적절한 주석을 달아야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_15_04</rule>
    <ruleTitle><![CDATA[switch 문의 조건식에는 effectively boolean 값이 들어가면 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[ switch 문의 조건식에는 effectively boolean 값이 들어가면 안 된다. 이는 switch 문의 의도와 다를 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_15_05</rule>
    <ruleTitle><![CDATA[모든 switch 문은 하나 이상의 case 절을 가져야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 모든 switch 문은 하나 이상의 case 절을 가져야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_16_01</rule>
    <ruleTitle><![CDATA[함수의 인자 수는 가변적으로 정의되서는 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수의 인자 수가 가변적이면 이로 인해 많은 문제가 발생할 수 있다. 유저는 가변적인 인자 수를 가지는 함수를 사용해선 안 된다. 따라서 이와 같은 상황에서 이용되는 stdarg.h, va_arg, va_start, va_end는 사용을 금한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_16_02</rule>
    <ruleTitle><![CDATA[함수의 직/간접적인 재귀 호출 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 시스템의 안정성을 위하여 함수의 재귀호출은 사용하지 않는 것이 좋다. 재귀호출은 스택 공간 이용을 초과하는 위험을 가져오며 이것은 심각한 오류가 될 수 있다. 함수의 재귀 호출이 매우 엄격하게 통제된다고 하더라도, 프로그램 실행 전에 스택 사용의 최악의 상황을 예측하는 것은 불가능하다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_16_03</rule>
    <ruleTitle><![CDATA[함수의 프로토타입(prototype) 선언 시 형식 인자는 모두 식별자가 주어져야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 호환성, 명확성, 유지 보수성(maintainability)을 위하여 함수 선언 시 모든 형식 인자를 위한 식별자의 이름이 주어져야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_16_04</rule>
    <ruleTitle><![CDATA[함수의 선언에 사용된 식별자와 정의에 사용된 식별자가 서로 같아야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 호환성, 명확성, 유지 보수성(maintainability)을 위하여 함수의 선언에 사용된 식별자와 정의에 사용된 식별자가 서로 같아야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_16_05</rule>
    <ruleTitle><![CDATA[함수에 형식 인자가 없는 경우 void 타입 형식 인자로 선언해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수는 return 타입과 함께 선언하는데, 함수에 return 타입이 없다면 void 타입으로 선언한다. 이와 비슷하게, 함수에 형식 인자가 없다면 형식 인자 부분은 void로 선언되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_16_06</rule>
    <ruleTitle><![CDATA[함수 호출 시 인자의 개수는 형식 인자의 수와 일치해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 이 문제는 함수 프로토타입(prototype)의 사용으로 완전히 해결할 수 있다.(Rule 8.1 참조). ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_16_07</rule>
    <ruleTitle><![CDATA[포인터 인자가 가리키는 오브젝트가 함수의 프로토타입(prototype)에서 변하지 않으면 base type 을 const로 선언해야 함]]></ruleTitle>
    <ruleDesc><![CDATA[ const 한정자는 포인터가 아니라 포인터가 가리키는 base type 에 적용해야 한다. 왜냐하면 변경하지 않아야 할 대상은 포인터가 아니라 오브젝트이기 때문이다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_16_08</rule>
    <ruleTitle><![CDATA[Non-void return 타입 함수의 모든 출구는 하나의 명시적인 return 구문을 가져야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 이러한 함수를 사용하면 함수의 return 값이 출력 된다. 그런데 return 구문의 부재는 정의되지 않은 행동을 유발할 수 있다.(컴파일러에 따라 이런 형태를 에러로 보지 않을 수도 있다.) ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_16_09</rule>
    <ruleTitle><![CDATA[함수 식별자는 주소 값(&가 붙은 형태)으로 사용하거나, 괄호화 된 형식 인자 리스트(식별자 뒤에 ()을 붙임)로 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 식별자를 그대로 사용한다면 그 목적이 함수의 주소가 NULL이 아닌지를 테스트하는 것인지, 함수의 호출인지 명확하지 않다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_16_10</rule>
    <ruleTitle><![CDATA[만약 함수가 에러 정보를 반환한다면, 반환된 에러 정보는 검사되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수는 에러의 발생을 표시하는 무언가를 반환할 수 있다. 이것은 에러 flag, 특정 반환 값, 또는 다른 것일수도 있다. 함수가 어떤 방법으로 동작하던, 호출 프로그램은 함수의 반환 후 에러 정보를 확인해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_17_01</rule>
    <ruleTitle><![CDATA[포인터 연산은 배열이나 배열의 요소를 가리키는 포인터에만 적용 가능함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 배열이나 배열 요소를 가리키는 포인터가 아닌 포인터의 덧셈 또는 뺄셈(증가나 감소 포함)은 정의하지 않은 결과를 가져올 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_17_02</rule>
    <ruleTitle><![CDATA[포인터 뺄셈은 같은 배열의 요소를 가리키는 포인터에 대해서만 적용 가능함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 포인터의 뺄셈은 두 포인터가 같은 배열 객체를 가리킬 때 정의한 결과를 가져온다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_17_03</rule>
    <ruleTitle><![CDATA[포인터 타입에 대한 >, >=, <, <= 연산은 같은 배열의 요소를 가리키는 포인터에 대해서만 적용 가능함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 두 포인터가 같은 배열 객체를 가리키지 않을 때 두 포인터를 비교하는 것은 정의하지 않은 행동을 할 수 있다. (Note: it is permissible to address the next element beyond the end of an array, but accessing this element is not allowed.) ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_17_04</rule>
    <ruleTitle><![CDATA[포인터에 접근할 때는 배열 인덱싱 형태만을 사용해야 하며, 포인터 값 연산은 금지함]]></ruleTitle>
    <ruleDesc><![CDATA[ 포인터에 접근할 때는 배열 인덱싱 형태만을 사용해야 한다. 왜냐하면 그것이 더욱 명확하고, 포인터 조작보다 에러를 덜 발생시키기 때문이다. <br/><b> 이 규칙은 포인터 값의 명시적인 계산을 금지한다. </b><br/> 배열 인덱싱은 배열 타입으로 정의된 객체에 적용되어야 한다. 명시적으로 계산된 포인터 값은 의도하지 않거나 잘못된 메모리 주소에 접근할 가능성을 가진다. 포인터들은 배열이나 구조체의 영역을 벗어날 수 있으며, 사실상 임의의 위치를 가리킬 수 있다. 규칙 MISRA_21_01 참조.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_17_05</rule>
    <ruleTitle><![CDATA[2레벨을 넘어가는 포인터는 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 2레벨을 넘어가는 포인터 사용은 코드의 가독성을 떨어뜨리므로 이러한 사용은 피해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_17_06</rule>
    <ruleTitle><![CDATA[자동 할당 공간을 사용하는 객체를 대상으로, 주소에 할당된 객체가 삭제 된 이후에도 존재할 수 있는 객체에는 할당 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 자동 할당 객체의 주소가 다른 더 큰 scope의 자동 할당 객체, static 객체 또는 함수의 리턴 값에 할당된다면, 객체를 포함하는 주소는 객체가 제거된 이후에도 존재할 수 있다.(그리고 그 주소는 무효화된다.) ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_18_01</rule>
    <ruleTitle><![CDATA[모든 구조체와 유니온 타입이 최종적으로 완전한 타입인지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 구조체나 유니온 타입은 컴파일 단위(translation unit) 내에서 완전한 타입이 되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_18_02</rule>
    <ruleTitle><![CDATA[메모리 영역이 오버랩 되어있는 두 오브젝트 간의 복사 금지]]></ruleTitle>
    <ruleDesc><![CDATA[ 표준은 메모리 영역이 오버랩된 두 개의 오브젝트가 생성되고, 한쪽을 다른쪽에 복사하는 경우의 특성을 정의하지 않았다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_18_03</rule>
    <ruleTitle><![CDATA[메모리 영역을 관련성 없게 재사용하면 안됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 안전과 관련된 시스템에서 이러한 기법은 위험한 방법으로 분류된다. 프로그램에서 이 저장공간을 예기치 못한 상태에서 사용하려고 할 수 있고, 병렬환경에서의 위험이 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_18_04</rule>
    <ruleTitle><![CDATA[유니온 타입 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 메모리 공간의 재사용은 데이터를 잘못 해석할 수 있는 위험이 있다. 따라서 어떤 목적으로라도 유니온의 사용을 금한다. <br/><br/>프로그램의 효율을 고려해서 설계할 때, 유니온 타입의 신중한 사용이 바람직한 상황이 존재하더라도, 유니온 타입은 사용하면 안 된다.<br/> 다음과 같은 부분에서, 컴파일러에 따라 다른 행동을 보인다.<br/><ul><li>padding - 유니온의 끝에 얼마나 많은 패딩이 추가 되는지</li><li>alignment - 유니온 내의 구조체 멤버들이 어떻게 정렬되는지</li><li>endianness - word의 최상위 바이트가 메모리 주소의 가장 낮거나 가장 높은 곳에 위치하는지</li><li>bit-order - bit가 byte 내에서 어떻게 정렬되는지, 그리고 어떻게 bit가 bit field로 할당되는지</li></ul> ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_19_01</rule>
    <ruleTitle><![CDATA[#include 앞에는 다른 preprocessor directive나 주석만 허용 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 모든 #include 문은 특정 코드 파일에서 파일의 head 근처에 그룹화 되어야 한다. 파일 내에에서 #include 앞에 올 수 있는 것은 preprocessor directive 또는 주석 뿐이다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_19_02</rule>
    <ruleTitle><![CDATA[헤더파일의 이름에 standard character가 아닌 것은 포함될 수 없음 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 만약 ', \, ", 또는 /* 문자가 헤더파일의 < 와 > 사이에서 사용된다면, 또는 " 사이에서 사용된다면, 정의되지 않은 행동을 할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_19_03</rule>
    <ruleTitle><![CDATA[#include 다음에 오는 형태는 " 파일명 " 나 <파일명> 이어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ #include 다음에 오는 형태 " 파일명 " 나 <파일명> 이어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_19_04</rule>
    <ruleTitle><![CDATA[C 매크로는 괄호 초기화문, 상수, 괄호 문장, 타입 지정자, 저장 클래스 지정자, do-while-zero 구조에 대해서만 확장해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C 매크로는 괄호 초기화문, 상수, 괄호 문장, 타입 지정자, 저장 클래스 지정자, do-while-zero 구조에 대해서만 허용된다. <br/>저장 클래스 지정자와 타입 한정자는 extern, static, const 등을 포함한다. 위에서 언급하지 않은 용도로 #define을 사용하는 경우, 매크로가 대체되었을 때 기대하지 않은 행동을 유발하거나 가독성이 떨어질 수 있다.<br/> 특정 매크로는 do-while 구조를 제외한 문장(statement)이나 문장의 한 부분을 정의하는데 사용될 수 없다. 또한 macro는 언어의 문법을 재정의 하면 안 된다. 매크로 내에서 타입과 상관 없이 모든 괄호는 짝이 맞아야 한다.<br/> do-while-zero 구조는 macro body에서 완전한 문장를 가지기 위하여 허용된 메카니즘이다. do-while-zero 구조는 하나 또는 여러 개의 문장 들을 둘러 싸는 형태로 사용 되며, 정확한 행동을 보장한다.(macro body의 끝에 세미콜론은 반드시 빠져야 한다.) ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_19_05</rule>
    <ruleTitle><![CDATA[블럭 내에서 #define, #undef 사용금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C에서는 #define이나 #undef를 코드 파일 내에 어디에 위치시키더라도 허용하지만, 블럭 내에 사용하는 것은 블럭 범위내로 한정된다고 오해할 수 있다. 보통 #define은 파일의 시작에, 첫 함수 정의 전에 사용한다. 보통 #undef는 사용할 필요가 없다.(Rule 19.6) ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_19_06</rule>
    <ruleTitle><![CDATA[#undef 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ #undef는 보통 필요하지 않다. #undef의 사용은 코드 안에서 매크로가 사용되었을때 매크로의 존재 여부 또는 매크로의 의미에 혼란을 가져올 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_19_07</rule>
    <ruleTitle><![CDATA[함수 형태의 매크로 대신 함수를 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 매크로가 함수에 비해서 속도가 빠르다는 장점이 있지만, 함수가 더욱 안전하고 견고한 메카니즘이다. 함수는 컴파일시 형식 인자의 타입 검사를 수행한다는 장점이 있다. 함수 매크로는 타입 검사를 수행하지 않고, 형식 인자를 여러 번 평가(evaluation)할 수 있다는 문제점도 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_19_08</rule>
    <ruleTitle><![CDATA[함수 매크로 사용시에 모든 인자를 전달해야함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 매크로의 인자는 적어도 하나의 preprocessing token으로 구성되어 있어야 한다. 보통의 경우에 컴파일러는 정확한 경고메시지를 출력하지만, 일부 전처리기는 이 문제를 무시하기도 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_19_09</rule>
    <ruleTitle><![CDATA[함수 매크로 사용시 인자 부분에 Preprocessor directive가 들어가면 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 만약 인자가 preprocessor directive처럼 행동한다면, 매크로가 대체되었을 때 그 행동은 예측하지 못한 결과를 가져올 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_19_10</rule>
    <ruleTitle><![CDATA[함수 매크로의 정의에서 각 형식 인자들은 괄호에 의해 감싸져야 함(단, #이나 ##의 피연산자로 사용하는 경우는 제외) ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 매크로의 정의에서 인자는 괄호로 감싸져야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_19_11</rule>
    <ruleTitle><![CDATA[모든 매크로 식별자는 사용되기 전에 defined 되었는지 검사(#ifdef, #ifndef, defined() 는 제외) ]]></ruleTitle>
    <ruleDesc><![CDATA[ 만약 preprocessor directive 내에서 어떤 식별자를 사용하려고 시도한다면, 그리고 그 식별자가 정의되지 않았다면, preprocessor는 경고하지 않고 값을 0으로 가정한다. #ifdef, #ifndef 그리고 defined()는 매크로의 존재를 검사하는데 사용하므로 제외된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_19_12</rule>
    <ruleTitle><![CDATA[하나의 매크로 정의 시 최대 한 번의 # 또는 ## 전처리 연산자가 사용되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ #과 ## 전처리 연산자와 관련된 평가 순서에 대해서는 표준에 명시되지 않았다. 이러한 문제를 피하기 위해서 하나의 매크로 정의 시 최대 한 번의 # 또는 ## 전처리 연산자가 사용되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_19_13</rule>
    <ruleTitle><![CDATA[# 또는 ## 과 같은 전처리 연산자 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ #과 ## 전처리 연산자와 관련된 평가 순서에 대해서는 표준에 명시되지 않았다. 컴파일러는 이러한 연산자를 사용하여 구현 시 일관성이 없다. 이러한 문제를 피하기 위하여 이들은 사용하면 안 된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_19_14</rule>
    <ruleTitle><![CDATA[Defined 전처리 연산자는 두 가지 표준 형태 중의 하나로 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 정의된 전처리 연산자의 두 가지 허용되는 형태는 다음과 같고, 이외는 정의되어 있지 않았으므로 사용한 경우에 그 결과를 결정할 수 없다: <ul><li>defind(식별자)</li><li>defined 식별자</li></ul> ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_19_15</rule>
    <ruleTitle><![CDATA[헤더 파일이 중복되어 include되는 것을 방지하기 위한 예방 조치가 되어있어야 함(#ifndef, #endif) ]]></ruleTitle>
    <ruleDesc><![CDATA[ 컴파일 단위(translation unit)가 중복된 헤더파일의 복잡한 계층으로 이루어져 있을 때, 특정 헤더 파일이 두 번 이상 include 되는 일이 발생한다. 이것은 개발자를 혼동하게 만들 수 있다. <br/>만약 그것이 여러 번의 정의로 인한 충돌을 일으킨다면 프로그램은 잘못된 결과를 나타낼 수 있다.<br/> 헤더 파일을 여러 번 포함하는 것은 신중한 코드 설계로 피할 수 있다. 만약 그것이 불가능 하다면 파일의 내용을 한 번 이상 include 하는 것을 예방하는 메카니즘을 사용할 수 있다. <br/>공통적인 접근 방식은 매크로를 각 파일에 적용하는 것이다. 이 매크로는 파일이 처음 include 되었을 때 정의되며, 이후에 파일이 다시 include 되려고 할 때, 파일의 내용을 차단하는데 사용된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_19_16</rule>
    <ruleTitle><![CDATA[Preprocessor directive가 전처리기에 의해서 제거되도 구조는 여전히 의미있어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 소스 코드의 한 부분이 전처리기에 의해 제외될 때, 각각의 제외된 문장(statement)은 #else, #elif, #endif를 만날 때 까지 무시 될 문장으로 인식한다. 만약 사용자의 실수로 이렇게 무시될 directive 중의 하나가 문법 오류를 포함하더라도, 이는 컴파일러에 의한 경고 없이 무시될 수 있다.<br/><br/> <b>이 규칙의 요구는 비록 제외된 코드의 블럭에서 발생된다고 하더라도 모든 preprocessor directive가 구문론적으로 타당해야 한다는 것이다.<br/> 특히 #else와 #endif 뒤에 공백이 아닌 어떤 문자가 오는지 확인해야 한다. 컴파일러는 이러한 ISO 요구에 대하여 항상 일관된 결과를 출력하지 않는다.</b> ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_19_17</rule>
    <ruleTitle><![CDATA[모든 #else, #elif, #endif는 이들과 관련있는 #if, #ifdef와 같은 파일 내에 위치해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 문장(statement)들을 컴파일에 포함할지 제외할지 여부를 directive에 의해 조절할 때, 만약 모든 관련된 directive가 한 파일 내에 있지 않으면 혼동이 생길 수 있다.<br/><br/><b>이 규칙은 #if / #ifdef ... #elif ... #else ... #endif로 이루어진 모든 preprocessor directive가 같은 파일 내에 존재하기를 요구한다.</b> ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_20_01</rule>
    <ruleTitle><![CDATA[표준 라이브러리에 예약된 식별자, 매크로 그리고 함수는 defined, redefined 또는 undefined 할 수 없음 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 표준 라이브러리에 정의된 매크로를 #undef 하는 것은 잘못된 습관이다. 표준 라이브러리에 정의된 매크로, 객체 또는 함수의 이름이나 예약된 식별자를 매크로 이름으로 정의하는 것 또한 잘못된 습관이다. 예를 들어 defined, __LINE__, __FILE__, __DATE__, __TIME__, __STDC__, errno, assert 처럼 재 정의 또는 정의 취소 되었을 때 정의되지 않은 행동을 할 수 있는 특정 단어나 함수의 이름이 존재한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_20_02</rule>
    <ruleTitle><![CDATA[표준 라이브러리에 있는 매크로, 객체, 함수들의 이름의 재사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 표준 라이브러리 매크로, 객체 또는 함수의 새로운 버전이 프로그래머에 의해 수정되어 사용되면, 수정된 매크로, 객체 도는 함수는 새로운 이름을 가져야 한다. 이는 표준 매크로, 객체 또는 함수인지 수정된 버전인지 혼동하는 것을 막기 위함이다. 그래서 예를 들면, 만약 sqrt 함수의 새로운 버전에 input이 음수가 아닌 지를 체크하는 부분이 추가된다면, 새로운 함수의 이름은 "sqrt"가 아닌 새로운 이름으로 지어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_20_03</rule>
    <ruleTitle><![CDATA[라이브러리 함수에 전달되는 인자 값이 올바른지 검사해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 표준 C 라이브러리의 많은 함수들은 ISO 표준에 의한 형식 인자의 유효성을 검사하지 않는다. 표준에 의해 검사 하거나 컴파일러 개발자가 형식 인자의 유효성을 검사한다고 하더라도, 적절한 검사가 이루어졌는지 보장할 수는 없다. 그러므로 프로그래머는 제한된 입력 범위를 갖는 모든 라이브러리 함수를 위한 입력 값의 적절한 검사를 제공해야 한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_20_04</rule>
    <ruleTitle><![CDATA[동적 힙 메모리 할당 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 이는 calloc, malloc, realloc 그리고 free 함수의 사용을 금지하는 규칙이다. 다른 수많은 잠재적인 위험과 마찬가지로 동적 메모리 할당과 관련된 구체화 시, 정의 시, 구현 시 정의 되지 않은 행동이 존재한다. 동적 힙 메모리 할당은 메모리 누수, 데이터 불일치, 메모리 고갈, 결정되지 않은 행동을 가져올 수 있다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_20_05</rule>
    <ruleTitle><![CDATA[에러 지시자(error indicator) "errno" 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ "errno"의 사용은 이론적으로 유용한 C의 기능이다. 그러나 실제로 표준에서 거의 사용되지 않는다. "error" 값이 0이 아니면, 문제가 발생했을수도 아닐 수도 있으므로 사용하지 않는 것이 좋다. 비록 "errno"의 행동이 잘 정의되어있다고 해도, 에러를 잡기 위해 "errno"를 사용하기 보다는 함수 호출 전에 입력 값을 검사하는 것을 더욱 권장한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_20_06</rule>
    <ruleTitle><![CDATA[stddef.h 의 매크로 'offsetof' 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 피연산자의 타입이 호환되지 않거나 bit field가 사용되는 경우, offsetof의 사용은 정의되지 않은 행위를 유발할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_20_07</rule>
    <ruleTitle><![CDATA[Longjmp 함수와 setjmp 매크로 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Longjmp와 setjmp는 일반적인 함수 호출 메카니즘을을 지나치는 것을 허용하게 한다. 따라서 사용하면 안 된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_20_08</rule>
    <ruleTitle><![CDATA[signal.h 의 신호 처리 기능 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 신호 처리는 실행 시 정의되는 부분을 포함하고 있으며, 정의되지 않은 행위를 유발한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_20_09</rule>
    <ruleTitle><![CDATA[입/출력 라이브러리인 stdio.h 는 제품 코드에서 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 이 라이브러리는 파일과의 input, output을 처리하는 함수 fgetpos, fopen, ftell, gets, perror, remove, rename, 그리고 ungetc를 포함한다.<br/> stream과 파일의 I/O는 그와 연관된 구체적이지 않은, 정의되지 않은, 실행 시 정의되는 수많은 행위를 포함한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_20_10</rule>
    <ruleTitle><![CDATA[stdlib.h 의 함수 atof, atoi, atol 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 위에 언급한 함수들은 string이 변환 되지 않을 때 그와 연관된 정의되지 않은 행동을 유발한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_20_11</rule>
    <ruleTitle><![CDATA[라이브러리 stdlib.h 의 함수 abort, exit, system, getenv 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 위에 언급한 함수들은 보통 시스템 환경과 연계할 필요가 없는 임베디드 시스템에서 요구된다. 만약 이 함수가 application에서 꼭 필요하다면, 함수의 구현 시 정의되는 행동을 검사할 필요가 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_20_12</rule>
    <ruleTitle><![CDATA[라이브러리 time.h 의 시간 조작 함수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Time, strftime을 포함한 이 라이브러리는 시간과 연관이 있다. 이 라이브러리는 구현 의존적인 면이 많아 이식성을 해친다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2004</ruleSetName>
    <ruleSetDesc><![CDATA[MISRA C:2004 Guidelines for the use of the C language in critical systems - MISRA(The Motor Industry Software Reliability Association)]]></ruleSetDesc>
    <rule>MISRA_21_01</rule>
    <ruleTitle><![CDATA[런타임 오류를 최소화하기 위해 적어도 다음 중 한 가지 방법을 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 런타임 오류를 최소화할 수 있는 방법들은 다음과 같다.<br/><ul><li>(a) 정적 분석 도구/기법 활용</li><li>(b) 동적 분석 도구/기법 활용</li><li>(c) 런타임 오류를 처리하기 위한 방어적 코딩</li></ul> ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_AMD</ruleSetName>
    <ruleSetDesc><![CDATA[Additional security guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_12_05</rule>
    <ruleTitle><![CDATA[sizof 연산자는 배열로 선언된 함수 파라미터를 피연산자로 사용하면 안됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
아래의 코드에서 sizeof 연산자는 배열 A의 요소 수를 확인하는데 사용된다.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;size_t arraySize = sizeof( A ) / sizeof ( A[0] );<br/>
<br/>
이는 A가 배열로 지정된 식별자일 때, 배열 타입이므로 예상대로 동작한다.<br/><br/>

&nbsp;&nbsp;&nbsp;&nbsp;void f ( int32_t A[4] );<br/><br/>

그러나 위의 코드와 같이 함수 파라미터인 경우에는 그렇지 않다. <br/>
표준에서는 함수 파라미터는 배열 타입을 가지지 않고, 배열로 선언된 함수 파라미터는 포인터 타입으로 변경시킨다.  <br/>
이는 sizeof( A )는 sizeof( int32_t * )과 동일하며, 배열의 크기를 반환하지 않는다.<br/>
이는 A가 배열로 지정된 식별자일때, 배열 타입이므로 예상대로 동작한다.<br/><br/>

]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_AMD</ruleSetName>
    <ruleSetDesc><![CDATA[Additional security guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_21_13</rule>
    <ruleTitle><![CDATA[cype.h 내 함수에 사용되는 모든 값은 unsigned char 또는 EOF로 표현되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

ctype.h 내 관련 함수는 int 타입의 인자를 가지지만, 그 값이 unsigned char의 범위 내에 있거나 EOF 값을 가지기를 기대한다.
<br/>
그 외 다른 값이 인자로 사용될 경우 undefined behavior가 발생한다.<br/><br/>


<span style="color:#B73232">See also</span> &nbsp;Rule 10.3<br/>]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_AMD</ruleSetName>
    <ruleSetDesc><![CDATA[Additional security guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_21_14</rule>
    <ruleTitle><![CDATA[null terminator로 끝나는 문자열을 표준 라이브러리 함수 memcpm에 사용하면 안됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

표준 라이브러리 함수
<br/>
int memcmp ( const void *s1, const void *s2, size_t n );
<br/> 
는 s1과 s2의 참조된 두 객체의 첫 번째 byte부터 n 개의 비교를 수행한다
<br/><br/>

n보다 작은 길이의 두 문자열을 비교하는데 사용되면, 논리적으로는 두 문자열이 같을지라도 memcmp는 다른 값이라고 비교할 것이다.
<br/>

<span style="color:#B73232">See also</span> &nbsp;Rule 21.15, Rule 21.16<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_AMD</ruleSetName>
    <ruleSetDesc><![CDATA[Additional security guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_21_15</rule>
    <ruleTitle><![CDATA[표준 라이브러리 함수 memcpy, memmove, memcmp의 포인터 인자는 서로 호환 가능한 타입이어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Traslation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

표준 라이브러리 함수
<br/><br/> 
void * memcpy ( void * restrict s1, const void * restrict s2, size_t n );
<br/> 
void * memmove ( void * s1, const void * s2, size_t n );
<br/> 
int memcmp ( const void * s1, const void * s2, size_t n );
<br/> <br/> 
는 두 포인터 s1, s2가 가리키는 객체의 첫 바이트부터 n 개에 대해 비교, 복사, 이동을 수행한다.
<br/>
서로 다른 두 타입의 인자를 사용하여 이 함수들을 호출하는 경우 이는 실수일 가능성이 높다.
<br/><br/>

<span style="color:#B73232">See also</span> &nbsp;Rule 21.14, Rule 21.16<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_AMD</ruleSetName>
    <ruleSetDesc><![CDATA[Additional security guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_21_16</rule>
    <ruleTitle><![CDATA[표준 라이브러리 함수 memcmp에 대한 포인터 인수는 포인터 유형, essentially signed type, essentially unsigned type, essentially Boolean type 또는 essentially enum type을 가리켜야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Traslation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

표준 라이브러리 함수<br/>
void * memcpy ( void * restrict s1, const void * restrict s2, size_t n );<br/> 
s1과 s2가 가리키는 두 객체의 첫 번째 n 바이트를 바이트 단위로 비교 동작한다.<br/><br/>

memcmp를 사용하여 구조체를 비교해서는 안 된다.<br/>
멤버가 같은 값을 가지고 있어도 두 구조체가 같지 않다고 잘못 판단하기도 하며,<br/>
구조체는 멤버 사이에 불확정 값을 가진 padding이 포함될 수 있고 memcmp는 이를 비교 대상에 포함한다.<br/>
구조체 멤버들이 같아도 padding이 같다고 판단할 순 없다.<br/><br/>
Union은 다른 중복된 멤버의 표현이 우연히 같을 때 동일한 값을 갖는 것으로 잘못 판단될 수 있다.<br/>
서로 다른 두 타입의 인자를 사용하여 이 함수들을 호출하는 경우 이는 잘못 판단될 가능성이 높다.<br/>
<br/><br/>

<span style="color:#B73232">See also</span> &nbsp;Rule 21.14, Rule 21.15<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_AMD</ruleSetName>
    <ruleSetDesc><![CDATA[Additional security guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_21_17</rule>
    <ruleTitle><![CDATA[string.h의 문자열 처리 함수의 사용으로 인해 매개 변수 포인터에 참조된 객체의 경계를 넘어 접근이 발생해서는 안됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

string.h의 관련 문자열 처리 함수는 다음과 같다:<br/>
strcat, strchr, strcmp, strcoll, strcpy, strcspn, strlen, strpbrk, strrchr, strspn, strstr, strtok<br/><br/> 
위에 나열된 함수를 잘못 사용하면 매개 변수로 전달된 객체의 경계를 벗어난 읽기 또는 쓰기 액세스가 발생하여 정의되지 않은 동작이 발생할 수 있다.<br/>
]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_AMD</ruleSetName>
    <ruleSetDesc><![CDATA[Additional security guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_21_18</rule>
    <ruleTitle><![CDATA[string.h의 함수에 전달된 size_t 인자는 적절한 값을 가져야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

&lt;string.h&gt;의 다음과 같은 함수는 적절한 값을 가져야한다 : <br/>
memchr, memcmp, memcpy, memmove, memset, strncat, strncmp, strncpy, strxfrm<br/>
 - 양수<br/>
 - 포인터 parameter로 함수에 전달된 가장 작은 객체보다 크기가 크면 안 된다.<br/><br/>

위에 언급한 함수를 잘못 사용하면 매개변수로 전달된 객체의 경계를 벗어난 쓰기나 읽기로 인해 undefined behaviour가 발생할 수 있다.<br/><br/>

<span style="color:#B73232">See also</span> &nbsp;Rule 21.17]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_AMD</ruleSetName>
    <ruleSetDesc><![CDATA[Additional security guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_21_19</rule>
    <ruleTitle><![CDATA[표준 라이브러리 함수 localeconv, getenv, setlocale or, strerror은 const 한정자 타입의 포인터만 가지는 것처럼 사용되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

localeconv 함수는 struct lconv * 타입의 포인터를 반환한다. 이 포인터는 const struct lconv *로 간주되어야 한다. 
struct lconv 객체는 char * 타입을 포함하고 getenv, setlocale, strerror 함수는 가각 char* 타입을 반환한다. 포인터들은 문자열에 접근하는데 사용되어진다.(null로 끝나는 char 배열) 해당 규칙의 목적은 이러한 포인터들을 const char *로 간주하는 것이다.<br/><br/>

표준에서는 프로그램이 수정되는 경우 undefined behaviour가 발생함을 나타낸다.<br/>
- localeconv에 의해 반환된 값의 구조체 포인터<br/>
- getenv, setlocale 또는 strerror에 의해 반환된 문자열<br/><br/>
<b>참조</b> 표준은 localedconv에 의해 반환된 값이 가리키는 구조체에 의해 참조되는 문자열이 수정되어지는 경우 특정 행동을 지정하지 않는다. 해당 룰은 문자열들이 바람직하지 않은 문자열로 변경되는 것을 금지한다.<br/><br/>

다양한 함수에 의해 반환된 포인터를 const 한정자인 것처럼 허용해야 하고 분석기는 포인터를 통해 오브젝트를 수정하려는 시도를 감지해야 한다. 추가적으로, const 한정자 포인터에 함수의 반환값을 할당하면 객체를 수정하려고 하면 컴파일러가 진단 메세지를 출력한다.
<br/><br/>
<b>참조</b> 수정된 버전이 필요하다면 프로그램은 규칙이 적용되는 모든 값의 사본을 작성하고 수정해야 한다.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 7.4, Rule 11.8, Rule 21.8]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_AMD</ruleSetName>
    <ruleSetDesc><![CDATA[Additional security guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_21_20</rule>
    <ruleTitle><![CDATA[표준 라이브러리 함수 asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale 또는 strerror에 의해 반환되는 포인터는 동일한 함수를 뒤에 호출한 경우 사용되어서는 안 됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<br/>
setlocale를 호출하면 이전에 localeconv를 통해 반환한 값을 변경할지도 모른다. 이 규칙의 목적상, setlocale과 localeconv 함수는 같은 함수인 것처럼 사용되어야 한다.<br/>
표준 라이브러리 함수 asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale 또는 strerror는 표준 라이브러리에 대한 객체를 포인터로 반환한다. 
구현시 이러한 객체 중 하나에 정적 버퍼를 사용할 수 있으며 동일한 함수에 대한 두 번째 호출은 버퍼의 내용을 수정할 수 있다. 
함수에 대한 후속 호출 전에 프로그램에서 가지고 있는 포인터를 통해 액세스 한 값이 예기치 않게 변경 될 수 있다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_AMD</ruleSetName>
    <ruleSetDesc><![CDATA[Additional security guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_22_07</rule>
    <ruleTitle><![CDATA[매크로 EOF는 EOF를 반환하는 표준 라이브러리 함수의 수정되지 않은 반환 값으로만 비교 되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

함수의 리턴 값은 나중에 매크로 EOF와 비교될 경우 형식 변환의 대상이 되지 않아야 함. 
<br/><br/> 
이러한 함수에서 파일 끝 또는 읽기 또는 쓰기 오류가 발생했음을 나타내는데  EOF 반환 값으로 사용된다.<br/>
반환된 값이 다른 타입으로 변환되면 EOF 값이 유효한 문자 코드와 구별되지 않을 수 있다. <br/> 
이 경우 변환된 값을 EOF에 대조할 경우 파일 끝에 도달했는지 또는 오류가 발생했는지를 확실하게 식별하지 못해 값이 변경되기 전 EOF와 비교해야 한다.<br/> 
또는 표준 라이브러리 함수인 feof와 ferror를 사용하여 변환이 발생하기 전이나 후에 스트림의 상태를 직접 확인할 수 있다.<br/> ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_AMD</ruleSetName>
    <ruleSetDesc><![CDATA[Additional security guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_22_08</rule>
    <ruleTitle><![CDATA[errno의 값은 errno-setting-function을 호출하기 전에 0으로 설정되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<br/>
다음과 같은 함수들이 error-setting-fuction이다:<br/>
ftell, fgetpos, fsetpos, fgetwc, fputwc, strtoimax, strtomax, strtol, strtoul, strtoll, strtoull, strtof, strtod, strtold, wcstoimax, wcstoumax, wcstol, wcstoul, wcstoll, wcstoull, wcstof, wcstod, wcstold, wcrtomb, wcsrtombs, mbrtowc<br/><br/>

errno를 사용하여 오류 정보를 반환하는 다른 함수도 errno-setting-function이다. <br/>
<b>참조</b> 여기에는 표준에서 허용하는 표준 라이브러리의 추가 기능이 포함될 수 있다.<br/><br/>

"prior"는 동일한 함수와 errno-setting-function을 호출하는 모든 경로에서 errno가 0으로 설정되어야 한다. 게다가 이 경로에서 errno를 지정하는 함수를 호출할 수 없다.  이것은 errno를 설정하도록 허용된 표준 라이브러리 내의 모든 함수에 대한 호출을 포함한다.
<br/><br/>
 
errno-setting-function은 에러가 발견되면 errno에 0이 아닌 값을 쓰고 그렇지 않으면 값을 수정하지 않은 채로 둔다. 표준에는 비표준 조언이 포함되어 있다. "오류 검사를 위해 errno를 사용하는 프로그램은 라이브러리 함수 호출 전에 0으로 설정해야 하며 이후 라이브러리 함수 호출 전에 검사해야 한다"
<br/>
오류가 탐지될 수 있도록 이 규칙은 errno-setting-function이 호출되기 전에 errno가 0으로 설정되어야 한다고 규정하고 있다.
<br/><br/>
 

<b>예외사항</b><br/>
errno의 값이 0으로 판명될 때 0으로 설정할 필요는 없다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_AMD</ruleSetName>
    <ruleSetDesc><![CDATA[Additional security guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_22_09</rule>
    <ruleTitle><![CDATA[errno의 값은 errno 설정 함수가 호출된 후 바로 테스트되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
errno 설정 함수는 에러를 감지하면 errno에 0이 아닌 값을 기록하고, 그렇지 않으면 값을 기록하지 않고 남겨둔다.

표준은 비규범적인 내용(에러 확인을 위해 errno를 사용하는 프로그램은 해당 함수가 호출되기 전에 errono의 값을 0으로 설정하여야 하고,  다른 함수가 호출되기 전에 검사해야 한다)을 포함한다.
<br/>
errno 설정 함수에 의해 반환된 값은  errno가 0으로 설정되지 않았을 경우 정확하지 않을 수 있기 때문에, 프로그램은 반환된 값을 적절하게 사용하기 위함을 보장하기 위해 errno의 값을 확인해야 한다.
<br/><br/>
<span style="color:#B73232">Exception</span><br/>
errno 설정 함수의 반환 값이 에러가 발생했는지 여부를 확인할 수 있으면,  errno의 값은 확인하지 않아도 된다.


<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 22.9, Rule 22.10<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_AMD</ruleSetName>
    <ruleSetDesc><![CDATA[Additional security guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_22_10</rule>
    <ruleTitle><![CDATA[errno의 값은 호출된 마지막 함수가 errno 설정 함수일 때만 테스트되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
errno 설정 함수는 에러가 발생했을 때 errno의 값을 설정하는 유일한 함수이다.
<br/>
표준 라이브러리에 정의된 함수를 포함한 다른 함수들은 에러가 발생하더라도 errno 값을 설정하지 않을 것이다.
<br/>
때문에 이러한 함수들의 에러를 감지하기 위한 errno의 사용은 errno을 값은 변경하지 않기 때문에 실패할 것이다.
<br/>
 

값이 0인 errno는 errno 설정 함수가 아닌 함수 내에서 오류가 없다는 것을 보장하지 않고, 그 값은 시험되지 말아야 한다.




<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 22.8, Rule 22.9<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_DIR</ruleSetName>
    <ruleSetDesc><![CDATA[Additional directive guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_DIR_01_01</rule>
    <ruleTitle><![CDATA[프로그램의 산출 결과와 관련된 implementation-defined behavior는 문서화되고 이해할 수 있어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br><span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>
<br>

프로그램의 출력은 의도적이고 우연히 생산된 것이 아님을 아는 것이 중요하다.<br/>
안전에 관련된 임베디드 소프트웨어에서 implementation-defined behavior들은 아래에 설명을 따르는 경향이 있다.<br/><br/>

<b> 주요 동작</b><br/><br/>
 대부분 프로그램에서 요구되는 경향이 있는, 구현시 정의된 기본적인 implementation-defined behavior 들은 다음을 포함한다:<br/>
&nbsp;&nbsp;- 코드 번역 시 출력된 진단 메시지를 어떻게 확인할 것인가;<br/>
&nbsp;&nbsp;- freestanding 구현환경에서의 main 함수의 타입( 보통은 void main(void) );<br/>
&nbsp;&nbsp;- 식별자에서 구분 가능한 character의 개수 --> Rule 5.2로 커버<br/>
&nbsp;&nbsp;- 소스와 실행 character 집합<br/>
&nbsp;&nbsp;- Integer 타입의 크기<br/>
&nbsp;&nbsp;- 어떤 방식으로 #include의 이름이 파일 이름과 호스트 파일 시스템의 위치에 매핑되는가<br/><br/>


<b>확장</b><br/><br/>
확장은 임베디드 시스템에서 주변 장치에 대한 액세스를 제공하고, Flash EEPROM 또는 고속 액세스 RAM과 같은 특수 속성을 사용하여 개체를 메모리 영역에 배치하는데 자주 사용된다.<br/>
표준을 준수하는 구현체는 엄격하게 프로그램의 의미를 변경시키지 않는 한 확장을 제공 할 수 있다.<br/><br/>
구현체가 확장을 제공할 수 있는 방법은 다음과 같다:<br/>

&nbsp;&nbsp;- #pragma ppd 또는 _Pragma 연산자<br/>
&nbsp;&nbsp;- 새로운 키워드<br/><br/>

<b>표준 라이브러리</b><br/><br/>
표준 라이브러리 구현의 몇몇 측면에서 중요한 점은:<br/>
&nbsp;&nbsp;- 어떤 표준 라이브러리 함수가 사용될 때, errno로의 값 할당<br/>
&nbsp;&nbsp;- clock 과 time 함수의 구현<br/>
&nbsp;&nbsp;- 파일 시스템의 특징(characteristic)<br/><br/>

<b>어플리케이션 바이너리 인터페이스(ABI)
</b><br/><br/>
때로는 어셈블리어와 함께 C 코드 인터페이스가 필요하다. 예를 들면 중요한 위치에서 실행 속도를 늘리는데에 필요하다.<br/>
또한, 다른 컴파일러 또는 가능하다면 다른 언어로 생성된 코드 인터페이스가 필요할 때가 있다.<br/>
컴파일러를 위한 ABI는 아래와 같은 일들을 처리하기 위해 필요한 정보들을 제공하는데, <br/>
이러한 정보 중에는 implementation-defined behavior 도 포함되어 있다.<br/>
&nbsp;&nbsp;- 레지스터와 스택에서 함수 파라미터가 어떻게 통과하는지<br/>
&nbsp;&nbsp;- 함수 값이 어떻게 반환되는지<br/>
&nbsp;&nbsp;- 어떤 레지스터가 함수에 의해 보존되어야 하는지<br/>
&nbsp;&nbsp;- 어떻게 automatic storage duration을 가진 오브젝트가 스택 프레임에 할당되는지<br/>
&nbsp;&nbsp;- 각각 데이터 타입을 위한 정렬 요구사항<br/>
&nbsp;&nbsp;- 어떻게 structure가 배치되었는지, 어떻게 비트필드가 스토리지 유닛에 할당되는지<br/>
몇몇 프로세서는 모든 구현에 사용되는 표준 ABI를 가진다. 이러한 표준이 없는 경우에, 구현은 그 자신만의 표준을 제공할 것이다.<br/><br/>

<b>정수 나눗셈</b><br/><br/>
&nbsp;&nbsp;- 피연산자가 음수 값인 부호있는 정수 나눗셈 또는 나머지 연산은 내림 또는 버림을 할 수 있다. C99에서, 반올림은 0이 되도록 보장하고 있다.<br/><br/>

<b>Floating-point 구현</b><br/><br/>
Floating-point 타입의 구현은 프로그램 동작에 따라 중요한 영향이 있다. 예를들어<br/>
&nbsp;&nbsp;- 값의 범위 그리고 정확도<br/>
&nbsp;&nbsp;- 소수점 연산이 따르는 반올림의 방향<br/>
&nbsp;&nbsp;- 더 작은 크기의 소수점 또는 정수 타입으로 변환되었을 때 반올림의 방향<br/>
&nbsp;&nbsp;- 언더플로우, 오버플로우, NaNs에서의 동작<br/>
&nbsp;&nbsp;- 도메인과 범위 오류가 발생한 경우의 라이브러리 함수의 동작<br/><br/>
<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 5.1, Rule 5.2<br>]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_DIR</ruleSetName>
    <ruleSetDesc><![CDATA[Additional directive guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_DIR_02_01</rule>
    <ruleTitle><![CDATA[모든 소스파일은 컴파일 에러 없이 컴파일되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
표준에 적합한 컴파일러(conforming compiler)는 컴파일 에러가 발생하더라도 객체 모듈 생성을 허용한다. 그러나, 프로그램 실행 결과는 unexpected behaviour를 가져올 수 있다.<br/><br/>

<span style="color:#B73232">See also</span> &nbsp;Rule 1.1<br/>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_DIR</ruleSetName>
    <ruleSetDesc><![CDATA[Additional directive guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_DIR_04_01</rule>
    <ruleTitle><![CDATA[런타임 오류는 최소화해야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br><span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>
<br>

  C언어는 매우 제한된 빌트인 런타임 체크를 제공하도록 디자인되었다. 이러한 접근이 가볍고 빠른 실행 가능한 코드를 생성하는데 도움이 되지만, 런타임 체크는 프로그래머가 직접 해야 한다는 부담이 있다. 원하는 만큼의 프로그램 견고함을 위해, 프로그래머가 신중하게 고려해서 런타임 에러가 발생할만한 위치에 동적 체크를 추가하는 것이 중요하다.<br><br>

  때로는 피연산자의 값이 표현식 evaluation 과정에서 런타임 에러가 발생하지 않음을 증명 가능할 때도 있다. 이러한 경우에는 문서화할 필요가 없다. 이런 종류의 정보들은 인자에 의존한다는 가정을 포함해야 한다. 이러한 정보는 인자의 남은 값을 확실히 하기 위한 코드를 이후에 수정할 때 사용할 수 있다.<br><br>

런타임 오류를 최소화하는 데 사용될 기법, 예를 들어 설계 표준, 테스트 계획, 정적 분석 및 코드 리뷰 등은 계획하고 문서화해야 한다. 이러한 기법의 특성은 프로젝트의 무결성 요구 사항에 따라 달라질 수 있다.<br>
<br>


다음의 참고사항은 동적검사 수행 시 고려해야 할 사항에 대한 지침이다.<br/><br/>

&nbsp;&nbsp;-산술 오류 - 오버플로우, 언더플로우, 0으로 나누기, shiting으로 부호 값 손실과 같은 수식의 평가 도중 발생하는 에러를 포함한다.<br/>
&nbsp;&nbsp;-포인터 연산 - 주소가 동적으로 계산될 때, 그 주소는 합리적이고 의미가 있음을 보장해야 한다.  특히 포인터가 배열을 가리키고, 그 포인터를 증가하거나 감소시킬 때에도 그 배열 안의 요소를 가리켜야 한다. <br/>
&nbsp;&nbsp;-배열 바운드 오류 - 배열 인덱스를 사용하기 전에 배열 크기 내에 있음을 보장해야 한다.<br/>
&nbsp;&nbsp;-함수 파라미터 - 라이브러리 함수에 인자를 전달하기 전에 인자의 유효성에 대해 검사해야 한다.<br/>
&nbsp;&nbsp;-포인터 역 참조 - 포인터가 이미 NULL이 아닌 것으로 알려진 경우가 아니면 해당 포인터를 역 참조하기 전에 런타임 검사를 수행해야 한다.<br/>
&nbsp;&nbsp;-동적 메모리 - 동적 메모리 할당이 수행되는 경우, 각 할당이 성공하였는지, 그렇지 않은 경우 적절한 복구 전략이 설계되고 테스트 되는지 확인해야 한다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Dir 4.11, Dir 4.12, Rule 1.3, Rule 18.1, Rule 18.2, Rule 18.3<br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_DIR</ruleSetName>
    <ruleSetDesc><![CDATA[Additional directive guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_DIR_04_02</rule>
    <ruleTitle><![CDATA[모든 어셈블리어의 사용은 문서화되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
어셈블리 언어의 사용에 대한 이론적 근거와 C와 어셈블리 언어 간의 인터페이스 메커니즘은 문서화 되어야 함.<br/><br/>
어셈블리 언어 코드는 구현에 따라 정의되므로 portable 할 수 없다.]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_DIR</ruleSetName>
    <ruleSetDesc><![CDATA[Additional directive guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_DIR_04_03</rule>
    <ruleTitle><![CDATA[어셈블리어는 캡슐화되고 분리되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
어셈블리 명령어가 사용되는 곳에서는 캡슐화되고 격리되어야 한다.<br/>
- 어셈블리 언어 함수<br/>
- C 함수 (c99에 대해 선호되는 인라인 함수)<br/>
- C 매크로<br/><br/>

효율성 때문에 간단한 어셈블리 언어 명령어를 인라인으로 내장해야하는 경우가 있다. 예를 들면 인터럽트를 활성화 및 비활성화하기 위해 이것이 필요한 경우에는 매크로를 사용하거나 c99 인라인 함수를 사용하여 수행하는 것이 좋다.<br/><br/>

assembly language를 캡슐화하면 다음과 같은 이점이 있다.<br/>
- 가독성을 향상<br/>
- 매크로 또는 함수를 캡슐화한 이름 및 설명서는 어셈블리 언어의 의도를 명확하게 만든다.<br/>
- 주어진 목적을 위해 어셈블리어를 모두 사용하면 캡슐화를 공유 할 수있어 유지 보수성이 향상된다.<br/>
- 어셈블리어는 다른 대상이나 정적 분석의 목적으로 대체 될 수 있다.<br/><br/>

<b>참조</b> 인라인 어셈블리 언어의 사용은 표준 C에 대한 확장이므로 규칙 1.2를 준수함
]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_DIR</ruleSetName>
    <ruleSetDesc><![CDATA[Additional directive guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_DIR_04_04</rule>
    <ruleTitle><![CDATA[코드 섹션 주석 처리 금지]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
소스 코드 섹션이 컴파일되지 않도록 요구되는 곳은 조건부 컴파일을 사용하여 소스 코드를 구현해야 함.
(예 : #if 또는 #ifdef가 주석으로 구성됨)
<br/><br/>
C는 중첩 된 주석을 지원하지 않으므로 코드 섹션에 이미있는 주석의 기능을 변경하기 때문에 이 목적으로 시작 및 끝 주석 표시자를 사용하는 것은 위험하다.<br/><br/>

<span style="color:#B73232">See also</span> &nbsp;Rule 3.1, Rule 3.2<br/>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_DIR</ruleSetName>
    <ruleSetDesc><![CDATA[Additional directive guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_DIR_04_05</rule>
    <ruleTitle><![CDATA[같은 네임스페이스에 있는 식별자는 혼동되지 않는 문자를 사용해야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br><span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

문자열 셋을 표시하는 폰트에 따라 서로 다른 문자이지만 동일한 문자처럼 보일 수 있다. <br/>
이로인해 개발자는 식별자를 다른 이름의 식별자와 혼동할 수 있다..<br><br>

영어 단어로 사용된 라틴 알파벳에 대해서, 식별자는 다음의 조합으로 구별되어서는 안된다<br><br>
&nbsp;&nbsp;-소문자와 해당 대문자<br>
&nbsp;&nbsp;-밑줄 문자의 유무<br>
&nbsp;&nbsp;-문자 'O'와 숫자 '0'<br>
&nbsp;&nbsp;-문자 'I' 와 숫자 '1'<br>
&nbsp;&nbsp;-문자 'I' 와 문자 'l' ( L의 소문자 )<br>
&nbsp;&nbsp;-문자 'S'와 숫자 '5'<br>
&nbsp;&nbsp;-문자 'Z'와 숫자 '2'<br>
&nbsp;&nbsp;-문자 'n'과 문자 'h'<br>
&nbsp;&nbsp;-문자 'B'와 숫자 '8'<br>
&nbsp;&nbsp;-문자열 'rn'과 문자 'm'<br>
]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_DIR</ruleSetName>
    <ruleSetDesc><![CDATA[Additional directive guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_DIR_04_06</rule>
    <ruleTitle><![CDATA[크기와 부호를 나타내는 typedefs는 basic numerical type 대신에 사용되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
char, short, int, long, long long(C99), float, double, and long double 과 같은 basic numerical types은 사용되면 안되고 특정 길이로 typedefs 후 사용되어야 한다.<br/>
C99에서 &lt;stdint.h&gt;에 적용된 타입은 사용할 수 있다. C90에서는 equivalent 타입은 정의되고 사용되어져야 한다.<br/>
구현된 타입의 특정 길이가 실제 길이와 다르다면 타입을 특정 길이로 정의하면 안된다. 비트 필드에서는 typedefs로 선언할 필요가 없다.<br/><br/>

<b>예외사항</b>
- typedef로 특정 길이의 타입으로 정의된 basic numerical types은 허용<br/>
- main 함수의 반환 타입의 int형<br/>
- main 함수의 매개변수로 사용된 argc의 int형<br/>
- main 함수의 매개변수로 사용된 argv의 char형<br/>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_DIR</ruleSetName>
    <ruleSetDesc><![CDATA[Additional directive guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_DIR_04_07</rule>
    <ruleTitle><![CDATA[함수가 에러정보를 반환하면, 그 에러정보는 테스트 되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br><span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>
함수 (표준 라이브러리, 제3 자 라이브러리 또는 사용자 정의 함수의 일부이든)는 오류의 발생을 나타내는 몇 가지 수단을 제공하는 것으로 간주될 수 있다.

이것은 오류 플래그, 일부 특수 반환 값 또는 다른 수단을 통해 발생할 수 있다.<br/>

이러한 메커니즘을 제공하는 함수를 호출하는 프로그램은 함수가 값을 반환 한 직후 오류 정보를 확인해야 한다.<br/><br/>

그러나 함수에 대한 입력 값 검사는 함수가 완료된 후에 오류를 탐지하는 것보다 오류 방지 수단이 더 강건한 것으로 간주된다.<br/><br/>


<span style="color:#B73232">Exception</span> <br/>
함수가 오류 표시를 리턴할 수 없다는 것을 보장할 수 있다면( 예를 들어, 함수에 사용되는 인자를 검사 ) 검사를 수행할 필요가 없다.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Dir 4.11, Rule 17.7<br>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_DIR</ruleSetName>
    <ruleSetDesc><![CDATA[Additional directive guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_DIR_04_08</rule>
    <ruleTitle><![CDATA[구조체 또는 공용체를 역참조하지 않는 한 객체 구현을 숨겨야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
객체의 구현은 불완전한 유형에 대해 포인터를 사용하여 숨겨야 함.
<br/><br/>
객체의 구현 세부 정보가 필요하지 않으며 구조체 또는 공용체에 대한 포인터가 역 참조되지 않는 경우, 의도하지 않은 변경으로부터 해당 내용을 보호해야 한다.<br/><br/>

구현 세부 사항을 숨기면 포인터를 통해 참조 될 수 있지만 내용에 액세스할 수 없는 Opaque Type이 만들어지게 된다.<br/><br/>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_DIR</ruleSetName>
    <ruleSetDesc><![CDATA[Additional directive guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_DIR_04_09</rule>
    <ruleTitle><![CDATA[함수는 매크로 함수보다 우선 사용해야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
객체의 구현은 불완전한 유형에 대한 포인터를 사용하여 숨겨야 함.
<br/><br/>
대부분의 경우 매크로 대신 함수를 사용해야 한다.<br/>
함수는 인수 형식 검사를 수행하고 인수를 한 번 평가하므로  잠재적인 부작용을 피할 수 있다. 
또한, 많은 디버깅 시스템에서 매크로를 실행하는 것보다 함수를 실행하는 것이 더 쉬울 수 있다.<br/><br/>

그럼에도 불구하고 어떤 상황에서는 매크로가 유용할 수 있다.<br/><br/>

함수 또는 매크로 중 무엇을 사용할지 결정할 때 고려해야 할 몇 가지 요소는 다음과 같다.<br/>
- 함수 인수 및 결과 유형 검사의 이점<br/>
- C99에서 인라인 함수가 사용 가능하지만 인라인이 적용되는 정도는 구현에 따라 결정됨<br/>
- 코드 크기와 실행 속도 간의 균형<br/>
- 컴파일 타임 평가 가능성이 중요한지 여부 : 상수 인수가 있는 매크로는 해당 함수 호출보다 컴파일 타임에 평가될 가능성이 높음<br/>
- 인수가 함수에 대해 유효한지 여부 : 매크로 인수는 텍스트이지만 함수 인수는 표현식<br/>
- 이해와 관리의 용이함<br/>
<br/>

<span style="color:#B73232">See also</span> &nbsp;Rule 13.2, Rule 20 .7<br/>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_DIR</ruleSetName>
    <ruleSetDesc><![CDATA[Additional directive guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_DIR_04_10</rule>
    <ruleTitle><![CDATA[헤더 파일의 내용이 두 번 이상 포함되지 않도록 주의해야 함]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
객체의 구현은 불완전한 유형에 대한 포인터를 사용하여 숨겨야 한다.
<br/><br/>
번역 단위에 중첩된 헤더 파일의 복잡한 계층 구조가 포함되어 있으면 특정 헤더 파일을 두 번 이상 포함할 수 있으며 문제의 원인이 될 수 있다.<br/>
여러 번 include 되거나 또는 중복 정의될 경우 정의되지 않거나 잘못된 동작이 발생할 수 있다.<br/><br/>
]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>MISRA_C_2012_DIR</ruleSetName>
    <ruleSetDesc><![CDATA[Additional directive guidelines for MISRA C 2012]]></ruleSetDesc>
    <rule>MISRA_C_2012_DIR_04_12</rule>
    <ruleTitle><![CDATA[동적 메모리 할당은 사용되면 안 됨]]></ruleTitle>
    <ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

다음과 같은 동적 메모리 할당 패키지에 적용된다<br/>
- 표준 라이브러리에 의해 제공된 것<br/>
- 타사 패키지<br/><br/>

표준 라이브러리의 동적 메모리 할당 및 해제 루틴은 Rule 21.3에 설명한 것처럼 undefined behavior를 초래할 수 있다. 다른 동적 메모리 할당 시스템은 표준 라이브러리와 비슷한 정의되지 않은 동작을 나타낼 수 있다. 동적 메모리 할당이 부주의하게 사용되지 않도록 타사 루틴의 사양을 확인해야 한다. 동적 메모리를 사용하기로 결정한 경우 소프트웨어가 예측 가능한 방식으로 작동하도록 주의해야 한다. <br/>
예를들면 :<br/>
- 요청을 만족시키기에 메모리가 부족할 수 있다.<br/>
- 사용 패턴 및 결과적인 조각화 정도에 따라 성능 향상 또는 할당 해제에 필요한 실행 시간에 높은 차이가 있다.<br/>

]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_01</rule>
    <ruleTitle><![CDATA[char 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ char 타입의 global 변수는 'g_c'로 시작해야 한다.
match regular expression : 'g_c.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_02</rule>
    <ruleTitle><![CDATA[char 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ char 타입의 static 변수는 't_c'로 시작해야 한다.
match regular expression : 't_c.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_03</rule>
    <ruleTitle><![CDATA[char 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ char 타입의 local 변수는 'c'로 시작해야 한다.
match regular expression : 'c.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_04</rule>
    <ruleTitle><![CDATA[signed char 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ signed char 타입의 global 변수는 'g_sc'로 시작해야 한다.
match regular expression : 'g_sc.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_05</rule>
    <ruleTitle><![CDATA[signed char 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ signed char 타입의 static 변수는 't_sc'로 시작해야 한다.
match regular expression : 't_sc.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_06</rule>
    <ruleTitle><![CDATA[signed char 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ signed char 타입의 local 변수는 'sc'로 시작해야 한다.
match regular expression : 'sc.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_07</rule>
    <ruleTitle><![CDATA[unsigned char 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ unsigned char 타입의 global 변수는 'g_uc'로 시작해야 한다.
match regular expression : 'g_uc.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_08</rule>
    <ruleTitle><![CDATA[unsigned char 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ unsigned char 타입의 static 변수는 't_uc'로 시작해야 한다.
match regular expression : 't_uc.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_09</rule>
    <ruleTitle><![CDATA[unsigned char 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ unsigned char 타입의 local 변수는 'uc'로 시작해야 한다.
match regular expression : 'uc.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_10</rule>
    <ruleTitle><![CDATA[short 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ short 타입의 global 변수는 'g_s'로 시작해야 한다.
match regular expression : 'g_s.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_11</rule>
    <ruleTitle><![CDATA[short 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ short 타입의 static 변수는 't_s'로 시작해야 한다.
match regular expression : 't_s.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_12</rule>
    <ruleTitle><![CDATA[short 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ short 타입의 local 변수는 's'로 시작해야 한다.
match regular expression : 's.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_13</rule>
    <ruleTitle><![CDATA[unsigned short 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ unsigned short 타입의 global 변수는 'g_us'로 시작해야 한다.
match regular expression : 'g_us.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_14</rule>
    <ruleTitle><![CDATA[unsigned short 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ unsigned short 타입의 static 변수는 't_us'로 시작해야 한다.
match regular expression : 't_us.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_15</rule>
    <ruleTitle><![CDATA[unsigned short 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ unsigned short 타입의 local 변수는 'us'로 시작해야 한다.
match regular expression : 'us.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_16</rule>
    <ruleTitle><![CDATA[int 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ int 타입의 global 변수는 'g_i'로 시작해야 한다.
match regular expression : 'g_i.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_17</rule>
    <ruleTitle><![CDATA[int 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ int 타입의 static 변수는 't_i'로 시작해야 한다.
match regular expression : 't_i.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_18</rule>
    <ruleTitle><![CDATA[int 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ int 타입의 local 변수는 'i'로 시작해야 한다.
match regular expression : 'i.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_19</rule>
    <ruleTitle><![CDATA[unsigned int 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ unsigned int 타입의 global 변수는 'g_ui'로 시작해야 한다.
match regular expression : 'g_ui.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_20</rule>
    <ruleTitle><![CDATA[unsigned int 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ unsigned int 타입의 static 변수는 't_ui'로 시작해야 한다.
match regular expression : 't_ui.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_21</rule>
    <ruleTitle><![CDATA[unsigned int 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ unsigned int 타입의 local 변수는 'ui'로 시작해야 한다.
match regular expression : 'ui.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_22</rule>
    <ruleTitle><![CDATA[long 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ long 타입의 global 변수는 'g_l'로 시작해야 한다.
match regular expression : 'g_l.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_23</rule>
    <ruleTitle><![CDATA[long 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ long 타입의 static 변수는 't_l'로 시작해야 한다.
match regular expression : 't_l.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_24</rule>
    <ruleTitle><![CDATA[long 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ long 타입의 local 변수는 'l'로 시작해야 한다.
match regular expression : 'l.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_25</rule>
    <ruleTitle><![CDATA[unsigned long 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ unsigned long 타입의 global 변수는 'g_ul'로 시작해야 한다.
match regular expression : 'g_ul.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_26</rule>
    <ruleTitle><![CDATA[unsigned long 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ unsigned long 타입의 static 변수는 't_ul'로 시작해야 한다.
match regular expression : 't_ul.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_27</rule>
    <ruleTitle><![CDATA[unsigned long 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ unsigned long 타입의 local 변수는 'ul'로 시작해야 한다.
match regular expression : 'ul.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_28</rule>
    <ruleTitle><![CDATA[long long 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ long long 타입의 global 변수는 'g_ll'로 시작해야 한다.
match regular expression : 'g_ll.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_29</rule>
    <ruleTitle><![CDATA[long long 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ long long 타입의 static 변수는 't_ll'로 시작해야 한다.
match regular expression : 't_ll.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_30</rule>
    <ruleTitle><![CDATA[long long 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ long long 타입의 local 변수는 'll'로 시작해야 한다.
match regular expression : 'll.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_31</rule>
    <ruleTitle><![CDATA[unsigned long long 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ unsigned long long 타입의 global 변수는 'g_ull'로 시작해야 한다.
match regular expression : 'g_ull.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_32</rule>
    <ruleTitle><![CDATA[unsigned long long 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ unsigned long long 타입의 static 변수는 't_ull'로 시작해야 한다.
match regular expression : 't_ull.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_33</rule>
    <ruleTitle><![CDATA[unsigned long long 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ unsigned long long 타입의 local 변수는 'ull'로 시작해야 한다.
match regular expression : 'ull.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_34</rule>
    <ruleTitle><![CDATA[float 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ float 타입의 global 변수는 'g_f'로 시작해야 한다.
match regular expression : 'g_f.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_35</rule>
    <ruleTitle><![CDATA[float 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ float 타입의 static 변수는 't_f'로 시작해야 한다.
match regular expression : 't_f.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_36</rule>
    <ruleTitle><![CDATA[float 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ float 타입의 local 변수는 'f'로 시작해야 한다.
match regular expression : 'f.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_37</rule>
    <ruleTitle><![CDATA[double 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ double 타입의 global 변수는 'g_d'로 시작해야 한다.
match regular expression : 'g_d.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_38</rule>
    <ruleTitle><![CDATA[double 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ double 타입의 static 변수는 't_d'로 시작해야 한다.
match regular expression : 't_d.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_39</rule>
    <ruleTitle><![CDATA[double 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ double 타입의 local 변수는 'd'로 시작해야 한다.
match regular expression : 'd.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_40</rule>
    <ruleTitle><![CDATA[char string 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ char string 타입의 global 변수는 'g_sz'로 시작해야 한다.
match regular expression : 'g_sz.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_41</rule>
    <ruleTitle><![CDATA[char string 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ char string 타입의 static 변수는 't_sz'로 시작해야 한다.
match regular expression : 't_sz.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_42</rule>
    <ruleTitle><![CDATA[char string 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ char string 타입의 local 변수는 'sz'로 시작해야 한다.
match regular expression : 'sz.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_43</rule>
    <ruleTitle><![CDATA[array 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ array 타입의 global 변수는 'g_a'로 시작해야 한다.
match regular expression : 'g_a.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_44</rule>
    <ruleTitle><![CDATA[array 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ array 타입의 static 변수는 't_a'로 시작해야 한다.
match regular expression : 't_a.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_45</rule>
    <ruleTitle><![CDATA[array 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ array 타입의 local 변수는 'a'로 시작해야 한다.
match regular expression : 'a.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_46</rule>
    <ruleTitle><![CDATA[char pointer 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ char pointer 타입의 global 변수는 'g_psz'로 시작해야 한다.
match regular expression : 'g_psz.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_47</rule>
    <ruleTitle><![CDATA[char pointer 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ char pointer 타입의 static 변수는 't_psz'로 시작해야 한다.
match regular expression : 't_psz.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_48</rule>
    <ruleTitle><![CDATA[char pointer 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ char pointer 타입의 local 변수는 'psz'로 시작해야 한다.
match regular expression : 'psz.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_49</rule>
    <ruleTitle><![CDATA[pointer 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ pointer 타입의 global 변수는 'g_p'로 시작해야 한다.
match regular expression : 'g_p.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_50</rule>
    <ruleTitle><![CDATA[pointer 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ pointer 타입의 static 변수는 't_p'로 시작해야 한다.
match regular expression : 't_p.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_51</rule>
    <ruleTitle><![CDATA[pointer 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ pointer 타입의 local 변수는 'p'로 시작해야 한다.
match regular expression : 'p.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_52</rule>
    <ruleTitle><![CDATA[function pointer 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ function pointer 타입의 global 변수는 'g_pf'로 시작해야 한다.
match regular expression : 'g_pf.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_53</rule>
    <ruleTitle><![CDATA[function pointer 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ function pointer 타입의 static 변수는 't_pf'로 시작해야 한다.
match regular expression : 't_pf.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_54</rule>
    <ruleTitle><![CDATA[function pointer 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ function pointer 타입의 local 변수는 'pf'로 시작해야 한다.
match regular expression : 'pf.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_55</rule>
    <ruleTitle><![CDATA[enum 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ enum 타입의 global 변수는 'g_e'로 시작해야 한다.
match regular expression : 'g_e.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_56</rule>
    <ruleTitle><![CDATA[enum 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ enum 타입의 static 변수는 't_e'로 시작해야 한다.
match regular expression : 't_e.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_57</rule>
    <ruleTitle><![CDATA[enum 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ enum 타입의 local 변수는 'e'로 시작해야 한다.
match regular expression : 'e.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_58</rule>
    <ruleTitle><![CDATA[struct 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ struct 타입의 global 변수는 'g_st'로 시작해야 한다.
match regular expression : 'g_st.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_59</rule>
    <ruleTitle><![CDATA[struct 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ struct 타입의 static 변수는 't_st'로 시작해야 한다.
match regular expression : 't_st.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_60</rule>
    <ruleTitle><![CDATA[struct 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ struct 타입의 local 변수는 'st'로 시작해야 한다.
match regular expression : 'st.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_61</rule>
    <ruleTitle><![CDATA[union 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ union 타입의 global 변수는 'g_u'로 시작해야 한다.
match regular expression : 'g_u.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_62</rule>
    <ruleTitle><![CDATA[union 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ union 타입의 static 변수는 't_u'로 시작해야 한다.
match regular expression : 't_u.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_63</rule>
    <ruleTitle><![CDATA[union 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ union 타입의 local 변수는 'u'로 시작해야 한다.
match regular expression : 'u.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_64</rule>
    <ruleTitle><![CDATA[boolean 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ boolean 타입의 global 변수는 'g_b'로 시작해야 한다.
match regular expression : 'g_b.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_65</rule>
    <ruleTitle><![CDATA[boolean 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ boolean 타입의 static 변수는 't_b'로 시작해야 한다.
match regular expression : 't_b.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_66</rule>
    <ruleTitle><![CDATA[boolean 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ boolean 타입의 local 변수는 'b'로 시작해야 한다.
match regular expression : 'b.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_67</rule>
    <ruleTitle><![CDATA[bool 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ bool 타입의 global 변수는 'g_b'로 시작해야 한다.
match regular expression : 'g_b.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_68</rule>
    <ruleTitle><![CDATA[bool 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ bool 타입의 static 변수는 't_b'로 시작해야 한다.
match regular expression : 't_b.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_69</rule>
    <ruleTitle><![CDATA[bool 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ bool 타입의 local 변수는 'b'로 시작해야 한다.
match regular expression : 'b.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_70</rule>
    <ruleTitle><![CDATA[byte 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ byte 타입의 global 변수는 'g_by'로 시작해야 한다.
match regular expression : 'g_by.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_71</rule>
    <ruleTitle><![CDATA[byte 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ byte 타입의 static 변수는 't_by'로 시작해야 한다.
match regular expression : 't_by.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_72</rule>
    <ruleTitle><![CDATA[byte 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ byte 타입의 local 변수는 'by'로 시작해야 한다.
match regular expression : 'by.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_73</rule>
    <ruleTitle><![CDATA[word 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ word 타입의 global 변수는 'g_w'로 시작해야 한다.
match regular expression : 'g_w.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_74</rule>
    <ruleTitle><![CDATA[word 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ word 타입의 static 변수는 't_w'로 시작해야 한다.
match regular expression : 't_w.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_75</rule>
    <ruleTitle><![CDATA[word 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ word 타입의 local 변수는 'w'로 시작해야 한다.
match regular expression : 'w.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_76</rule>
    <ruleTitle><![CDATA[DWORD 타입의 global 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ DWORD 타입의 global 변수는 'g_dw'로 시작해야 한다.
match regular expression : 'g_dw.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_77</rule>
    <ruleTitle><![CDATA[DWORD 타입의 static 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ DWORD 타입의 static 변수는 't_dw'로 시작해야 한다.
match regular expression : 't_dw.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_78</rule>
    <ruleTitle><![CDATA[DWORD 타입의 local 변수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ DWORD 타입의 local 변수는 'dw'로 시작해야 한다.
match regular expression : 'dw.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_79</rule>
    <ruleTitle><![CDATA[macro 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ macro는 대문자와 숫자, '_'로만 구성되어 있어야 한다.
match regular expression : '[A-Z0-9_]+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_80</rule>
    <ruleTitle><![CDATA[const qualified 타입의 변수는 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ const qualified 타입의 변수는 'o_'로 시작해야 한다.
match regular expression : 'o_.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_81</rule>
    <ruleTitle><![CDATA[static 함수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ static 함수는 'sf'로 시작해야 한다.
match regular expression : 'sf.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_82</rule>
    <ruleTitle><![CDATA[inline 함수 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ inline 함수는 'if'로 시작해야 한다.
match regular expression : 'if.+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_83</rule>
    <ruleTitle><![CDATA[struct 타입 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ struct 타입은 'S_'로 시작하고, 대문자, 숫자, '_'로만 구성되어야 한다.
match regular expression : 'S_[A-Z0-9_]+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_84</rule>
    <ruleTitle><![CDATA[union 타입 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ union 타입은 'U_'로 시작하고, 대문자, 숫자, '_'로만 구성되어야 한다.
match regular expression : 'U_[A-Z0-9_]+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>NAMING_C</ruleSetName>
    <ruleSetDesc><![CDATA[C Naming Rule Set]]></ruleSetDesc>
    <rule>NAMING_C_85</rule>
    <ruleTitle><![CDATA[enum 타입 명명 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ enum 타입은 'E_'로 시작하고, 대문자, 숫자, '_'로만 구성되어야 한다.
match regular expression : 'E_[A-Z0-9_]+' ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_001</rule>
    <ruleTitle><![CDATA[동적할당된 데이터를 release할 때, 잘못된 method를 이용하여 release하면 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 동적할당을 할 때 배열형식으로 할당하고, 해제할 때 단일 형식으로 해제해야 한다. 배열의 크기가 클수록 다량의 메모리 누수가 발생한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_002</rule>
    <ruleTitle><![CDATA[지역 변수나 함수 parameter의 주소 값을 처리하는 handle을 return하지 말아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 지역 변수나 함수 parameter의 주소 값을 처리하는 handle을 return하지 말아야 한다. return 문은 localdata의 값을 리턴하지만, Method가 reference를 이용하도록 되어 있어서 주소만 리턴하게 된다.(DAPA_CPP_03 포함) ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_003</rule>
    <ruleTitle><![CDATA[소멸자내에서 처리할 수 없는 예외 상황을 발생시키지 말아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 소멸자내에서 처리할 수 없는 예외 상황을 발생시키지 말아야 한다. 소멸자에서 예외가 발생하면 C++에서는 프로그램을 강제 종료시킨다. 처리되지 않은 예외가 있는 경우 해당클래스는 종료되지 않는다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_004</rule>
    <ruleTitle><![CDATA[사용되지 않는 예외 처리 문을 작성하지 말아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 사용되지 않는 예외 처리 문을 작성하지 말아야 한다. 첫 번째 catch 문에서 두 번째 catch 문의 예외 처리가 되나, 두 번 catch 문의 예외처리는 전혀 발생하지 않는다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_005</rule>
    <ruleTitle><![CDATA[exception specification에 기술되지 않은 모든 throw에 대하여 예외처리를 해야만 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ exception specification에 기술되지 않은 모든 throw에 대하여 예외처리를 해야만 한다. 처리할수 없는 예외는 unexpected()에 의해서 처리된다. 만일 사용자 개체(Implementation defined object)의 경우 unexpected()에서도 처리되지 않으므로 terminate()를 호출하여 프로그램 강제 종료가 발생한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_006</rule>
    <ruleTitle><![CDATA[main 함수에서 처리되지 않는 throw를 작성하지 말아야  한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ main 함수에서 처리되지 않는 throw를 작성하지 말아야  한다. 시스템에서terminate()를 호출하고 프로그램을 강제종료 시키기 때문이다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_007</rule>
    <ruleTitle><![CDATA[release 된 메모리 영역 사용하지 말아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ release 된 메모리 영역 사용하지 말아야 한다. 잘못된 메모리 영역 참조로 시스템 crash 또는 오동작이 가능하기 때문이다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_008</rule>
    <ruleTitle><![CDATA[copy operator를 통해서, 복사되지 않는 멤버 변수가 존재하지 말아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ copy operator를 통해서, 복사되지 않는 멤버 변수가 존재하지 말아야 한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_009</rule>
    <ruleTitle><![CDATA[C 코딩 방법으로 메모리를 할당 하면 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ C 코딩 방법으로 메모리를 할당 하면 안된다. delete 수행과정에서 잘못된 heap으로 인하여 프로그램 강제종료 현상 발생 가능하기 때문이다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_010</rule>
    <ruleTitle><![CDATA[순수 가상함수는 반드시 0으로 초기화 되어야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 순수 가상함수는 반드시 0으로 초기화 되어야 한다. 순수 가상함수를 0으로 초기화하지 않을 경우 가상함수가 쓰레기 값을 가지고 있을 수 있다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_011</rule>
    <ruleTitle><![CDATA[순수함수는 반드시 가상함수로 선언되어야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 순수함수는 반드시 가상함수로 선언되어야 한다. 순수 함수가 정의된 클래스를 상속받은 서브 클래스에서 순수 함수를 재정의하여 사용할 경우 함수 매핑시 오류가 발생할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_012</rule>
    <ruleTitle><![CDATA[virtual base 클래스의 포인터는 derived 클래스의 포인터로 cast 할 때에는 dynamic_cast만 사용해야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ virtual base 클래스의 포인터는 derived 클래스의 포인터로 cast 할 때에는 dynamic_cast만 사용해야 한다. base 클래스의 클래스 포인터를 안전하지 않은 casting 방법으로 상속받은 클래스 포인터의 형변환은 안전성을 보장할 수 없다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_013</rule>
    <ruleTitle><![CDATA[생성자/소멸자 내에서 가상함수는 식별자 없이 호출하면 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 생성자/소멸자 내에서 가상함수는 식별자 없이 호출하면 안된다. Base클래스의 생성자에서 파생 클래스의 객체는 instance가 유효한 상태가 아니므로 Base클래스의 생성자에서 호출되면 안된다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_014</rule>
    <ruleTitle><![CDATA[생성자/소멸자에 dynamic type을 사용하면 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 생성자/소멸자에 dynamic type을 사용하면 안된다. 생성과 소멸중의 타입은 완전히 생성된 객체의 타입과 다를 수 있기 때문에, 생성자와 소멸자에서의 객체의 다이나믹 타입의 사용은 개발자의 의도와 다를 수 있다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_015</rule>
    <ruleTitle><![CDATA[Scanf의 Argument 는 Object Value의 저장된 주소에 값이 입력되어야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ scanf 계열 함수(scanf, fscanf, vscanf, vfscanf)에 사용되는 식별자는 주소여야 하므로 pointer type이어야 한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_016</rule>
    <ruleTitle><![CDATA[#include 구문에서 표준에 맞지 않는 Character set을 사용하지 않아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 만약 ', , ", 또는 /* 문자가 헤더파일의 < 와 > 사이에서 사용된다면, 또는 " 사이에서 사용된다면, 정의되지 않은 행동을 할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_017</rule>
    <ruleTitle><![CDATA[Allocated되는 메모리 블록의 크기는 Pointer에 의해서 Address 되는 완전한 하나의 multiple size여야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ Allocated되는 메모리 블록의 크기는 Pointer에 의해서 Address 되는 완전한 하나의 multiple size여야 한다. 타입의 사이즈를 하드코딩 하면 안된다. 기본 타입의 사이즈는 컴파일러에 따라 혹은 같은 컴파일러 사이에도 버전에 따라 달라질 수 있기 때문이다. 따라서 sizeof 연산자의 사용을 권장한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_018</rule>
    <ruleTitle><![CDATA[함수의 Argument type과 개수는 함수의 Prototype, 선언, 정의가 모두 같아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수의 Argument에 대하여 다르게 입력할 시 데이터 값이 변환되어 의도하지 않은 동작을 할 위험이 있음. (함수의 Argument의 타입은 반드시 표준에 정의된 Compatible한 타입으로 사용해야 한다.) ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_019</rule>
    <ruleTitle><![CDATA[구조체/배열의 초기화 시 default 초기화 값(0)을 제외하고, 구조에 맞게 '{}'를 사용하여 선언된 Size에 맞게 초기화 해야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 구조체/배열의 초기화 시 default 초기화 값(0)을 제외하고, 구조에 맞게 '{}'를 사용하여 선언된 Size에 맞게 초기화 해야 한다. 어떠한  값이 초기화되는지 오해를 일으킬 수 있다. 가독성을 위해 default 초기값(0) 이외의 초기값을 입력할 때는 반드시 전체 맴버 변수에 대하여 초기화를 해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_020</rule>
    <ruleTitle><![CDATA[float 자료형에서 동등성 비교연산을 수행하지 말아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 부동소수점 특성 상 예상한 비교 결과가 나오지 않을 수 있다. 게다가 실행해보기 전 까지는 행위를 예측할 수 없고, 컴파일러마다 다를 수도 있기 때문에 수식의 비교가 참을 기대했을 때 종종 참으로 판단되지 않는다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_021</rule>
    <ruleTitle><![CDATA[조건문의 결과가 항상 true거나 false면 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 조건문의 결과가 항상 true거나 false면 안된다. Boolean 연산자가 항상 true거나 false면 대부분 프로그래밍 에러라고 볼 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_022</rule>
    <ruleTitle><![CDATA[switch의 case의 조건을 만족할 수 없는 Label을 사용하지 않는다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ switch의 case의 조건을 만족할 수 없는 Label을 사용하지 않는다. switch의 각 case의 값은 switch 조건의 값의 범위안에 있어야 한다. 범위를 벗어난 값으로 switch label을 사용하면 해당 절은 도달 불가능한 코드가 된다. 대부분의 경우 논리적 오류이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_023</rule>
    <ruleTitle><![CDATA[Switch 구문에서 첫번째 label 전에 코드 구문이 존재하면 안된다.]]></ruleTitle>
    <ruleDesc><![CDATA[ Switch 구문에서 첫번째 label 전에 코드 구문이 존재하면 안된다. Switch 구문은 label로 바로 이동하여 수행되기 때문에 첫번째 label 전에 코드 구문이 존재해도 수행되지 않는다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_024</rule>
    <ruleTitle><![CDATA[Switch 구문에서 Expression을 논리적 연산으로 사용하지 말아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ Switch 구문에서 Expression을 논리적 연산으로 사용하지 말아야 한다. 논리적 연산은 if 문 사용을 권장하고 논리적 연산을 switch 구문에 사용 시 문제가 될 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_025</rule>
    <ruleTitle><![CDATA[수행되지 않는 소스코드를 작성하지 말아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 수행되지 않는 소스코드를 작성하지 말아야 한다. 이 규칙은 도달할 수 없거나 compile-time에 확인할 수 없는 코드에 관한 규칙이다. 도달할 수 있지만 실행되지 않는 코드는 규칙에서 제외된다(Defensive programming code). 만약 코드의 어떤 부분으로 들어가는 적절한 entry point가 없다면 그 부분에는 도달할 수 없다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Dead Code</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_026</rule>
    <ruleTitle><![CDATA[선언된 데이터 형으로 표현할 수 있는 숫자의 영역을 초과하는 값을 할당하지 말아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 선언된 데이터 형으로 표현할 수 있는 숫자의 영역을 초과하는 값을 할당하면 overflow가 발생한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_027</rule>
    <ruleTitle><![CDATA[가변인수를 받는 함수의 Conversion 지시자와 Argument의 type은 동일해야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 가변인수를 받는 함수의 Conversion 지시자와 Argument의 type은 동일해야 한다. 입력 값과 변환 지정자가 일치하지 않으면 undefined behavior가 발생한다. 많은 컴파일러가 출력 함수 수행 시 포맷 불일치를 진단해낸다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_028</rule>
    <ruleTitle><![CDATA[가변인수를 받는 함수의 Conversion 지시자와 Argument의 개수는 동일해야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 가변인수를 받는 함수의 Conversion 지시자와 Argument의 개수는 동일해야 한다. Argument의 개수가 틀릴 경우 동작여부가 보장 안된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_029</rule>
    <ruleTitle><![CDATA[Object 저장 값을 표현할 수 없는 데이터로의 형 변환을 하지 말아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ Object 저장 값을 표현할 수 없는 데이터로의 형 변환을 하지 말아야 한다. 이런 변환은 배열의 참조자, 포인터 연산, 객체의 사이즈나 길이 등에서 신뢰하지 못하는 코드를 유발할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_030</rule>
    <ruleTitle><![CDATA[음수값을 unsigned type으로 변환을 자제해야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 음수값을 unsigned type으로 변환을 자제해야 한다. 이런 변환은 배열의 참조자, 포인터 연산, 객체의 사이즈나 길이 등에서 신뢰하지 못하는 코드를 유발할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_031</rule>
    <ruleTitle><![CDATA[Character 문자열과 Wide character 문자열을 혼용하지 말아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ Character 문자열과 wide character 문자열을 concatenation 하면 안된다. C99 ISO/IEC 9899:1999 에 의하면, wide string literal 과 narrow string literal 의 결합은 undefined behavior를 유발한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_032</rule>
    <ruleTitle><![CDATA[포인터 Cast의 결과로 인한 이전 포인터의 const 특성의 상실을 유의해야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 포인터 Cast의 결과로 인한 이전 포인터의 const 특성의 상실을 유의해야 한다. const qualifiication이 제거되면 프로그램이 해당 포인터에 참조되는 object를 수정할 수 있게 되면, 그 결과는 undefined behavior이다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_033</rule>
    <ruleTitle><![CDATA[포인터 Cast의 결과로 인한 이전 포인터의 volatile 특성 상실을 유의해야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 포인터 Cast의 결과로 인한 이전 포인터의 volatile 특성 상실을 유의해야 한다. volatile object가 non-volatile value의 사용에 의해 참조될 수 있으면 그 결과는 undefined behavior이다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_034</rule>
    <ruleTitle><![CDATA[external과 internal linkage의 특성을 동시에 가질 수 없다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ external과 internal linkage의 특성을 동시에 가질 수 없다. 두가지 storage class를 모두 갖고 있을 경우 어떻게 동작 할지 표준에 정의되어 있지 않다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_035</rule>
    <ruleTitle><![CDATA[external linkage scope에서 선언된 함수나 Object의 이름은 유일해야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ external linkage scope에서 선언된 함수나 Object의 이름은 유일해야 한다. external linkage 특성을 갖는 식별자는 여러 파일에서 구현될 경우 링커가 에러를 발생시킨다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_036</rule>
    <ruleTitle><![CDATA[external linkage scope에서 정의된 함수나 Object의 데이터형은 선언 시 정의와 동일해야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ external linkage scope에서 정의된 함수나 Object의 데이터형은 선언 시 정의와 동일해야 한다. 호환 가능한 type의 정의는 길고 복잡하다. 두 개의 동일한 타입은 호환 가능해야 하지만 두 개의 호환 가능한 타입이 동일할 필요는 없다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_037</rule>
    <ruleTitle><![CDATA[바깥 scope의 식별자를 가리는 정의를 하면 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 바깥 scope의 변수 사용 의도와 내부 scope의 변수 사용 의도가 혼용되어 가독성이 떨어짐. 특히 내부 scope에서 변경한 값이 외부 스코프에서 그대로 있을 것이라고 착각하게 되어 논리적 오류가 발생할 여지가 많아진다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_038</rule>
    <ruleTitle><![CDATA[String 배열의 초기화에서 배열의 마지막 인자는 NULL로 종료 되어야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ String 배열의 초기화에서 배열의 마지막 인자는 NULL로 종료 되어야 한다. 예를 들어 사이즈가 5인 문자열의 경우 배열의 최소 크기가 6이어야 NULL을 보장할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_039</rule>
    <ruleTitle><![CDATA[초기화 되지 않은 변수를 사용하지 말아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 변수는 사용 전에 값이 할당되어 있어야 한다. 분기의 일부에서만 값이 할당 된 경우 분기가 합쳐진 다음에는 값이 할당되지 않았을 수도 있다. 이 룰에서는 이러한 경우까지 검출한다. 포인터의 사용은 값 할당을 목적으로 할 수 있기 때문에 const qualified 포인터로 받는 경우에만 사용으로 인정하며 그 외에는 값을 할당하는 것으로 간주한다.(DATA_Init_03을 포함) ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_040</rule>
    <ruleTitle><![CDATA[하나의 Sequense Point 내에서 하나의 Object Value를 두 번 이상 변경하지 않아야 하고, 하나의 sequence point 내에서 Object value를 변경하고 access하지 않아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 몇몇 연산자(함수 호출 연산자 (), &&, ||, ? :, ,(comma))와 별개로 평가된 sub-expression의 순서는 달라질 수 있다. 이것은 sub-expression의 평가 순서를 믿을 수 없다는 것을 의미하고, 특히 side effect가 발생하는 순서를 믿을 수 없다는 것을 의미한다. Expression 평가의 관점에서 이전에 일어난 모든 side effect는 발생되었음을 보장할 수 있고, 이것은 "sequence points"라고 부른다. 이러한 평가 순서는 괄호의 사용으로 해결할 수 없고, 단지 우선순위의 문제만은 아니다. 이 규칙에서는 모든 함수의 호출에서 side effect가 발생한다고 가정한다.(DAPA_OP_03 포함) ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_041</rule>
    <ruleTitle><![CDATA[0 으로 나눗셈 연산을 하지 않는다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ /, % 연산자의 두 번째 피연산자로 0(zero)가 오면 undefined behavior가 발생한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_042</rule>
    <ruleTitle><![CDATA[음수 값 또는 데이터 사이즈를 초과하는 값을 사용하여 Shift operator를 하지 않는다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 예를 들어 만약 left-shift 또는 right-shift의 왼쪽 피연산자가 16-bit integer라면, 이 shift가 0에서 15 사이의 수 만큼 이루어 지는지 확인하는 것이 중요하다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_043</rule>
    <ruleTitle><![CDATA[Underlying type이 Unsigned인 데이터에 '-'를 사용하여 결과를 assign하지 말아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 단항 마이너스 연산자를 unsigned int 또는 unsigned long type expression에 적용하는 것은 의미 없는 연산이다. 단항 마이너스 연산자를 더 작은 unsigned integer type의 피연산자에 적용하는 것은 integral promotion 때문에 signed type의 결과가 나올 수 있지만, 이것은 좋은 구현이 아니다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_044</rule>
    <ruleTitle><![CDATA[sizeof의 인자는 side effect를 가지지  말아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 일부 컴파일러는 sizeof를 통하여 데이터 연산이 가능하나, 표준에 의해 정확하게 정의 되어 있지 않기 때문에 일부 컴파일러에서는 변환되지 않을 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_045</rule>
    <ruleTitle><![CDATA[Boolean 표현 값에 &&와 ||와 !연산자를 제외하고 다른 연산자를 사용하지 말아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 일반적으로  True는 1로 판단하지만 ISO-C90 표준에 의하여 명확하게 정의 되어 있지 않으므로 이식성을 위하여 논리 연산자와 산술 연산자를 분리하여 사용해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_046</rule>
    <ruleTitle><![CDATA[Singed Value에서 Bitwise연산자(<<, ~, |, ^ 등)로 인한 Negative Value를 유의해야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 비트 연산자(~, <<, <<=, >>, >>=, &, &=, ^, ^=, |, |=)들은 signed 정수에 대해서는 의미있는 연산을 수행하지 못한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_047</rule>
    <ruleTitle><![CDATA[condition에 직접적인 assignment operator를 사용하지 말아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 결과가 boolean 값을 가지는 표현 식의 내부에는 대입 연산자를 사용하면 안 된다. 여기서 말하는 대입 연산자는 단순한 대입 연산자와 복합 대입 연산자를 모두 일컫는다. 단, 변수에 boolean 값을 대입하는 경우는 예외다. 만약 boolean 값을 가지는 표현식에서 대입 연산자가 반드시 필요한 경우라면, 해당 표현식의 외부에서 따로 처리하여 사용하는 것을 권장한다. 그렇게 함으로써 '='와 '=='가 혼동되지 않도록 확실하게 처리할 수 있을 것이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_048</rule>
    <ruleTitle><![CDATA[Null pointer를 참조하지 않는다.]]></ruleTitle>
    <ruleDesc><![CDATA[ null 값을 가지는 객체에 대해 dereference 하게 되면 memory access violation이 발생한다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_049</rule>
    <ruleTitle><![CDATA[지역변수의 주소값을 더 넓은 scope를 가진 변수에 할당하지 말아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 자동 할당 객체의 주소가 다른 더 큰 scope의 자동 할당 객체, static 객체 또는 함수의 리턴 값에 할당된다면, 객체를 포함하는 주소는 객체가 제거된 이후에도 존재할 수 있다.(그리고 그 주소는 무효화된다.) ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_050</rule>
    <ruleTitle><![CDATA[선언된 배열의 크기를 초과하는 인덱스 값을 사용하지 말아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 배열의 index에 범위를 벗어나는 상수를 사용하는 경우 buffer overflow의 메모리 에러를 발생시킨다. 이는 접근 불가능한 메모리 영역을 접근함으로써 segmentation fault등 crash를 발생시킬 수 있다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_051</rule>
    <ruleTitle><![CDATA[지역변수의 주소값을 함수의 리턴값으로 사용하지 말아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 자동 할당 객체의 주소가 다른 더 큰 scope의 자동 할당 객체, static 객체 또는 함수의 리턴 값에 할당된다면, 객체를 포함하는 주소는 객체가 제거된 이후에도 존재할 수 있다.(그리고 그 주소는 무효화된다.) ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_052</rule>
    <ruleTitle><![CDATA[함수나 변수의 선언 시 type을 명시해야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 원형에서 변수와 return 값의 type은 정의와 일치해야 한다. 동일한 기본형식을 갖는것 뿐 아니라 typedef 이름과 qualifier 까지 동일해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_053</rule>
    <ruleTitle><![CDATA[의미 없는 구문은 사용하지 말아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ null이 아니면서 side effect가 없고 제어 흐름의 변화를 일으키지 않는 statement는 보통 프로그래밍 에러로 가정하므로, 정적인 체크가 수행되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_054</rule>
    <ruleTitle><![CDATA[함수의 return type에 맞는 return을 사용해야 한다.]]></ruleTitle>
    <ruleDesc><![CDATA[ 이러한 함수를 사용하면 함수의 return 값이 출력 된다. 그런데 return 구문의 부재는 정의되지 않은 행동을 유발할 수 있다.(컴파일러에 따라 이런 형태를 에러로 보지 않을 수도 있다.)]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_055</rule>
    <ruleTitle><![CDATA[선언 없이 함수를 사용하지 말아야 한다. (묵시적 선언이 사용됨)  ]]></ruleTitle>
    <ruleDesc><![CDATA[ 링커는 object로 되어있는 파일로부터, 함수의 식별자와 리턴 값의 형만 검사하여 파라미터가 올바르게 사용되었는지 확인할 수 없다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_056</rule>
    <ruleTitle><![CDATA[매크로의 정의 여부를 확인하지 않고 해당 매크로에 대하여  '#if', '#elif' 표현을 사용하지 말아야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 만약 preprocessor directive 내에서 어떤 identifier를 사용하려고 시도한다면, 그리고 그 identifier가 정의되지 않았다면, preprocessor는 경고하지 않고 값을 0으로 가정한다. #ifdef, #ifndef 그리고 defined()는 매크로의 존재를 검사하는데 사용하므로 제외된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_057</rule>
    <ruleTitle><![CDATA[하나의 함수는 하나의 exit point를 가져야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 하나의 함수에 여러 개의 Return 문을 사용할 경우 가독성 및 문제 발생시 수행 경로에 대하여 판단하기 힘들다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_058</rule>
    <ruleTitle><![CDATA[goto 문 사용은 최대한 자제한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ goto 문을 사용은 프로그램의 흐름을 복잡하게 하여 가독성 및 문제가 될 수 있는 코드를 작성할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_059</rule>
    <ruleTitle><![CDATA[if ... else if 문은 else 문도 포함 시킨다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 코드의 가독성을 높이고 예외상황에 대한 방어를 위해 if-else if 문을 사용 시 반드시 else 문을 사용해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_060</rule>
    <ruleTitle><![CDATA[한 줄에 하나의 명령문을 사용한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 코드의 가독성을 높이고 실수를 방지하기 위하여 한 줄에 하나의 명령문을 사용해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_061</rule>
    <ruleTitle><![CDATA[코드 섹션은 주석처리 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 특정 소스코드의 섹션이 컴파일 되지 않는 것을 요구할 때, 조건부 컴파일을 사용하는 것을 권장한다(주석과 함께 사용되는 #if 또는 #ifdef 구조). C 표준은 중첩 주석을 지원하지 않는다. 이러한 목적을 위한 주석 시작과 끝 표시의 사용은 위험하다. 왜냐하면 C가 중첩 주석을 지원하지 않고, 코드 섹션 내에 다른 주석이 있다면 프로그램 흐름이 바뀔 수 있기 때문이다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_062</rule>
    <ruleTitle><![CDATA[헤더파일에 객체나 함수 정의 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 헤더 파일에는 객체, 함수, typedef, 그리고 매크로의 선언만 사용해야 한다. 헤더파일은 저장공간을 사용하는 객체나 함수의 정의를 포함해서는 안 된다. 오직 .c 파일에만 실행 가능한 소스 코드가 포함되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_063</rule>
    <ruleTitle><![CDATA[모든 unsigned 타입의 상수에는 U 접미사를 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 정수 상수의 타입은 잠재적 혼동을 가져온다. 예를 들어 정수 상수 40000은 32bit 환경에서는 int 타입이지만, 16bit 환경에서는 long 타입이다. 정수 타입은 다음 요소들의 복잡한 조합에 의존한다.<ul><li>- 상수의 크기</li><li>- 정수형 타입의 구현된 크기</li><li>- 접미사의 표현</li><li>- 값이 표현된 number base(decimal, octal or hexadecimal)</li></ul> ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_064</rule>
    <ruleTitle><![CDATA[반복문에는 loop를 종료하기 위해 최대 하나의 break 문이 사용되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 이 규칙은 잘 구조화된 프로그래밍을 위한 규칙이다. 효율적인 코딩을 위해 하나의 loop에는 하나의 break 문이 허용된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_065</rule>
    <ruleTitle><![CDATA[switch, while, do ... while, for 문장(statement)의 body는 복합문이어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 비록 복합문 내에 하나의 문장만 존재하더라도 switch, while, do ... while, for 문은 복합문이어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_066</rule>
    <ruleTitle><![CDATA[if 문(else if 또는 else 포함)의 body는 복합문이어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 복합문을 위한 layout과 괄호는 style guideline에서 결정되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_067</rule>
    <ruleTitle><![CDATA[switch 문 안에 case, default 절이 아닌 문장(statement)은 존재하면 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C언어에서 switch 문을 위한 문법은 취약하고, 복잡하며, 구조화 되어있지 않다. 따라서 이를 대체하기 위해 MISRA-C에 의해 정의된 switch 문을 위한 문법이 존재한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_068</rule>
    <ruleTitle><![CDATA[문장(statement)이 있는 모든 case 또는 default 구문은 조건문이 없는 break문으로 끝나야 함]]></ruleTitle>
    <ruleDesc><![CDATA[ 모든 case 또는 default 구문의 마지막에는 break 문이 있어야 한다. 만약 case 또는 default 구문이 복합문이라면 복합문 내의 마지막 문장이 break 문이어야 한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_069</rule>
    <ruleTitle><![CDATA[모든 switch 문은 하나 이상의 case 절을 가져야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 모든 switch 문은 하나 이상의 case 절을 가져야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_070</rule>
    <ruleTitle><![CDATA[헤더 파일이 중복되어 include되는 것을 방지하기 위한 예방 조치가 되어있어야 함(#ifndef, #endif) ]]></ruleTitle>
    <ruleDesc><![CDATA[ 컴파일 단위(translation unit)가 중복된 헤더파일의 복잡한 계층으로 이루어져 있을 때, 특정 헤더 파일이 두 번 이상 include 되는 일이 발생한다. 이것은 개발자를 혼동하게 만들 수 있다. <br/>만약 그것이 여러 번의 정의로 인한 충돌을 일으킨다면 프로그램은 잘못된 결과를 나타낼 수 있다.<br/> 헤더 파일을 여러 번 포함하는 것은 신중한 코드 설계로 피할 수 있다. 만약 그것이 불가능 하다면 파일의 내용을 한 번 이상 include 하는 것을 예방하는 메카니즘을 사용할 수 있다. <br/>공통적인 접근 방식은 매크로를 각 파일에 적용하는 것이다. 이 매크로는 파일이 처음 include 되었을 때 정의되며, 이후에 파일이 다시 include 되려고 할 때, 파일의 내용을 차단하는데 사용된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_071</rule>
    <ruleTitle><![CDATA[정수 나눗셈의 구현은 반드시 주어진 컴파일러에서 결정되고 문서화 되며, 고려되어야 함]]></ruleTitle>
    <ruleDesc><![CDATA[ ISO 표준의 컴파일러는 부호있는 정수 나눗셈에 대해 두 가지 특성을 가질 수 있다. 몫을 올림하고 나머지는 음수를 취하는 것과, 몫을 내림하고 나머지는 양수를 취하는 것이다. <br/>예를 들면 -5/3 의 몫을 -1, 나머지를 -2 를 취하는 것과, 몫을 -2 를, 나머지를 +1 을 취하는 것이다. 이러한 상황을 어떻게 처리하도록 컴파일러를 구현할지 결정하고, 프로그래머를 위해서 문서화하는 것이 중요하다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_072</rule>
    <ruleTitle><![CDATA[오브젝트의 포인터와는 정수형 타입, 다른 오브젝트의 포인터 또는 void 포인터를 제외한 어떤 타입간에도 변환이 일어나선 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 오브젝트의 포인터와는 정수형 타입, 다른 오브젝트의 포인터 또는 void 포인터를 제외한 어떤 타입간에도 변환이 일어나선 안된다. 이와 같은 변환은 정의되지 않은 변환이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_073</rule>
    <ruleTitle><![CDATA[C 연산자의 우선순위에 의존하지 말고 연산 우선순위를 명시적으로 표현해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 괄호는 기본 연산자 우선순위 대로 계산되는 것을 방지하기 위해서 사용할 뿐 아니라 기존 연산 우선순위를 강조하기 위해서도 사용되어야 한다. C 언어는 복잡한 우선순위 때문에 실수 하기가 쉬우므로, 괄호를 사용하여 에러를 방지하고 가독성을 높일 수 있다. 그러나 너무 많은 괄호를 집어넣어 코드를 어수선하게 만들고 가독성을 떨어뜨려서는 안 된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_074</rule>
    <ruleTitle><![CDATA[switch 문의 마지막 절이 default 절이어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 마지막 절에 default가 오는 것은 방어적 프로그래밍을 위함이다. default 절에서는 적절한 행동을 취하거나 아무 행동을 하지 않으면 적절한 주석을 달아야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_075</rule>
    <ruleTitle><![CDATA[함수의 인자 수는 가변적으로 정의되서는 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수의 인자 수가 가변적이면 이로 인해 많은 문제가 발생할 수 있다. 유저는 가변적인 인자 수를 가지는 함수를 사용해선 안 된다. 따라서 이와 같은 상황에서 이용되는 stdarg.h, va_arg, va_start, va_end는 사용을 금한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_076</rule>
    <ruleTitle><![CDATA[함수의 직/간접적인 재귀 호출 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 시스템의 안정성을 위하여 함수의 재귀호출은 사용하지 않는 것이 좋다. 재귀호출은 스택 공간 이용을 초과하는 위험을 가져오며 이것은 심각한 오류가 될 수 있다. 함수의 재귀 호출이 매우 엄격하게 통제된다고 하더라도, 프로그램 실행 전에 스택 사용의 최악의 상황을 예측하는 것은 불가능하다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_077</rule>
    <ruleTitle><![CDATA[함수에 형식 인자가 없는 경우 void 타입 형식 인자로 선언해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수는 return 타입과 함께 선언하는데, 함수에 return 타입이 없다면 void 타입으로 선언한다. 이와 비슷하게, 함수에 형식 인자가 없다면 형식 인자 부분은 void로 선언되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_078</rule>
    <ruleTitle><![CDATA[#include 앞에는 다른 preprocessor directive나 주석만 허용 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 모든 #include 문은 특정 코드 파일에서 파일의 head 근처에 그룹화 되어야 한다. 파일 내에에서 #include 앞에 올 수 있는 것은 preprocessor directive 또는 주석 뿐이다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_079</rule>
    <ruleTitle><![CDATA[표준 라이브러리에 예약된 식별자, 매크로 그리고 함수는 defined, redefined 또는 undefined 할 수 없음 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 표준 라이브러리에 정의된 매크로를 #undef 하는 것은 잘못된 습관이다. 표준 라이브러리에 정의된 매크로, 객체 또는 함수의 이름이나 예약된 식별자를 매크로 이름으로 정의하는 것 또한 잘못된 습관이다. 예를 들어 defined, __LINE__, __FILE__, __DATE__, __TIME__, __STDC__, errno, assert 처럼 재 정의 또는 정의 취소 되었을 때 정의되지 않은 행동을 할 수 있는 특정 단어나 함수의 이름이 존재한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_C_CPP_Standard</ruleSetName>
    <ruleSetDesc><![CDATA[한전 C,C++ 표준 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_080</rule>
    <ruleTitle><![CDATA[동적 힙 메모리 할당 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 이는 calloc, malloc, realloc 그리고 free 함수의 사용을 금지하는 규칙이다. 다른 수많은 잠재적인 위험과 마찬가지로 동적 메모리 할당과 관련된 구체화 시, 정의 시, 구현 시 정의 되지 않은 행동이 존재한다. 동적 힙 메모리 할당은 메모리 누수, 데이터 불일치, 메모리 고갈, 결정되지 않은 행동을 가져올 수 있다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_IEC60880_061</rule>
    <ruleTitle><![CDATA[switch문은 두 개 이상의 case를 가져야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 코드 가독성을 위해 하나의 case를 갖는 switch 문은 if 문으로 작성하는 것이 좋다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_IEC60880_062</rule>
    <ruleTitle><![CDATA[switch문의 마지막 절이 default절 인지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 모든 enum 을 처리하는 것이 아닌 경우, 반드시 예외적인 default 절을 추가해서 예외적인 상황을 고려하는 방어적인 프로그램을 수행하는 것이 좋다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_IEC60880_065</rule>
    <ruleTitle><![CDATA[if 가 있다면 else가 반드시 있는 지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ if 문장 이후에 else 구문이 없는 경우, 예외적인 흐름을 기대하게 된다. 방어적으로 프로그래밍하면 else 인 상황에 맞는 코드가 필요하다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_IEC60880_069</rule>
    <ruleTitle><![CDATA[메서드의 인자 개수 제한 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수의 인자가 많은 경우, 함수가 단일 책임 원칙을 위배하는 경우가 많다. 또한 코드의 관리도 직관적이지 않게 된다. 최소한의 인자만을 사용하도록 수정한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_IEC60880_072</rule>
    <ruleTitle><![CDATA[메서드 복잡도(cyclomatic complexity number) 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 메서드 정의가 복잡하면, 코드의 유지보수가 어렵다. 유지보수성을 위해 메서드 복잡도를 일정 수준 이하로 유지한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_IEC60880_077</rule>
    <ruleTitle><![CDATA[메서드 코드 라인 수(LOC) 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 코드 라인 수가 크면 코드의 유지보수가 어렵다. 유지보수성을 위해 메서드의 코드 라인 수를 일정 수준 이하로 유지한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_IEC60880_078</rule>
    <ruleTitle><![CDATA[함수가 하나의 exit point 를 가졌는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 조건에 따라 종료하는 종료시점이 많을 수록 코드의 가독성이 떨어지고, 프로그램의 논리 구조가 명확해 지지 않는다. 종료지점을 최소한으로 유지하는 것이 좋다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_001</rule>
    <ruleTitle><![CDATA[동적 메모리 할당 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 동적 메모리 할당을 사용하는 calloc, malloc, realloc, strdup 함수의 사용을 금지한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_002</rule>
    <ruleTitle><![CDATA[free된 포인터 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ free() 또는 realloc()함수 호출에 의해 해제된 공간을 참조하는 포인터 값을 사용하는 프로그램의 동작은 undefined. (undefined behavior 168 of Annex J 참조) 
한번 free된 메모리에 접근하는것은 heap을 관리하는 자료구조를 파괴할수 있다. 해제된 메모리로의 참조는 dangling pointer로의 참조가 된다. dangling pointer에 접근하는것은 취약점을 드러내는 결과가 될수 있다. 
메모리가 해제될때, 재할당 또는 해제된 chunk를 재활용 할때의 메모리 관리자의 재량권 때문에 그 내용은 아직 변형없이 남아있고 접근 가능하다. 해제된 위치의 데이타는 문제없이 보일수 있다. 그러나 이것은 불시에 변경될수 있고 프로그램을 unintended behavior로 유도한다. 결과적으로 한번 해제된 메모리가 읽거나 쓰이지 않음을 보장할 필요가 있다 ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_003</rule>
    <ruleTitle><![CDATA[free된 포인터에 즉시 새로운 값을 저장하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Dangling pointer는 exploitable 이중 free와 free된 메모리 접근 취약점을 이용하도록 유도할수 있다. Dangling pointer를 제거하고 많은 메모리관련 취약점을 피하는 간단하지만 유효한 방법은 포인터에 그들이 free된 후 또는 그들을 다른 적절한 object에 지정한 후에 NULL값을 지정하는것이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_004</rule>
    <ruleTitle><![CDATA[메모리 할당 함수의 할당 성공 여부 반환값이 검증되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 메모리 할당 함수의 반환 값은 할당의 성공이나 실패 여부를 의미한다. C99에 따르면 calloc(), malloc(), realloc()는 메모리 할당이 실패할 경우 null 포인터를 반환한다. 따라서 메모리 함수의 최종 상태를 확인한 뒤 문제가 발생한 경우에는 적절한 가이드를 해줘야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_005</rule>
    <ruleTitle><![CDATA[클래스 연산자를 명시적으로 선언하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 클래스 연산자를 명시적으로 선언하였는지 검사 ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_006</rule>
    <ruleTitle><![CDATA[메모리 할당 함수의 할당 크기를 입력하는 인자에 sizeof를 포함한 expression을 사용했는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 타입의 사이즈를 하드코딩 하면 안된다. 기본 타입의 사이즈는 컴파일러에 따라 혹은 같은 컴파일러 사이에도 버전에 따라 달라질 수 있기 때문이다. 따라서 sizeof 연산자의 사용을 권장한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_007</rule>
    <ruleTitle><![CDATA[특정 함수의 특정 인자로 검증되지 않은 변수 또는 0(constant zero) 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 메모리 할당 시에 사이즈를 0으로 입력하는 것에 대한 처리는 implementation-defined이다. 또한 메모리 할당 함수가 non-null 포인터를 반환하는 경우 할당된 메모리를 읽거나 쓰는 것에 대해서는 undefined behaviord이다. 따라서 메모리 할당 함수에 전달되는 사이즈가 0인지 검사하고 사용해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_008</rule>
    <ruleTitle><![CDATA[realloc()의 인자의 타입과 cast되는 타입이 다른지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C standard에 의하면, recalloc(ptr, size) 호출은 ptr이 가리키는 구 객체를 할당해제 하고 size에 의해 크기가 명세되는 새 객체를 반환한다. 새 객체의 내용은 새 객체와 구 객체중 작은쪽의 크기까지 할당해제 전의 구 객체의 내용과 같다, 구 객체의 크기 너머의 새 객체의 바이트들은 결정되지 않은 값들을 가진다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_009</rule>
    <ruleTitle><![CDATA[사용이 권장되지 않거나 구형의 함수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 어떤 함수들은 사용이 권장되지 않거나 새로운 함수를 통해 대체가 가능하다. 이러한 함수들의 사용이 발생하지 않도록 검사한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_010</rule>
    <ruleTitle><![CDATA[malloc 함수 사용시 오버플로가 발생하면 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 특정 함수 호출 시 전달되는 size가 size_t 타입의 범위를 벗어나는 경우 오버플로가 발생할 수 있다. 따라서 size_t 타입의 사용을 권장한다. 만약 expression 인자의 결과가 size_t 타입의 범위 내라는 보장이 있다면 전체 expression을 size_t로 casting 하기를 권장한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_011</rule>
    <ruleTitle><![CDATA[memcpy 함수 사용시 배열에 복사 할 때 오버플로가 발생하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 데이터를 배열에 복사할 때 충분한 공간을 확보하지 않으면 오버플로가 발생한다.  ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_012</rule>
    <ruleTitle><![CDATA[string 관련 함수 사용시 배열에 복사 할 때 오버플로가 발생하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 표준 함수인 strncpy()와 strncat()은 지정된 수 n개의 문자를 소스 문자열로부터 대상 배열로 복사한다. 소스 배열의 처음 n개의 문자 중에 널문자가 없다면 결과 값 역시 널문자로 종료되지 않고, n개를 초과하는 문자들은 버려진다. 따라서 널문자까지 복사될 만큼의 충분한 공간이 확보되었는지 주의를 기울여야 한다.  ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_013</rule>
    <ruleTitle><![CDATA[함수의 파라미터 개수 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 파라미터 개수를 31개로 제한한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_014</rule>
    <ruleTitle><![CDATA[함수의 직, 간접적인 재귀 호출 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 시스템의 안정성을 위하여 함수의 재귀호출은 사용하지 않는 것이 좋다. 재귀호출은 stack 공간 이용을 초과하는 위험을 가져오며 이것은 심각한 오류가 될 수 있다. 함수의 재귀 호출이 매우 엄격하게 통제된다고 하더라도, 프로그램 실행 전에 stack 사용의 최악의 상황을 예측하는 것은 불가능하다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_015</rule>
    <ruleTitle><![CDATA[사용이 권장되지 않거나 구형의 함수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 어떤 함수들은 사용이 권장되지 않거나 새로운 함수를 통해 대체가 가능하다. 이러한 함수들의 사용이 발생하지 않도록 검사한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_016</rule>
    <ruleTitle><![CDATA[Library 함수에 전달되는 인자 값이 올바른지 검사해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 표준 C library의 많은 함수들은 ISO 표준에 의한 parameter의 유효성을 검사하지 않는다. 표준에 의해 검사 하거나 컴파일러 개발자가 parameter의 유효성을 검사한다고 하더라도, 적절한 검사가 이루어 는지 보장할 수는 없다. 그러므로 프로그래머는 제한된 input domain을 갖는 모든 library 함수를 위한 input value의 적절한 검사를 제공해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_017</rule>
    <ruleTitle><![CDATA[배열의 index에 범위를 벗어나는 상수를 사용했는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 배열의 index에 범위를 벗어나는 상수를 사용하는 경우 buffer overflow의 메모리 에러를 발생시킨다. 이는 접근 불가능한 메모리 영역을 접근함으로써 segmentation fault등 crash를 발생시킬 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_018</rule>
    <ruleTitle><![CDATA[Goto statement 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 이 규칙은 잘 구조화된 프로그래밍을 위한 규칙이다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_019</rule>
    <ruleTitle><![CDATA[Longjmp 함수와 setjmp 매크로 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Longjmp와 setjmp는 일반적인 함수 호출 메카니즘을을 지나치는 것을 허용하게 한다. 따라서 사용하면 안 된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_020</rule>
    <ruleTitle><![CDATA[함수 복잡도(cyclomatic complexity number) 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 구조적 프로그래밍 원칙에 따라 구조 복잡성을 최소화해야 한다. 함수의 복잡도 값이 높다는 것은 내부 제어 흐름 구조가 복잡하다는 것이므로 가독성을 떨어뜨리고 유지보수를 어렵게 한다. 하나의 함수에서 너무 많은 역할을 하고 있는 것이 아닌지 검토가 필요하며 가능하면 기능적 분해를 통해 복잡도가 낮은 함수들로 재구성한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_021</rule>
    <ruleTitle><![CDATA[else if의 개수 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 연속된 if-else의 사용은 제어 흐름의 복잡도를 높게 만든다. 따라서 else if가 너무 많은 경우 switch case의 사용을 권장한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_022</rule>
    <ruleTitle><![CDATA[If 문(else if 또는 else 포함)의 body는 복합문이어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 복합문을 위한 layout과 괄호는 style guideline에서 결정되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_023</rule>
    <ruleTitle><![CDATA[switch 문의 마지막 절이 default 절이어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 마지막 절에 default가 오는 것은 defensive programming을 위함이다. default 절에서는 적절한 행동을 취하거나 아무 행동을 하지 않으면 적절한 주석을 달아야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_024</rule>
    <ruleTitle><![CDATA[문장이 있는 모든 case 또는 default label은 조건문이 없는 break문으로 끝나야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 모든 case 또는 default label의 마지막에는 break statement로 끝나야 한다. 만약 case 또는 default label이 복합문이라면 복합문 내의 마지막 statement가 break statement가 되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_025</rule>
    <ruleTitle><![CDATA[Switch 문의 마지막 절이 default 절이어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 마지막 절에 default가 오는 것은 defensive programming을 위함이다. default 절에서는 적절한 행동을 취하거나 아무 행동을 하지 않으면 적절한 주석을 달아야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_026</rule>
    <ruleTitle><![CDATA[도달 불가능한 코드 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 이 규칙은 도달할 수 없거나 compile-time에 확인할 수 없는 코드에 관한 규칙이다. 도달할 수 있지만 실행되지 않는 코드는 규칙에서 제외된다(Defensive programming code). 만약 코드의 어떤 부분으로 들어가는 적절한 entry point가 없다면 그 부분에는 도달할 수 없다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Dead Code</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_027</rule>
    <ruleTitle><![CDATA[변수 선언 시 초기화 여부 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 변수를 선언할 때 초기화를 함께 하는 것이 좋다. 초기화하지 않을 경우 쓰레기값이 존재하여 논리적 오류를 유발할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_028</rule>
    <ruleTitle><![CDATA[External linkage를 포함하는 identifier는 정확히 하나의 external definition을 가져야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Identifer가 서로 다른 파일에서 여러 개로 정의 되어 있거나, 정의되어있지 않으면 identifier의 동작은 정의되지 않는다. 서로 다른 파일에 여러 개의 정의가 있다면 정의가 같다고 하더라도 허용되지 않으며, 정의가 서로 다르거나 다른 값으로 초기화 한다면 더욱 심각한 문제를 일으킬 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_029</rule>
    <ruleTitle><![CDATA[Automatic 공간을 사용하는 객체를 대상으로, 주소에 할당된 객체가 삭제 된 이후에도 존재할 수 있는 객체에는 할당 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 자동 할당 객체의 주소가 다른 더 큰 scope의 자동 할당 객체, static 객체 또는 함수의 리턴 값에 할당된다면, 객체를 포함하는 주소는 객체가 제거된 이후에도 존재할 수 있다.(그리고 그 주소는 무효화된다.) ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_030</rule>
    <ruleTitle><![CDATA[reference 타입 함수에서 parameter 반환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ reference 타입 함수에서 parameter 반환 금지 ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_031</rule>
    <ruleTitle><![CDATA[변수 선언 시 초기화 여부 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 변수를 선언할 때 초기화를 함께 하는 것이 좋다. 초기화하지 않을 경우 쓰레기값이 존재하여 논리적 오류를 유발할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_032</rule>
    <ruleTitle><![CDATA[조건식으로 검사되지 않은 포인터 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 포인터는 사용시에 주의해야 한다. 조건식을 통해 검사를 수행한 후에 포인터를 사용하도록 한다. 이때 outmode 파라미터로 사용되는 것은 허용한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_033</rule>
    <ruleTitle><![CDATA[null 값을 가지는 객체에 대해 dereference 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ null 값을 가지는 객체에 대해 dereference 하게 되면 memory access violation이 발생한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_034</rule>
    <ruleTitle><![CDATA[하나의 선언문에 2개 이상의 변수선언 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 모든 선언은 그 라인에 변수의 역할에 대한 설명 comment 가 있는 단일한 변수만을 위한 것이이어야 한다. 하나의 선언문에 다중 변수 선언은 변수들의 타입과 그들의 초기값에 관해서 혼란을 일으킬수 있다. 만약 하나이상의 변수가 하나의 선언문에 선언되면, 반드시 변수의 타입과 초기화 값에 주의해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_035</rule>
    <ruleTitle><![CDATA[하나의 선언문에 포인터와 포인터가 아닌 객체의 선언이 혼합되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 하나의 선언문에 포인터와 포인터가 아닌 객체의 선언이 혼합되었는지 검사한다. 포인터를 여러개 선언하려는 의도로 코드를 작성하였으나 포인터와 포인터가 아닌 객체로 선언되는 실수가 빈번하게 발생되고 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_036</rule>
    <ruleTitle><![CDATA[하나의 함수는 함수의 끝에 하나의 exit point를 가져야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ IEC 61508 표준에 의한 규칙으로, 이는 좋은 프로그래밍 스타일을 위한 것이다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_037</rule>
    <ruleTitle><![CDATA[Non-void return type 함수의 모든 출구는 하나의 명시적인 return 구문을 가져야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 이러한 함수를 사용하면 함수의 return 값이 출력 된다. 그런데 return 구문의 부재는 정의되지 않은 행동을 유발할 수 있다.(컴파일러에 따라 이런 형태를 에러로 보지 않을 수도 있다.) ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_038</rule>
    <ruleTitle><![CDATA[함수의 선언과 정의에서 return type이 동일하며 변수의 type 또한 동일해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 원형에서 변수와 return 값의 type은 정의와 일치해야 한다. 동일한 기본형식을 갖는 것 뿐 아니라 typedef 이름과 qualifier 까지 동일해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_039</rule>
    <ruleTitle><![CDATA[함수의 prototype 선언 시 모든 parameter를 위한 identifier가 주어져야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 호환성, 명확성, 유지 보수성(maintainability)을 위하여 함수 선언 시 모든 parameter를 위한 identifier의 이름이 주어져야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_040</rule>
    <ruleTitle><![CDATA[함수에 parameter가 없는 경우 void type parameter로 선언해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수는 return type과 함께 선언하는데, 함수에 return type이 없다면 void type으로 선언한다. 이와 비슷하게, 함수에 parameter가 없다면 parameter list는 void로 선언되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_041</rule>
    <ruleTitle><![CDATA[함수 identifier는 주소 값(&가 붙은 형태)으로 사용하거나, 괄호화 된 parameter 리스트(identifier 뒤에 ()을 붙임)로 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 identifier를 그대로 사용한다면 그 목적이 함수의 주소가 NULL이 아닌지를 테스트하는 것인지, 함수의 호출인지 명확하지 않다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_042</rule>
    <ruleTitle><![CDATA[void 타입 함수에서 값을 가진 return문이 존재하면 안됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 반환 타입이 void인 함수에서 반환 값은 사용되지 않는다. 만약 특정 표현식이나 값을 반환하는 코드가 존재한다면 프로그래머의 착오가 있었을 가능성이 크다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_043</rule>
    <ruleTitle><![CDATA[함수의 인자 수는 가변적으로 정의되서는 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수의 인자 수가 가변적이면 이로 인해 많은 문제가 발생할 가능성이 있다. 유저는 가변적인 인자 수를 가지는 함수를 사용해선 안 된다. 따라서 이와 같은 상황에서 이용되는  stdarg.h, va_arg, va_start, va_end는 사용을 금한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_044</rule>
    <ruleTitle><![CDATA[함수 호출 시 인자의 개수는 parameter의 수와 일치해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 이 문제는 함수 prototype의 사용으로 완전히 해결할 수 있다.(Rule 8.1 참조). ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_045</rule>
    <ruleTitle><![CDATA[함수 매크로는 모든 argument를 호출해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 이는 오류를 제한하지만, preprocessor는 이 문제를 무시할 수 있다. 함수 매크로 내에 각각의 argument는 적어도 하나의 preprocessing token으로 구성되어 있어야 한다. 그렇지 않으면 정의되지 않은 행동이 발생할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_046</rule>
    <ruleTitle><![CDATA[포인터 타입 파라미터를 사용하기 전에 검증이 존재하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 포인터 타입 파라미터를 사용하기 전에 검증하는 과정이 존재해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_047</rule>
    <ruleTitle><![CDATA[함수에서 반환되는 값이 검증되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 정의에서 반환되는 값으로 사용되는 object들은 검증하는 과정이 존재해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_048</rule>
    <ruleTitle><![CDATA[Expression의 값들은 표준이 허용하는 평가 순서가 같아야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 몇몇 연산자(함수 호출 연산자 (), &&, ||, ? :, ,(comma))와 별개로 평가된 sub-expression의 순서는 달라질 수 있다. 이것은 sub-expression의 평가 순서를 믿을 수 없다는 것을 의미하고, 특히 side effect가 발생하는 순서를 믿을 수 없다는 것을 의미한다. Expression 평가의 관점에서 이전에 일어난 모든 side effect는 발생되었음을 보장할 수 있고, 이것은 "sequence points"라고 부른다. 이러한 평가 순서는 괄호의 사용으로 해결할 수 없고, 단지 우선순위의 문제만은 아니다. 이 규칙에서는 모든 함수의 호출에서 side effect가 발생한다고 가정한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_049</rule>
    <ruleTitle><![CDATA[비트 필드 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 비트 필드 형식을 사용하면 안된다. 비트 마스크 기능으로 사용하기를 권장한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_050</rule>
    <ruleTitle><![CDATA[Basic numerical type 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Char, int, short, long, float 그리고 double 등의 basic numerical type은 사용하지 말아야 하며, 대신 크기와 부호를 나타내는 typedef를 사용해야 한다. 실제 구현에서 integer 크기를 이해하는 것은 매우 중요하다. 프로그래머는 아래의 정의와 같이 typedef로 실제 구현하는 방법을 알아야 한다. 32bit integer machine에서 다음과 같이 구현한다.
typedef		char	char_t;
typedef	signed	char	int8_t;
typedef	signed	short	int16_t;
typedef	signed	int	int32_t;
typedef	signed	long	int64_t;
typedef	unsigned	char	uint8_t;
typedef	unsigned	short	uint16_t;
typedef	unsigned	int	uint32_t;
typedef	unsigned	long	uint64_t;
typedef		float	float32_t;
typedef		double	float64_t;
typedef	long	double	float128_t; ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_051</rule>
    <ruleTitle><![CDATA[Function pointer type과는 integer type을 제외한 어떤 type 간에도 변환이 일어나선 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[ function pointer를 다른 pointer의 type으로 변환하는 것은 정의되지 않은 행동이다. 예를 들어 function을 가리키는 pointer는 function의 다른 type을 가리키도록 변환할 수 없다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_052</rule>
    <ruleTitle><![CDATA[Object의 포인터와는 integer type, 다른 object의 포인터 또는 void 포인터를 제외한 어떤 type간에도 변환이 일어나선 안 됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 위와 같은 변환은 정의되지 않은 변환이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_053</rule>
    <ruleTitle><![CDATA[Pointer type과 integral type간에 cast 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Pointer가 integer로 변환될 때 요구되는 integer의 크기는 구현 시 정의된다. pointer와 integer type간의 casting은 가능한한 피하는 것이 좋지만, 메모리 레지스터에 주소를 매핑할 때 또는 하드웨어의 특정 기능에 의해 피할 수 없는 경우도 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_054</rule>
    <ruleTitle><![CDATA[Object type을 가리키는 pointer를 다른 object pointer type으로 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 이러한 type의 변환은 새로운 pointer type이 엄격한 alignment를 요구하지 않으면 무효할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_055</rule>
    <ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ integer 변환(묵시적, 명시적 모두 포함)은 데이터의 손실이나 부호의 변동을 가져오면 안된다. 이런 변환은 배열의 참조자, 포인터 연산, 객체의 사이즈나 길이 등에서 신뢰하지 못하는 코드를 유발할 수 있다. 단, 해당 변환에 대해 미리 인지하고 검사를 완료한 코드는 허용한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_056</rule>
    <ruleTitle><![CDATA[implicit type conversion 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ implicit type conversion이 발생하면 안된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_057</rule>
    <ruleTitle><![CDATA[서로 다른 name space에서 같은 이름의 identifier를 정의해서는 안됨 (단, structure와 union member 이름은 제외) ]]></ruleTitle>
    <ruleDesc><![CDATA[ Name space와 scope는 다른 개념이다. 이 규칙은 scope는 고려하지 않는다. ISO C 표준은 수많은 name space를 정의한다. 서로 다른 name space에서 완전히 다른 item을 표현할 때 같은 이름을 사용하는 것은 기술적으로 가능하다. 그러나 이는 혼란을 가져올 수 있기 때문에 서로 다른 name space에서도 같은 이름을 재사용하면 안 된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_058</rule>
    <ruleTitle><![CDATA[객체나 함수가 한번 이상 선언된다면, 그 type은 호환 가능해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 호환 가능한 type의 정의는 길고 복잡하다. 두 개의 동일한 타입은 호환 가능해야 하지만 두 개의 호환 가능한 타입이 동일할 필요는 없다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_059</rule>
    <ruleTitle><![CDATA[float 타입 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ float 타입의 사용을 금지한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_060</rule>
    <ruleTitle><![CDATA[Floating-point expression은 equality 또는 inequality 검사에 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Floating-point type으로 equality를 비교할 때 true를 예상하더라도 실제로 결과가 잘못 나오는 경우가 있다. 게다가 어떤 비교의 행동은 실행 전에 예측할 수 없고, 구현 시 마다 달라질 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_061</rule>
    <ruleTitle><![CDATA[나눗셈에 음수가 사용되는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 나눗셈의 양 변에 음수가 사용되면 안된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_062</rule>
    <ruleTitle><![CDATA[% 연산자를 쓸 때 나머지가 양수라고 가정하지 마라 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C99 정의에서 % 연산자에 대한 결과의 부호는 피제수(표현식의 첫 번째 연산자)의 부호를 따른다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_063</rule>
    <ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ integer 변환(묵시적, 명시적 모두 포함)은 데이터의 손실이나 부호의 변동을 가져오면 안된다. 이런 변환은 배열의 참조자, 포인터 연산, 객체의 사이즈나 길이 등에서 신뢰하지 못하는 코드를 유발할 수 있다. 단, 해당 변환에 대해 미리 인지하고 검사를 완료한 코드는 허용한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_064</rule>
    <ruleTitle><![CDATA[우선 순위가 다른 연산자 혼용 시 괄호를 사용하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 우선 순위가 다른 연산자 혼용 시 괄호를 사용할 것을 권장한다. 연산자의 우선 순위를 완벽히 이해하지 못 한 채로 혼용하는 경우 의도와 다른 결과를 초래할 수 있기 때문이다.  ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_065</rule>
    <ruleTitle><![CDATA[논리 연산자 && 와 || 의 오른쪽 피연산자에 side effect 포함 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C 코드에서 expression의 어떤 부분은 실행되지 않는 경우가 있다. 만약 sub-expresssion들이 side effect를 포함한다면, 다른 sub-expression의 값에 따라 side effect는 발생 할 수도 하지 않을 수도 있다.
이러한 문제를 발생시키는 연산자는 &&, ||, 그리고 ? : 이다. 앞의 두 가지의 경우, 오른쪽 피연산자의 실행은 왼쪽 피연산자의 값에 따라 결정된다. ? : 연산자의 경우 두 번째 또는 세 번째 피연산자가 실행되지만 둘 다 실행되지는 않는다. 논리 연산자 중 하나에서 오른쪽 피연산자의 실행은 프로그래머가 side effect를 포함시킨다면 문제를 일으킨다. ? : 연산자는 두 개의 sub-expression 중 하나를 실행하기 때문에 실수를 하는 경우가 적다. 이 규칙에서는 모든 함수의 호출에서 side effect가 발생하지 않는다고 가정한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_066</rule>
    <ruleTitle><![CDATA[condition에서 가장 상위에  assign 연산자 사용 금지 : && 연산의 피연산자, || 연산의 피연산자, top-level에 assign 연산자 사용금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 결과가 boolean 값을 가지는 표현식의 내부에는 대입 연산자가 사용되면 안된다. 만약 boolean 값을 가지는 표현식에서 대입 연산자가 반드시 필요한 경우라면, 해당 표현식의 외부에서 따로 처리하여 사용하는 것을 권장한다. 그렇게 함으로써 =와 ==가 혼동되지 않도록 확실하게 처리할 수 있을 것이다. 만약 top-level 표현식이 && 연산자나 || 연산자로 이루어진 경우라면 해당 연산자에 대한 각각의 피연산자들도 모두 위의 검사를 수행해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_067</rule>
    <ruleTitle><![CDATA[다중 상속 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 다중 상속 금지 ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_068</rule>
    <ruleTitle><![CDATA[가상 함수 정의 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 가상 함수 정의 금지 ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_070</rule>
    <ruleTitle><![CDATA[동적할당이 없는 포인터에 free 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 동적으로 할당되지 않은 메모리를 해제하는것은 규칙 MEM31_C 에서 논의된사항들과 유사한 심각한 에러를 유발할수 있다. 이 에러의 구체적인 결과는 구현체에 의존적이지만 그 범위는 아무것도 아닌것에서 프로그램 종료에까지 걸쳐있다. 구현체를 막론하고, 동적메모리 할당 함수(malloc() 같은것)에 의해 반환된 포인터가 아닌 다른 어떤것에는 free() 호출을 피해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_071</rule>
    <ruleTitle><![CDATA[중복 free 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 중복해서 메모리를 free하는것은 free된 후에 메모리에 계속해서 접근히는것과 유사하다. (MEM30_C 참조) 
먼저, 할당해제된 메모리에 대한 포인터를 읽는것은 undefined behavior이다. 포인터값이 애매하고 trap representation 을 가지기 때문이다. 후자의 경우 그렇게 하는것은  hardware trap을 일으킨다. free된 포인터를 읽는것이 trap을 일으키지 않을때, heap을 관리하는 자료구조가 프로그램에 보안 취약점을 전파할수 있는 방식으로 깨질수 있다. 이런형태의 이슈는 double-free 취약점으로 지칭된다. 실제  double-free 취약점은 엉뚱한 코드를 실행하도록 활용될수 있다. 
double-free 취약점을 제거하기 위해, 동적으로 할당된 메모리가 정확히 한번만 해제되도록 보장할 필요가 있다. 프로그래머는 반복이나 조건문에서 메모리를 free할때 주의해야한다. 코드가 잘못되면, 이런 구조는 double-free 취약점으로 유도될수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_072</rule>
    <ruleTitle><![CDATA[errno를 사용하는 라이브러리 함수를 호출하기 전에 errno 값을 0으로 설정 ]]></ruleTitle>
    <ruleDesc><![CDATA[ errno의 값은 프로그램 기동시에 0 이지만, 어떤 라이브러리 함수에 의해서도 결코 0으로 설정되지 않는다. errno의 값은 C standard 에서 errno의 사용이 함수 설명에 기술되지 않은 라이브러리 함수 호출에 의해서 그것에 에러가 있건 없건간에 0이 아닌값으로 설정될수 있다. 그것은 단지 프로그램에 대해 오류가 보고된 이후 errno의 내용을  조사하기 위한 의미가 있을 뿐이다. 더 정확하게는, errno는 에러 코드를 반환한 에러로 errno를 설정하는 라이브리러 함수 이후에만 의미가 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_073</rule>
    <ruleTitle><![CDATA[수학함수가 안전하게 사용되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C99 Section 7.12.1 은 math.h에 있는 수학함수들에 대한 두 타입의 error를 정의하고 있다.   [ISO/IEC 9899:1999]:domain error 는 입력인자가 정의된 함수의 domain을 초월했을때 error를 일으킨다.  range error 는 함수의 수학계산 결과가 명세된 타입의 object에 표현될수 없다면( extreme magnitude 로인한 경우 등) error를 일으킨다. Domain errors 는 함수 호출 전 bounds checking 으로 예방될수 있다. Range errors 는 거의 예방할수 없지만, range errors를 예방하는 대신 그것을 탐지하고 range error가 발생했을때의 사후처리를 해야한다 ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_074</rule>
    <ruleTitle><![CDATA[파일 입출력 사이에 플러시나 파일 위치 조정 함수가 존재하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 파일 스트림에 대해서 입력 다음에 fflush 호출이나 파일 위치 조정 함수(fseek, fsetpos, rewind)의 호출 없이 바로 출력을 수행하면 안되며, 반대로 출력 다음에 파일 위치 조정 함수 없이 바로(입력에서 파일 끝에 도달하지 않은 이상) 입력을 수행하면 안된다. 구현에 따라서 텍스트 파일을 업데이트 모드로 여는 것(혹은 생성하는 것)이 실제로는 바이너리 스트림을 열 수도 있다.  ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_075</rule>
    <ruleTitle><![CDATA[FILE 포인터에 대해 중복 close 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ FILE 포인터에 대해 중복 close를 금지한다. close 대상 함수는 기본적으로 close와 fclose에 대해 처리하며, 추가로 입력이 가능하다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_076</rule>
    <ruleTitle><![CDATA[signed 정수 연산이 오버플로되지 않도록 보장해야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 정수 오버플로는 undefined behavior를 유발한다. 따라서 signed 정수에서의 연산이 signed 오버플로를 발생시키지 않도록 보장해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_077</rule>
    <ruleTitle><![CDATA[division by zero가 발생하면 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ /, % 연산자의 두 번째 피연산자로 0(zero)가 오면 undefined behavior가 발생한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_079</rule>
    <ruleTitle><![CDATA[Switch, while, do ... while, for 문의 body는 복합문이어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 비록 복합문 내에 하나의 statement만 존재하더라도 switch, while, do ... while, for 문은 복합문이어야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_080</rule>
    <ruleTitle><![CDATA[제어문의 brace 위치 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 제어문의 brace 위치를 준수하였는지 검사한다. 첫 번째 brace를 제어문의 바로 뒤에 사용하는 형태(KnR)와 제어문의 다음 줄에 사용하는 형태(BSD)가 있다. 이 룰에서는 두 가지 형태를 모두 허용한다. (단, 탭(tab)은 에디터에서 보이는 것과 상관없이 1컬럼으로 인식된다.) ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_081</rule>
    <ruleTitle><![CDATA[indentation 규칙 ]]></ruleTitle>
    <ruleDesc><![CDATA[ indentation을 준수하였는지 검사한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_082</rule>
    <ruleTitle><![CDATA[External identifier가 식별 가능한지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ external identifier는 31번 째 문자까지 식별이 가능하다. 따라서 길이가 31이 넘는 external identifier에 대해서 31번째문자 까지가 다른 external identifier에 대해 유일하여 식별 가능한지 확인해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_083</rule>
    <ruleTitle><![CDATA[중첩된 C 스타일 주석 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 몇몇 컴파일러는 언어의 확장으로 주석의 중첩을 허용하기도 하지만, C언어 표준에서는 이를 허용하지 않는다. 주석은 /*로 시작해서 처음으로 만나는 */에서 끝나는데, 주석 안에 /*가 있으면 주석의 끝이 생략되었다고 잘못 인식될 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_084</rule>
    <ruleTitle><![CDATA[C 스타일 주석만 사용해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 소스 코드 내에서 C 언어 고유 주석인 /*  */ 스타일 주석 만을 사용해야 한다. C99는 C++와의 호환성을 위해 //방식의 주석을 지원하지만, C90에서는 이를 지원하지 못한다. //방식의 주석은 전처리기 명령어에서 해석이 달라질 수 있고, 컴파일러마다 다르게 작용한다. 또한 /*  */ 과 // 주석 스타일을 혼용하는 것은 일관성이 없다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_085</rule>
    <ruleTitle><![CDATA[주석 스타일이 혼용되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C스타일 주석과 C plus plus 스타일의 주석이 혼용되었는지 검사한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_086</rule>
    <ruleTitle><![CDATA[함수의 코드 라인 수(LOC) 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 프로그램이 분석 가능하도록 구조화 규칙에 맞게 작성해야 한다. 이를 위해 모듈을 잘 설계해야 한다. 하나의 함수의 코드 라인수(LOC)가 100 이하가 되도록 하는 것이 좋다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_087</rule>
    <ruleTitle><![CDATA[question 연산자 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ question 연산자 사용을 제한한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_088</rule>
    <ruleTitle><![CDATA[조건문에서 bitwise 연산자 (&,|) 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ bitwise AND (&, ampersand) 또는 bitwise OR (|, pipe) 연산자를 조건식에서 사용하지 말라.  이것은 전형적으로 프로그래머에게 실수를 유발하고 예측하지 못한 작동을 하는 결과가 될수 있다. & 또는 | 는 bitwise 연산에서만 쓰고, && 또는 || 는 논리 연산에서만 써야한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_089</rule>
    <ruleTitle><![CDATA[pointer to member(function/field) 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ pointer to member(function/field) 사용 금지 ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_090</rule>
    <ruleTitle><![CDATA[#include 앞에는 다른 preprocessor directive나 주석만 허용 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 모든 #include 문은 특정 코드 파일에서 파일의 head 근처에 그룹화 되어야 한다. 파일 내에에서 #include 앞에 올 수 있는 것은 preprocessor directive 또는 주석 뿐이다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_091</rule>
    <ruleTitle><![CDATA[external 함수 선언이 헤더에 있는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ external 함수 선언이 헤더에 존재해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_092</rule>
    <ruleTitle><![CDATA[매크로 정의시 괄호 및 꺽쇠(brace, parenthesis, bracket) 짝이 맞는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 매크로 정의시 괄호 및 꺽쇠(brace, parenthesis, bracket) 짝이 맞게 사용되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_093</rule>
    <ruleTitle><![CDATA[함수 매크로의 정의에서 각 parameter들은 괄호에 의해 감싸져야 함(단, #이나 ##의 피연산자로 사용하는 경우는 제외) ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 매크로의 정의에서 argument는 괄호로 감싸져야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_094</rule>
    <ruleTitle><![CDATA[숫자 상수 매크로 정의 금지 (const identifier 권장) ]]></ruleTitle>
    <ruleDesc><![CDATA[ 숫자 상수 매크로 정의를 금지한다. 숫자 상수의 사용은 const identifier 권장한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Nuclear</ruleSetName>
    <ruleSetDesc><![CDATA[한전 원자력 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_NUREG_095</rule>
    <ruleTitle><![CDATA[extern 객체나 함수는 오직 하나의 파일에서만 선언되어야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ identifier가 선언되고 사용되는 다른 모든 파일에 include 되는 헤더파일에 external identifier를 선언해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_API00_C</rule>
    <ruleTitle><![CDATA[FILE 타입을 파라미터로 가지는 함수에서 파라미터에 대한 검증이 존재하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C와 C++커뮤니티에서 방어적인 프로그래밍의 일부로 거론 되어지는 함수 호출자와 피호출자에서 일어나는 중복되는 검증의 큰 문제는 퍼포먼스에 있다. 어느 한쪽에서만 검증이 이루어지는 체계가 필요하다. 호출자에서 검증이 이루어지면 잘못된 값이 인자로 전달되는 자체를 막아주기 때문에 효율적이다. 피호출자에서 검증이 이루어지면 코드가 한 부분에 캡슐화되어 코드의 양이 줄고 일관적인 검증이 가능해진다. 안전과 보안상의 이유로 이 표준에서는 피호출자에서 파라미터를 검증하는 것을 추천한다.  ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_API03_C</rule>
    <ruleTitle><![CDATA[표준 라이브러리에 있는 매크로,객체,함수들의 이름은 재사용 되어선 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 라이브러리 함수는 지속적으로 사용가능한 인터페이스가 되도록 유지되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_API04_C</rule>
    <ruleTitle><![CDATA[일관적으로 사용 가능한 오류 처리 메커니즘을 사용하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ strlcpy()는 strcpy()보다 안전하고 일관적으로 설계되었으나 오류 처리에 대해서는 사용자가 직접 코드를 작성해야 한다. strcpy_m()은 오류 값을 반환하기 때문에 보다 일관적으로 구현이 가능하다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_API07_C</rule>
    <ruleTitle><![CDATA[타입의 안전성을 보장하는 함수 사용 권장 ]]></ruleTitle>
    <ruleDesc><![CDATA[ strncpy()는 결과 문자열이 null로 종료된다는 것을 보장하지 않는다. 따라서 결과 문자열이 null로 종료되지 않았을 경우를 반환값으로 검사할 수 있는 strncpy_s()의 사용을 권장한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_API09_C</rule>
    <ruleTitle><![CDATA[호환되는 값은 같은 타입을 가져야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 호환되는 값은 같은 타입을 가져야 한다. 예를 들어 어떤 함수의 반환값이 다른 함수의 인자로 사용된다고 할 때, 해당 타입들은 같은 타입을 가지도록 해야 묵시적인 변환으로 부터 발생하는 오류를 줄일 수 있다. 쉽게 범할 수 있는 오류로 size_t 타입과 ssize_t 타입을 구분없이 사용하는 경우가 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_ARR02_C</rule>
    <ruleTitle><![CDATA[배열의 사이즈 명시되고 initialize와 일치하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C표준은 bound와 초기화 literal로 선언되는 배열 변수를 허용한다. 초기화 literal은 또한 명세된 원소들의 수 이내의 배열 bound를 뜻한다. 
컴파일러들이 그들의 초기화 목록에 기반한 배열의 크기를 계산할수 있지만, 명시적으로 배열의 크기를 명세하는것은 배열 크기가 올바른지를 확인할수 있는 여분의 검사를 제공한다. 그것은 또한 컴파일러에게 배열크기 초기화에 의해 암시되는 크기보다 작으면 경고를 해줄수 있도록 한다. 
이 제안은 (모든 경우에서) string literal로 초기화되는 charcter배열에는 적용하지 않는다. STR36_C를 참조. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_ARR30_C</rule>
    <ruleTitle><![CDATA[배열의 인덱스가 유효한 범위 안에 있음을 보장해야 함 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 아래 식에서, index가 0보다 작을때 return 문장에서 증가 식의 동작은 undefined 43 이다. 어떤 구현체에서 증가는 하드웨어 trap을 작동시킬수 있다. 또 다른 구현체에서 증가는 역참조되었을때 하드웨어 trap을 작동시키는 결과를 만들어낼수 있다. 또 다른 구현체는 테이블로부터 동떨어진 object를 가리키는 포인터를 역참조하는 포인터를 만들어낼수도 있다. object에 접근하는 이러한 포인터를 사용하는것은 정보를 노출하거나 잘못된 object 변경되는 경우를 일으키도록 유도할수 있다. 

int* f(int index) { 
... 
static int table[TABLESIZE]; 
... 
return table + index; 
}  ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_ARR31_C</rule>
    <ruleTitle><![CDATA[Array 변수의 선언마다 type이 일치하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 배열은 관련된 모든 소스파일에 대해서 일관적인 타입을 사용해야 한다. 단, 같은 파일 내에서 배열이 함수의 인자로 전달되면 포인터로 변환되기 때문에 이 경우에는 강하게 요구되지 않는다. 그러나 함수 프로토타입 밖에서는, 만약 배열이 한 파일에서 포인터 표기를 사용해 선언되었지만 다른 파일에서 배열 표기로 사용되고 있다면, 두 표기는 같지 않다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_ARR32_C</rule>
    <ruleTitle><![CDATA[배열의 인덱스로 음수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Variable-length arrays (VLA) 는 그들이 integer 상수 식이 아닌 크기로 선언되고 block 스코프 또는 함수 prototype 스코프에서만 선언될수 있고 linkage를 가지지 않는 점을 제외하고 본질적으로 전통적인 C 배열과 같다. variable-length array 는 integer 식의 크기와 vla의 선언이 둘다 실행시간에 평가되는 곳에서 선언될수 있다. variable-length array 에 제공되는 크기 argument가 양의 integer 값이 아니면 undefined behavior 이다(C99의 Annex J 의 undefined behavior 69 참고). 더해서, argument의 크기가 과도하면 프로그램이 예측하지 못한방식으로 동작할수 있다. 공격자는 치명적인 프로그램 데이타를 덮어씀으로서 이 동작을 유발시킬수 있다[Griffiths 2006]. 프로그래머는 반드시 variable-length arrays로의 크기 argument 가 올바른지 예외적 integer 조건의 결과로 인해 깨져있지는 않은지 확인해야 한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_ARR33_C</rule>
    <ruleTitle><![CDATA[memcpy 함수 사용시 배열에 복사 할 때 오버플로가 발생하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 데이터를 배열에 복사할 때 충분한 공간을 확보하지 않으면 오버플로가 발생한다.  ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_ARR34_C</rule>
    <ruleTitle><![CDATA[배열 타입에 대한 incompatible type 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C99  section 6.7.5.2 에 따라, 식에 둘 혹은 그 이상의 incompatible array 사용은 undefined behavior를 일으킨다. Appendix J의 undefined behavior 70 참조. compatible해져야 할 두 array 타입에 대해, 양쪽은 compatible underlying element type을 가져야 하고 , 양쪽의 size specifier는 같은 상수값을 가져야 한다. 둘중 하나가 위배되면 undefined behavior를 일으킨다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_ARR36_C</rule>
    <ruleTitle><![CDATA[포인터 타입에 대한 >, >=, <. <= 연산은 같은 배열의 요소에 대한 pointer에 대해서만 적용 가능 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 두 개의 포인터로 뺄셈을 수행하려면 두 포인터가 같은 배열을 참조하거나 적어도 배열의 마지막 원소 다음 부분을 가리키고 있어야 한다. 이때 결과 값은 배열에서 두 원소 간의 거리가 된다. 이때 C에서의 포인터 뺄셈은 두 포인터 간의 객체 수를 나타내며 바이트 수를 나타내진 않는다는 제한이 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_ARR37_C</rule>
    <ruleTitle><![CDATA[pointer 연산은 배열이나 배열 요소에 대한 pointer만 적용 가능 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 배열의 원소를 참조하는 포인터에 대해서만 산술 연산을 수행해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CON33_C</rule>
    <ruleTitle><![CDATA[라이브러리 함수 사용 시 발생할 수 있는 race condition을 방어하는 함수 사용 권장 ]]></ruleTitle>
    <ruleDesc><![CDATA[ strerror()는 사람이 읽을 수 있는 오류 내용을 반환한다. 하지만 이 오류 문자열은 다른 스레드에서 접근하고 수정이 가능하기 때문에 항상 일정하게 오류 문자열을 출력하는 것을 보장할 수 없다. 따라서 스레드 안정성을 보장하는 strerror_r()의 사용을 권장한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-119</rule>
    <ruleTitle><![CDATA[메모리 버퍼의 경계에서 부적절한 제한이 발생하는 연산 수행 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 응용프로그램은 메모리 버퍼에서 동작되지만, 버퍼의 경계를 벗어나는 메모리 주소에는 읽기나 쓰기가 불가능하다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-120</rule>
    <ruleTitle><![CDATA[입력 값의 크기를 검사하지 않고 버퍼를 복사하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 입력 값과 출력 값의 크기를 고려하지 않고 복사를 수행하는 경우 버퍼 오버플로가 발생할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-121</rule>
    <ruleTitle><![CDATA[스택 기반에서 버퍼 오버플로가 발생하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 스택 기반 버퍼 오버플로는 스택에서 이미 할당된 버퍼의 공간을 벗어난 접근이 발생할 때 일어난다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-122</rule>
    <ruleTitle><![CDATA[힙 기반에서 버퍼 오버플로가 발생하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 힙 오버플로는 일반적으로 malloc()과 같은 함수를 통해 힙에서 할당된 버퍼의 공간을 벗어난 접근이 발생할 때 일어난다.  ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-129</rule>
    <ruleTitle><![CDATA[검증된 배열 인덱싱인지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 배열을 사용하거나 계산할 때, 검증되지 않았거나 잘못된 방법으로 검증되어 신뢰할 수 없는 입력값을 사용해서는 안된다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-131</rule>
    <ruleTitle><![CDATA[버퍼 사이즈에 대해 잘못된 계산이 있는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 버퍼 할당 시에 버퍼 사이즈에 대한 잘못된 계산은 오버플로를 초래할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-135</rule>
    <ruleTitle><![CDATA[멀티 바이트로 구성된 문자열에 대해 잘못된 길이 계산이 있는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 와이드형 문자 혹은 멀티 바이트 문자 를 포함하는 문자열에 대한 잘못된 계산으로 오류가 발생할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-14</rule>
    <ruleTitle><![CDATA[메모리 초기화 관련 함수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 컴파일러가 프로그램 생성 시 사용되지 않거나 필요하지 않은 코드를 제거할 수 있다. 일반적으로 이런 방식은 이득이 되지만, 컴파일러가 필요 없다고 판단해 제거한 코드가 사실은 보안상의 이유로 추가된 것일 수 있다. 민감한 데이터를 저장하는데 사용한 버퍼를 지우기 위해 덮어쓰기를 수행하는 경우를 예로 들 수 있다. 따라서 민감한 데이터를 다룰 때는 의도한 대로 동작하는지 확인해봐야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-170</rule>
    <ruleTitle><![CDATA[널 종료 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 문자열은 널 문자 또는 그와 동등한 종료자로 종료되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-190</rule>
    <ruleTitle><![CDATA[정수 오버플로 또는 wraparound 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 계산된 결과의 타입이 결과의 값을 항상 포함할 수 있을 것이라고 가정할 때 정수 오버플로 또는 wraparound가 발생할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-192</rule>
    <ruleTitle><![CDATA[강제 정수 변환 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 강제 정수 변환은 primitive 데이터 타입의 잘림, 확장, 변환등에서 결점을 가지게 된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-193</rule>
    <ruleTitle><![CDATA[off-by-one 오류 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 최대값 또는 최소값 계산을 1 많거나, 1 모자르게 잘못 계산하여 오류가 발생할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-20</rule>
    <ruleTitle><![CDATA[입력값이 검증되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 제어 흐름이나 자료 흐름에 영향을 줄 수 있는 입력값은 사전 검증이 필요하다. 사전 검증이 없다면, 공격자가 입력값에 의도적으로 공격을 하여 어플리케이션이 예측하지 못한 오류로 작동에 이상이 생기게 할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-242</rule>
    <ruleTitle><![CDATA[위험이 내재하는 함수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 안전하다고 보장되지 않는 함수의 사용을 금지한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-252</rule>
    <ruleTitle><![CDATA[함수의 반환값을 확인하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 예상하지 못하는 상황이나 조건에 대비하여 메서드나 함수의 반환값을 확인하였는지 검사한다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-311</rule>
    <ruleTitle><![CDATA[중요한 정보를 암호화 하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 중요한 정보는 저장이나 전파 이전에 암호화 되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-327</rule>
    <ruleTitle><![CDATA[안전하지 않은 암호화 알고리즘을 사용하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 안전하지 않은 암호화 알고리즘은 중요한 정보를 노출시킬 수 있으며 불필요한 리스크를 초래할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-330</rule>
    <ruleTitle><![CDATA[적당하지 않은 무작위 수 사용 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 예측할 수 없는 번호를 통한 보안 체계에 적당하지 않은 무작위 수나 값을 사용하면 안된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-369</rule>
    <ruleTitle><![CDATA[Devide by zero 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 어떤 값을 0으로 나누면 안된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-390</rule>
    <ruleTitle><![CDATA[함수의 반환값에 대해 오류 검증을 하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 많은 함수는 유효한 값을 반환하기도 하고 -1이나 null 포인터와 같은 오류 값을 반환하기도 한다. 함수의 성공적인 수행을 확인하기 위하여 반환값을 검사해야 한다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-391</rule>
    <ruleTitle><![CDATA[오류 검증 여부 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 오류나 예외를 무시하는 것은 공격자가 예상하지 못한 행동을 쉽게 유발시킬 수 있게 한다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-416</rule>
    <ruleTitle><![CDATA[메모리가 해제된 객체가 사용되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ free된 메모리를 사용하면 예상하지 못하는 값에 접근하게 되어 프로그램에 충돌이 발생한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-456</rule>
    <ruleTitle><![CDATA[초기화 누락 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 특정 상황에서 중요한 역할을 하는 변수들은 사용 전에 초기화되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-464</rule>
    <ruleTitle><![CDATA[자료 구조 sentinel 추가 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 자료 구조 sentinel이 추가되는 것은 프로그램 로직에 심각한 문제를 일으킬 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-466</rule>
    <ruleTitle><![CDATA[pointer type과 integer type 간 명시적 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 정수와 포인터를 서로 변환하는 일이 C에서 일반적이기는 하지만, 포인터에서 정수로, 정수에서 포인터로 변환하는 것은 구현마다 다르게 정의하고 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-467</rule>
    <ruleTitle><![CDATA[sizeof()의 인자로 포인터 변수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 특정 타입의 사이즈를 결정할 때 포인터 타입의 사이즈를 사용하면 안된다. 포인터 타입의 사이즈는 포인터가 가리키는 타입의 사이즈가 아니다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-469</rule>
    <ruleTitle><![CDATA[포인터 뺄셈 연산의 사용 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 배열의 원소를 참조하는 포인터에 대해서만 산술 연산을 수행해야 한다. 그리고 두 개의 포인터로 뺄셈을 수행하려면 두 포인터가 같은 배열을 참조하거나 적어도 배열의 마지막 원소 다음 부분을 가리키고 있어야 한다. 이때 결과 값은 배열에서 두 원소 간의 거리가 된다. 이때 C에서의 포인터 뺄셈은 두 포인터 간의 객체 수를 나타내며 바이트 수를 나타내진 않는다는 제한이 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-476</rule>
    <ruleTitle><![CDATA[메모리 할당 함수의 반환값이 검증되지 않아 null 포인터 참조가 시도되는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ null 포인터 결과값을 참조하려는 시도는 undefined behavior이다.  ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-480</rule>
    <ruleTitle><![CDATA[잘못된 연산자 사용 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 프로그래머는 의도하지 않게 잘못된 연산자를 사용할 수 있으며, 이는 어플리케이션의 로직에 변화를 줄 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-561</rule>
    <ruleTitle><![CDATA[도달 불가능한 코드 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 전혀 실행되지 않는 코드는 죽은 코드라고 불린다. 일반적으로 죽은 코드는 프로그램 자체나 환경의 변화로 인해 논리 에러가 발생했음을 암시한다. 죽은 코드는 컴파일되는 동안 프로그램에서 최적화되어 날아가는 게 일반적이다. 하지만 논리 에러가 해결됐음을 보장하고 프로그램의 가독성을 높이기 위해 죽은 코드를 찾아 파악한 후 제거해야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Dead Code</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-562</rule>
    <ruleTitle><![CDATA[스택 변수의 주소 반환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 스택 메모리 변수의 주소를 반환하는 것은 의도하지 않는 행동으로 오류를 유발할 수 있으며 보통의 경우엔 충돌이 발생한다. 스택 메모리가 다른 용도로 사용될 시점에 버퍼로 할당됐던 메모리 영역이 다른 데이터로 덮어 쓰였을 가능성이 있다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-628</rule>
    <ruleTitle><![CDATA[함수 호출의 인자가 정확한지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 호출 시 인자로 정확하지 않은 값이 전달되면 그 결과도 정확할 수 없다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-665</rule>
    <ruleTitle><![CDATA[부적절한 초기화 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 초기화가 적절하지 못하면 그 데이터를 접근하거나 사용하는 시점에 예측할 수 없는 오류가 발생할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-676</rule>
    <ruleTitle><![CDATA[잠재적으로 위험성을 가진 함수 사용 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 사용 자체에는 문제가 없다고 하더라도 잠재적으로 위험성을 가지는 함수들의 사용을 자제해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-681</rule>
    <ruleTitle><![CDATA[Numeric 타입 사이의 부정확한 변환 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 어떤 데이터를 다른 타입으로 변환할 때, 데이터가 손실되거나 예상하지 못한 값으로 변경될 수 있다. 중요한 데이터라면 큰 오류로 이어질 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-682</rule>
    <ruleTitle><![CDATA[부정확한 계산 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 잘못된 계산으로 인하여 부정확한 값이나 의도하지 않은 값을 가지게 되면 자원 관리나 보안상의 문제에 대해 오류를 초래할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-686</rule>
    <ruleTitle><![CDATA[함수 호출의 인자로 부정확한 타입 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 호출시 인자로 잘못된 데이터 타입이 사용되면 오류가 발생할 가능성이 크다. 또한 그 결과 값도 신뢰할 수 없게 된다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-687</rule>
    <ruleTitle><![CDATA[함수 호출의 인자로 부정확한 값 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 호출시 인자로 잘못된 값이 사용되면 오류가 발생할 가능성이 크다. 또한 그 결과 값도 신뢰할 수 없게 된다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-704</rule>
    <ruleTitle><![CDATA[잘못된 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 어떤 타입과 서로 다른 타입 사이에 적절하지 않은 변환이 존재하면 안된다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-705</rule>
    <ruleTitle><![CDATA[잘못된 제어 흐름 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수의 기능이 다 끝나기 전에 비정상 종료가 수행되면 정상적인 제어 흐름으로 진행될 수 없다. ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-754</rule>
    <ruleTitle><![CDATA[비정상적이거나 예외적인 조건에 대해 잘못된 검증이 발생하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 종종 발생할 수 있는 비정상적이거나 예외적인 조건에 대해 정확한 검증이 필요하다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-768</rule>
    <ruleTitle><![CDATA[잘못된 short-circuit 평가 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 조건식에서 논리 연산자가 2개 이상 결합된 경우 우변의 표현식들은 side-effect를 가져서는 안된다. 조건에 따라 해당 표현식들이 평가되지 않을 수 있기 때문이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-788</rule>
    <ruleTitle><![CDATA[버퍼를 넘어서는 접근 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 버퍼 공간의 끝을 넘어서는 인덱스나 포인터에 대해 읽기나 쓰기를 수행하는 것에 대한 행동은 정의되어 있지 않다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_CWE-805</rule>
    <ruleTitle><![CDATA[잘못된 길이 값으로 버퍼에 접근하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 버퍼에 대해 읽고 쓰는 연산들이 잘못된 버퍼의 길이 값을 가지고 있으면 버퍼의 경계를 넘어서는 곳에 접근하는 오류가 발생한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_DCL01_C</rule>
    <ruleTitle><![CDATA[scope상에서 동일한 identifier 가리는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 한 스코프 영역이 다른 스코프 영역 안에 포함돼 있는 경우 두 스코프에서 동일한 변수 이름을 사용하지 마라. 변수 이름을 재사용할 경우, 프로그래머 입장에선 어떤 변수가 변경되고 있는지 헷갈린다. 변수 이름이 재사용되고 있는 자체가 이름이 너무 일반적이라는 점을 알려준다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_DCL02_C</rule>
    <ruleTitle><![CDATA[identifier에 혼동 가능한 문자 사용 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 유사한 이름을 가지는 identifier 사이에서 혼동의 여지가 있는 문자의 사용을 검사한다. 혼란의 여지가 있는 문자들로는 여러가지가 있지만, 식별이 어려워 문제가 야기될 것이라 판단되는 0(zero)-O(capital o), 1(one)-l(lowercase L)-I(capital i)에 대해 검사한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_DCL03_C</rule>
    <ruleTitle><![CDATA[assert 매크로 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ runtime assert는 incorrect assumptions 을 확인하기 위해서만 사용해야 하고, runtime error checking 에서는 사용해서는 안된다. 결과적으로 runtime assertions 은 일반적으로  unsuitable 하다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_DCL04_C</rule>
    <ruleTitle><![CDATA[하나의 선언문에 2개 이상의 변수선언 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 모든 선언은 그 라인에 변수의 역할에 대한 설명 comment 가 있는 단일한 변수만을 위한 것이이어야 한다. 하나의 선언문에 다중 변수 선언은 변수들의 타입과 그들의 초기값에 관해서 혼란을 일으킬수 있다. 만약 하나이상의 변수가 하나의 선언문에 선언되면, 반드시 변수의 타입과 초기화 값에 주의해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_DCL05_C</rule>
    <ruleTitle><![CDATA[function pointer type을 typedef로 사용했는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 코드의 가독성을 높이기 위해 타입 정의(typedef)를 사용하는 것을 권장한다. 함수 포인터 타입의 경우에는 타입 정의를 사용하지 않으면 읽기 어렵고 이해하기도 힘들어진다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_DCL07_C</rule>
    <ruleTitle><![CDATA[함수 정의 시 old style parameter 선언 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수는 정확한 타입 선언 정보를 가진 형태로 정의되어야 한다. 만약 함수 선언이 명확하게 구체화되지 않은 경우, 컴파일러에서 함수 타입 정보에 대한 정확한 검사를 할 수 없게 된다. 검사의 일환으로 NonPrototype-Format 선언을 금지한다. C99 표준에서 파라미터 식별자와 선언리스트의 분리는 구식의 방법이라 말하고 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_DCL08_C</rule>
    <ruleTitle><![CDATA[상수 정의에 상수간의 관계가 적절히 나타나게 정의되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 한 정의가 다른 정의에 영향을 미친다면 둘 간의 관계를 인코딩하고 각각을 따로 정의하지 마라.  ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_DCL13_C</rule>
    <ruleTitle><![CDATA[포인터 타입의 인자가 수정되지 않았을 때 const가 선언되었는지 여부 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수의 매개 변수를 const로 선언하는 것은 함수가 그 값을 바꾸지 않는다고 약속하는 것과 같다. 함수는 포인터 인자로 참조되는 값을 수정할 수도 있고, 이렇게 수정된 값은 함수가 반환한 후에도 지속된다. 포인터가 참조하는 값을 바꾼 부분은 의도적일 수 있기 때문에 컴파일러가 이를 검사하지는 않는다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_DCL15_C</rule>
    <ruleTitle><![CDATA[하나의 파일에서만 쓰인 파일 scope 변수나 함수가 internal linkage를 가지는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 객체나 함수가 현재 스코프 밖에서 보일 필요가 없다면 static으로 선언되어 외부로부터 가려져야 한다. 이렇게 하면 모듈화된 코드를 만들고 전역 네임스페이스가 복잡해지는 것을 제한할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_DCL19_C</rule>
    <ruleTitle><![CDATA[변수나 함수가 사용 가능한 최소 범위에서 선언되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 변수와 함수는 사용 가능한 최소 범위에서 선언되어야 한다. 더 큰 스코프에서 사용할 수 있도록 하는 것은 가독성이 떨어지고, 유지가 어려워진다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_DCL20_C</rule>
    <ruleTitle><![CDATA[함수 선언과 정의시 파라미터가 없을 경우 명시적인 void 타입 파라미터를 선언했는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수에 인자가 없는 경우라도 반드시 void를 명시해주어야 컴파일러에서 파라미터를 가진 함수인지 검사하지 않는다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_DCL30_C</rule>
    <ruleTitle><![CDATA[automatic 객체의 주소는 그것이 더이상 존재하지 않게 된 후에도 남아있을수 있는 다른 객체에 할당되면 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 객체는 프로그램 수행 시 자신에게 할당된 저장공간이 있는 부분에 존재한다. 객체가 상수 주소를 갖고 존재한다면 자신의 수명 내에서 마지막으로 저장된 값을 계속 유지하고 있을 것이다. 객체가 자신의 수명을 다한 후에도 참조된다면, 정의되지 않은 행동을 유발할 수 있다. 수명을 다한 객체를 참조하는 포인터 역시 정의되지 않은 값을 갖게 된다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_DCL31_C</rule>
    <ruleTitle><![CDATA[함수나 변수의 선언이나 정의 시 type을 명시하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C99 표준은 타입 지정을 항상 요구하고 암시적 함수 선언을 금지한다. 하지만 컴파일러는 이 제한이 나오기 전에 만들어진 코드들과의 호환을 위해 먼저 코드를 진단해보고 암시적 선언을 허용하는 것으로 가정해 컴파일한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_DCL32_C</rule>
    <ruleTitle><![CDATA[External identifier가 식별 가능한지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ external identifier는 31번 째 문자까지 식별이 가능하다. 따라서 길이가 31이 넘는 external identifier에 대해서 31번째문자 까지가 다른 external identifier에 대해 유일하여 식별 가능한지 확인해야 한다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_DCL35_C</rule>
    <ruleTitle><![CDATA[function pointer 변수에 return 타입이 일치하지 않는 function assign 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ function pointer 변수에 return 타입이 일치하지 않는 function assign하였는지 검사한다. function pointer에 대응하는 function의 타입이 compatible하지 않으면, function pointer를 사용시 undefined behavior가 발생한다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_DCL36_C</rule>
    <ruleTitle><![CDATA[함수나 변수의 선언마다 type이 호환되는지(compatible) 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 다른 스코프에서 정의된 식별자나 한 스코프에서 여러 번 선언된 식별자는 링크 과정을 통해 같은 객체나 함수를 참조할 수 있다. 식별자는 외부 링크, 내부 링크, 링크 없음으로 분류된다. 외부 링크와 내부 링크를 모두 갖는 것으로 분류되는 식별자를 사용하면 정의되지 않은 행동을 초래할 수 있다. 컴파일 단위는 전처리 지시자 #include 로 포함되는 모든 소스와 헤더 파일과 소스 파일 자체를 포함한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_DCL37_C</rule>
    <ruleTitle><![CDATA[예약된 식별자를 재선언하거나 재정의 하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 예약된 식별자를 재선언 하거나 재정의 하여 사용하는 것은 정의되지 않은 행동을 유발한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_ENV30_C</rule>
    <ruleTitle><![CDATA[getenv(), setlocale(), localeconv(), strerror() 함수들의 반환 값을 변경하면 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ getenv(), setlocale(), localeconv(), strerror() 함수들의 반환 값을 변경하는 것은 undefined behavior를 유발한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_ENV31_C</rule>
    <ruleTitle><![CDATA[ setenv(), _putenv_s() 함수 호출 후 main() 함수의 세번 째 인자 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 윈도우 _putenv_s() 함수를 호출했거나 환경변수를 수정하는 다른 값을 수정한 경우라면 envp 포인터는 더 이상 환경변수를 참조하고 있지 않을 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_ENV32_C</rule>
    <ruleTitle><![CDATA[atexit 핸들러에서 반환 이외의 방법으로 종료(exit, longjmp)되면 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ atexit() 에 등록된 핸들러는 어떤 방법으로도 반환하지 않고 직접 프로그램을 종료해서는 안된다. atexit() 핸들러 전부가 클린업 동작을 수행하게 해주는 일은 매우 중요하며, 보안에 민감한 부분이기도 하다. 특별히 애플리케이션 프로그래머가 알지 못하는 지원 라이브러리에 의해 핸들러가 설치된 경우 더욱 그렇다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_ERR02_C</rule>
    <ruleTitle><![CDATA[sprintf 함수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ sprintf 함수 대신 오류 코드를 반환하는 sprint_m의 사용을 권장한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_ERR03_C</rule>
    <ruleTitle><![CDATA[TR 24731-1에 정의된 함수를 호출할 때는 런타임 지정 핸들러를 사용하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ ISO/IEC TR 24731-1-2007 에 의해 정의된 대부분 함수들은 그들의 명세의 일부로서 실행시간 제약들의 목록인 실행시간에 다루어질수 있는 위배사항들을 포함한다[ISO/IEC TR 24731-1:2007]. 라이브러리 구현체는 함수에 대한 실행시간 제약들이 프로그램에 의해 위배되지는 않았는지 반드시 검사해야한다. 만약 실행시간 제약들이 위배되면, 일반적으로 set_constraint_handler_s()로 등록한 실행시간 제약 핸들러가 호출된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_ERR07_C</rule>
    <ruleTitle><![CDATA[동일한 기능을 하는 함수라면 오류 검사를 제공하는 함수 사용을 권장 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 동일한 기능을 수행하는 두 개의 함수 중 하나를 선택해야 한다면, 오류를 검사하고 보고해주는 함수를 사용할 것을 권장한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_ERR30_C</rule>
    <ruleTitle><![CDATA[errno를 사용하는 라이브러리 함수를 호출하기 전에 errno 값을 0으로 설정 ]]></ruleTitle>
    <ruleDesc><![CDATA[ errno의 값은 프로그램 기동시에 0 이지만, 어떤 라이브러리 함수에 의해서도 결코 0으로 설정되지 않는다. errno의 값은 C standard 에서 errno의 사용이 함수 설명에 기술되지 않은 라이브러리 함수 호출에 의해서 그것에 에러가 있건 없건간에 0이 아닌값으로 설정될수 있다. 그것은 단지 프로그램에 대해 오류가 보고된 이후 errno의 내용을  조사하기 위한 의미가 있을 뿐이다. 더 정확하게는, errno는 에러 코드를 반환한 에러로 errno를 설정하는 라이브리러 함수 이후에만 의미가 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_ERR32_C</rule>
    <ruleTitle><![CDATA[시그널 핸들러에서의 금지함수 ]]></ruleTitle>
    <ruleDesc><![CDATA[ [ISO/IEC 9899-1999]에 따르면 abort 또는 raise 함수, 그리고 signal 함수 호출로부터 리턴되는 SIG_ERR을 취한 그에 대응하는 signal handler 호출의 결과로서가 아닌 signal 발생 이후의 errno의 값이 참조될때, 프로그램은 undefined behavior이다. (Annex J 의 undefined behavior 126 참고) 
signal handler는 signal()을 호출하도록 허용되고 만약 실해하면 signal()은 SIG_ERR를 반환하고 errno을 양의 값으로 설정한다. 그러나 signal을 일으킨 사건이 external 이었다면 signal handler 가 호출하게 될 함수는 _Exit() 또는 abort() 또는 현재 처리중인 signal 상의 signal() 뿐이고, signal()이 실패하면 errno값은 정해지지 않는다. 
이 규칙은 SIG31_C의 특별한 경우이다. errno에 의해 지정되는 객체는 static 저장소 수명을 가지고 volatile sig_atomic_t 가 아니다. 결과적으로, errno가 설정될 필요가 있을 어떤 액션을 취하는것은 대개 undefined behavior를 일으킬것이다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_ERR33_C</rule>
    <ruleTitle><![CDATA[함수의 반환값에 대해 오류 검증을 하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 많은 함수는 유효한 값을 반환하기도 하고 -1이나 null 포인터와 같은 오류 값을 반환하기도 한다. 함수의 성공적인 수행을 확인하기 위하여 반환값을 검사해야 한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP00_C</rule>
    <ruleTitle><![CDATA[우선 순위가 다른 연산자 혼용 시 괄호를 사용하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 우선 순위가 다른 연산자 혼용 시 괄호를 사용할 것을 권장한다. 연산자의 우선 순위를 완벽히 이해하지 못 한 채로 혼용하는 경우 의도와 다른 결과를 초래할 수 있기 때문이다.  ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP01_C</rule>
    <ruleTitle><![CDATA[sizeof()의 인자로 포인터 변수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 특정 타입의 사이즈를 결정할 때 포인터 타입의 사이즈를 사용하면 안된다. 포인터 타입의 사이즈는 포인터가 가리키는 타입의 사이즈가 아니다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP02_C</rule>
    <ruleTitle><![CDATA[논리연산자 && 과 || 의 오른쪽 피연산자에 side effect 포함금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 논리 AND와 논리 OR 연산자는 단축 평가를 수행한다. 즉 첫 번째 피연산자로 평가가 완료된 경우 두 번째 피연산자는 평가하지 않는다. 따라서 두 번째 연산자가 부수 효과를 갖고 있다면 이 부수 효과가 실제로 발생하는지 보이지 않으므로 주의해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP04_C</rule>
    <ruleTitle><![CDATA[함수 memcmp의 인자로 구조체 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 구조체는 메모리상으로 정렬시키기 위해 data가 pad된다. 이 pading의 내용이나 추가되는 패딩의 크기는 unspecified이다. 따라서 구조체 사이에 바이트단위의 비교가 시도된다면 그 결과가 부정확 할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP05_C</rule>
    <ruleTitle><![CDATA[const를 명시적으로 제거하는 타입 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 포인터의 const qualification을 명시적으로 제거하는 타입 변환을 검사한다. const qualifiication이 제거되면 프로그램이 해당 포인터에 참조되는 object를 수정할 수 있게 되면, 그 결과는 undefined behavior이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP06_C</rule>
    <ruleTitle><![CDATA[sizeof 연산자에 side effect expression 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ sizeof 연산자는 피연산자의 크기를 바이트 단위로 알려준다. 피연산자는 표현식일 수도 있고 괄호로 묶인 타입 이름일 수도 있다. 피연산자의 타입이 가변 배열 타입이 아닌 경우에는 평가되지 않는다. 부수 효과를 가져올 수 있는 표현식이 제공되는 경우에는 표현식이 평가되지 않았다는 사실을 모르는 프로그래머에게는 혼란을 줄 수 있다. 결국 프로그래머는 프로그램의 상태에 대해 유효하지 않은 가정을 하고, 이는 에러나 소프트웨어의 취약성으로 이어진다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP09_C</rule>
    <ruleTitle><![CDATA[메모리 할당 함수의 할당 크기를 입력하는 인자에 sizeof를 포함한 expression을 사용했는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 타입의 사이즈를 하드코딩 하면 안된다. 기본 타입의 사이즈는 컴파일러에 따라 혹은 같은 컴파일러 사이에도 버전에 따라 달라질 수 있기 때문이다. 따라서 sizeof 연산자의 사용을 권장한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP10_C</rule>
    <ruleTitle><![CDATA[하위 표현식의 평가 순서에 의존하지 않도록 하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 하위 표현식의 평가나 부수 효과가 발생하는 순서가 지정돼 있지 않은 경우는 다음과 같다. 1.함수에 주어진 인자가 평가되는 순서 2.할당문에서 피연산자가 평가되는 순서 3.초기화 표현식에서 나열된 객체들이 부수 효과를 갖는 순서는 지정돼 있지 않다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP11_C</rule>
    <ruleTitle><![CDATA[integer type과 floating type 간 명시적 타입 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ incompatible type 사이의 타입 변환을 금지한다. integer type과 floating type 간의 명시적인 타입 변환은 기대하는 값과 다른 엉뚱한 값을 발생시킬 우려가 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP12_C</rule>
    <ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수는 side effect를 가지는지 여부와 상관없이 유용한 값을 반환한다. 대부분의 경우 이 값은 함수가 성공적으로 수행되었는 또는 어떤 에러가 발생했는지 여부를 나타낸다. 혹은, 어떤 계산의 결과값을 가지기도 한다. 만약 반환 값이 있는 함수에 대해서는 그 의미있는 반환 값을 사용하는지 검사해야 한다. 만약 반환 값을 사용할 필요가 없는 함수라면 반환 타입을 void로 하도록 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP13_C</rule>
    <ruleTitle><![CDATA[relational, equality 연산자가 결합되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 비교 또는 동등 연산자는 좌측부터 결합된다. 이 연산자들의 결합은 일반적인 결합과 다른 결과를 가진다. a<b<c 의 결과값은 해당 expression 자체의 참 거짓이 아니라, 만약 a가 b보다 큰 경우 1과 c를 비교하게 된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP14_C</rule>
    <ruleTitle><![CDATA[underlying type unsigned char, unsigned short에 대해 bitwise operator(~, <<) 사용시 해당 underlying type으로의 명시적 변환 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ int보다 작은 정수 타입에 대한 bitwise 연산에서는 예상치 못한 결과값이 발생할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP16_C</rule>
    <ruleTitle><![CDATA[함수 이름이 호출식이나 주소연산자(&)가 붙은 형태로만 사용되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ null이 아닌 함수의 포인터를 비교하는 표현식은 대부분 프로그래머의 실수로 그 결과는 정의되지 않는 행동을 유발한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP17_C</rule>
    <ruleTitle><![CDATA[조건문에서 bitwise 연산자 (&,|) 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ bitwise AND (&, ampersand) 또는 bitwise OR (|, pipe) 연산자를 조건식에서 사용하지 말라.  이것은 전형적으로 프로그래머에게 실수를 유발하고 예측하지 못한 작동을 하는 결과가 될수 있다. & 또는 | 는 bitwise 연산에서만 쓰고, && 또는 || 는 논리 연산에서만 써야한다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP18_C</rule>
    <ruleTitle><![CDATA[condition에 assignment 연산자 사용금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 조건문이나 반목문의 조건절의 최상위 표현식에 대입연산자를 사용하면 안된다. 이는 대개 개발자의 실수이며 예상하지 못한 결과를 유발한다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP19_C</rule>
    <ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[Statement의 body가 하나의 statement만을 가지고 있더라도, 항상 body는 block으로 처리해야 한다. 이는 코드의 통일성과 가독성을 향상시킨다. 더욱 중요한 것은, 하나의 statement만 가지는 body에 statement를 추가할 때, brace를 추가하지 않아서 잘못된 코드가 만들어 질 수 있다는 점이다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP20_C</rule>
    <ruleTitle><![CDATA[가독성 향상을 위해 조건 구문을 명시적으로 표기하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 코드의 가독성을 높이기 위하여 성공, 참/거짓, 동등 여부를 표현하는 것이 좋다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP30_C</rule>
    <ruleTitle><![CDATA[평가순서에 따라 결과가 달라지는 문장사용금지 (sequence point detection) ]]></ruleTitle>
    <ruleDesc><![CDATA[ 표현식의 평가는 부수 효과를 가져오는데, 이 때 이전 평가 단계에서의 모든 부수 효과가 발생하고 다음 평가 단계에서의 부수 효과가 아무것도 발생하지 않은 지점에 해당하는 시퀀스 포인트라는 샐행 지점이 있다. C99의 6.5절에 따르면, 이전과 다음 시퀀스 포인트 사이의 객체는, 객체에 저장된 값을 표현식 평가로 한 번 수정할 수 있다. 또한 이전 값은 저장될 값을 결정하려는 목적으로만 읽을 수 있다. 이 요구사항은 전체 표현식의 모든 가능한 하위 표현식의 순서에 대해 만족돼야 한다. 그렇지 않다면 어떤 행동을 할지 예측할 수 없다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP31_C</rule>
    <ruleTitle><![CDATA[assert 매크로의 인자로 side-effect 포함 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ assert() 매크로는 코드안에서 진단 테스트를 짜넣기 편리하게 동작한다 (제안 MSC11_C참고) 표준 assert 매크로와 함께 사용된 표현식은 side effect를 가져서는 안된다. 전형적으로, assert 매크로의 동작은 NDEBUG 전처리 심볼의 상태에 의존적이다. NDEBUG가 정의되어있지 않으면, assert 매크로는 그것의 인지 표현식을 평가하도록 정의되고 표현식의 결과가 false 로 변환가능하다면 프로그램을 중단시킨다. NDEBUG가 정의되어 있으면 assert는 아무 동작도 하지 않도록 정의된다. 따라서, assertion에서 표현식의 평가로부터 도출되는 어떤 side effect 는 디버깅버젼이 아닌 코드에서는 잃어버리게 된다. 
assert는 매크로이기 때문에, 이 룰은 PRE31_C의 특별한 케이스이다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP32_C</rule>
    <ruleTitle><![CDATA[volatile을 제거하는 명시적 타입 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 포인터의 volatile qualification을 명시적으로 제거하는 타입 변환을 검사한다. volatile object가 non-volatile value의 사용에 의해 참조될 수 있으면 그 결과는 undefined behavior이다.  ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP33_C</rule>
    <ruleTitle><![CDATA[변수 사용 전 값 할당 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 로컬의 자동 변수는 초기화되기 전에 사용될 경우 이상한 값이 들어 있다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP34_C</rule>
    <ruleTitle><![CDATA[메모리 할당 함수의 반환값이 검증되지 않아 null 포인터 참조가 시도되는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ null 포인터 결과값을 참조하려는 시도는 undefined behavior이다.  ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP35_C</rule>
    <ruleTitle><![CDATA[함수의 반환 값을 인접한 다음 시퀀스 포인트에서 접근하거나 수정하지 마라 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수 호출의 결과 값을 다음 시퀀스 포인트 후에 접근 또느 수정하려고 한다면 정의되지 않은 결과를 얻게 된다. C함수는 배열을 반환할 수 없다. 하지만 배열을 가진 구조체나 공용체는 반환할 수 있다. 만약 함수 호출 후 얻은 반환 값에 배열이 있다면 그 배열은 표현식 내에서 접근되거나 수정되면 안된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP36_C</rule>
    <ruleTitle><![CDATA[pointer type의 변환 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 다른 타입의 객체에 대해서는 다른 타입의 정렬이 가능하다. 명시적인 캐스팅이나 포인터가 void 포인터로 변환됐다가 다른 타입으로 변경되는 경우로 인해 타입 체크 시스템이 무효화된다면, 객체의 정렬도 바뀔 수 있다. 그 결과 한 객체에 대한 포인터가 다른 객체에 대한 타입으로 변경된 경우, 두 번째 객체의 타입은 처음 것보다 덜 엄격한 정렬을 요구해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP37_C</rule>
    <ruleTitle><![CDATA[특정 함수의 특정 인자가 존재하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ POSIX 함수 open()은 세 번째 인자로 생성된 파일에 접근하는 모드를 결정하는 가변인자를 가진 함수다. 새로운 파일을 생성하기 위해 open()을 사용하고 세 번째 인자를 생략한다면, 파일은 의도하지 않은 접근 권한을 갖고 생성될 것이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_EXP40_C</rule>
    <ruleTitle><![CDATA[const-qualified 타입의 변수가 수정되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ const-qualified 타입의 object를 non-const-qualified 타입의 lvalue를 사용하여 수정하는 것은 undefined behavior를 유발한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_FIO04_C</rule>
    <ruleTitle><![CDATA[입출력 함수의 성공 또는 실패 여부를 나타내는 반환값이 검증되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 입출력 함수는 성공 또는 실패 여부를 명백히 나타낸다. 실패한 경우에 반환된 값을 그대로 사용하는 경우 undefined behavior가 발생할 수 있다. 따라서, 입출력 함수의 결과값은 검사되어야 하고 에러가 발생한 경우에는 적절한 에러 처리가 필요하다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_FIO07_C</rule>
    <ruleTitle><![CDATA[rewind() 보다 fseek() 사용 권장 ]]></ruleTitle>
    <ruleDesc><![CDATA[ fseek()을 사용하는 것이 rewind()를 사용하는 것 보다 오류를 처리하는 능력이 뛰어나다. 따라서 fseek()의 사용을 권장한다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_FIO08_C</rule>
    <ruleTitle><![CDATA[remove() 함수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ remove()함수는 이미 열려 있는 파일에 대하여 호출될 경우에 대한 행동이 정의되어 있지 않다. 따라서 remove() 보다는 unlink()를 권장한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_FIO11_C</rule>
    <ruleTitle><![CDATA[함수 fopen 호출 시 지정된 mode 문자열을 사용해야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ C표준은 fopen() 함수 호출에 대해 mode로 사용할 수 있는 지정된 문자열을 식별한다. 표준을 따르고 호환 가능하게 하려면 반드시 지정된 문자열 중 하나를 써야 한다. (지정된 문자열 목록: r, w, a, rb, wb, ab, r+, w+, a+, r+b, rb+, w+b, wb+, a+b, ab+) ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_FIO12_C</rule>
    <ruleTitle><![CDATA[setbuf() 보다 setvbuf() 사용 권장 ]]></ruleTitle>
    <ruleDesc><![CDATA[ setbuf()을 사용하는 것이 setvbuf()를 사용하는 것 보다 오류를 처리하는 능력이 뛰어나다. 따라서 setvbuf()의 사용을 권장한다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_FIO33_C</rule>
    <ruleTitle><![CDATA[입출력 함수의 반환값이 검증되지 않아 변수가 초기화되지 않은 상태로 사용되는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 입출력 함수가 정상적으로 수행되지 않은 경우, 반환값을 받는 변수가 초기화 되지 않은 상태로 남아있을 수 있다. 그 변수를 사용하는 경우에 발생할 수 있는 undefined behavior를 피하기 위해 함수 수행 실패에 대한 검증이 있어야 한다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_FIO34_C</rule>
    <ruleTitle><![CDATA[plain char/signed char 타입 사용 금지 상황 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 문자 입/출력 함수들  fgetc(), getc(), getchar() 는 모두 스트림으로 부터 문자를 읽고 int로 반환한다. 스트림이 end-of-file에 도달하면 end-of-file 지시자가 설정되고 함수는 EOF를 반환한다. 문자 입/출력 함수 fputc(), putc(), putchar(), ungetc() 또한 문자 또는 EOF를 반환한다. 
문자 입/출력 함수에 의해 반환되는 값은 그 값이  EOF 와 비교될것이라면 char 로 변환하지 말아야한다. 이들 함수의 반환값이 일단 char 타입으로 변환되면 문자값들이 EOF 와 구분할수 없게될수 있다. 또한  sizeof(int) == sizeof(char) 이면, 반환값을 capture 하기 위해 사용한 int 는 EOF 와 구분할수 없게될수 있다. sizeof(int) == sizeof(char) 에 대한 자세한 사항은 FIO35_C 를 참고. 올바른 문자 타입 사용에 대한 정보는 제안 STR00_C 를 참고. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_FIO38_C</rule>
    <ruleTitle><![CDATA[FILE 타입끼리 assign하면 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 스트림을 제어하는데 사용하는 FILE 객체에서는 주소 값이 중요하다. 하지만 복사된 FILE 객체는 원래 주소를 보존할 필요가 없다. 따라서 입출력 연산 시 FILE 객체를 복사해 사용하지 않는 것이 좋다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_FIO39_C</rule>
    <ruleTitle><![CDATA[파일 입출력 사이에 플러시나 파일 위치 조정 함수가 존재하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 파일 스트림에 대해서 입력 다음에 fflush 호출이나 파일 위치 조정 함수(fseek, fsetpos, rewind)의 호출 없이 바로 출력을 수행하면 안되며, 반대로 출력 다음에 파일 위치 조정 함수 없이 바로(입력에서 파일 끝에 도달하지 않은 이상) 입력을 수행하면 안된다. 구현에 따라서 텍스트 파일을 업데이트 모드로 여는 것(혹은 생성하는 것)이 실제로는 바이너리 스트림을 열 수도 있다.  ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_FIO41_C</rule>
    <ruleTitle><![CDATA[특정 매크로 함수의 인자에 side-effect 포함 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ side-effec를 가지는 stream 인자를 getc()나 putc()에 전달할 경우 예상하지 못한 결과가 발생할 수 있다. 따라서 해당 함수의 인자로 side-effect를 가지는 expression을 사용하지 말아야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_FIO44_C</rule>
    <ruleTitle><![CDATA[fsetpos()에 fgetpos()에서 반환된 값을 사용했는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ fsetpos 함수는 stream이 가리키는 스트림에서 pos로 표시되는 객체의 값에 따라 mbstate_t 객체와 파일 위치 표시자를 설정한다. 이때 pos는 같은 파일 스트림에 대해 fgetpos 함수를 호출해 성공적으로 반환된 값이어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_FLP02_C</rule>
    <ruleTitle><![CDATA[floating point 수식은 equality 검사에서 사용금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 컴퓨터는 유한한 개수의 숫자를 표현할 수 있다. 따라서 반복되는 이진 표기값을 정확하게 표현하는 것은 이진 부동소수점을 가진 대부분의 부동 소수점 표현으로는 불가능하다. 즉, 부동 소수점 연산에서는 정확하지 않은 결과가 발생할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_FLP03_C</rule>
    <ruleTitle><![CDATA[floating 오류 처리 루틴 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ floating-point 연산중의 에러는 연산 전에 피연산자를 확인하는데 집중하는 프로그래머에 의해 자주 무시된다. floating-point 연산중에 발생하는 에러는 일반적으로 인정하는 바와 같이 결정과 진단이 어렵지만, 그렇게 함으로써 얻어지는 이점은 비용을 무릅쓸 만하다. 이 제안은 floating-point 연산중의 에러를 잡는 방향을 제시한다. 
floating-point 예외 조건이 일어났는지를 결정하는 가장 portable한 방식은 C99에 의해 제공되는 fenv.h 의 floating-point 예외 장치를 사용하는것이다[ISO/IEC 9899:1999]. 그러나 C99 floating-point 예외 함수들에 문제가 없지는 않다. 
덜 portable 하지만 잠재적으로 더 안전한 해법은 구현체에 의해 제공되는 특성들을 사용하는것이다. 이 접근법이 취해지면, 해당 시스템의 조건들이 잘 이해될 필요가 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_FLP04_C</rule>
    <ruleTitle><![CDATA[scanf의 float type 입력값에 대해 isinf, isnan 수행 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Floating-point 숫자는 infinity 와 NaN (not-a-number) 라는 2종류의 예외적값을 가질수 있다. 이 값들은 예외 또는 풀수없는 floating point 연산의 결과로서 반환된다. (FLP32_C 참고) 추가적으로, 그들은 사용자에 의해 scanf 혹은 유사한 함수로 직접 입력될수 있다. 그런 값들을 탐지하거나 다루는데 실패하는것은 undefined behavior를 일으킬수 있다. 
NaN 값은 특히 문제가 된다. 식 NaN==NaN (모든 가능한 NaN값에 대해) 이 false 를 반환하기 때문이다. 인자중 하나로서 NaN과 이루어진 어떤 비교는 false 를 반환한다. 그리고 NaN 상의 모든 계산 함수들은 그것들을 코드로 전파한다. 즉, 코드의 어떤 장소에 NaN 이 들어갔고, 적적히 다루어지지 않는다면, 멀리 떨어진 다른 장소에서 문제를 일으킬수 있다. 
scanf 와 같은 Formatted-input 함수들은 INF, INFINITY, NAN 값들을 %f 포맷에 대한 올바른 입력값으로 받아들일것이고, 악의적인 사용자에게 그것들을 프로그램에 직접 입력시키는것을 허용한다. 프로그램은 모든 floating point 입력값들이 이런 값들을 가지고 있지 않은지, 가지고 있다면(특히 그것들이 사용자에 의해 제오된다면) 부적절한지를 확실히 검사해야 한다. <math.h> 라이브러리는 이것을 위한 두가지 매크로를 가지고 있다: isinf, isnan ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_FLP30_C</rule>
    <ruleTitle><![CDATA[for, while, do에 대해서 floating point 수식을 조건식 및 증감식에서 사용금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ floating-point 숫자는 부분값으로 표현될수 있기때문에, 그것들이 어떤 단순한 부분값을 정확하게 표현할수 있다고 흔히 잘못 가정된다. 사실 floating-point 숫자는 integer가 그렇듯, 그리고 binary floating-point 숫자가 모든 decimal 부분들을 정확히 표현해낼수 없는것과 같이(심지어 그것이 적은수의 10진수 숫자들로 표현될수 있을지라도), 제한된 정밀도에 영향받기 쉽다.
추가적으로, floating-point 숫자는 큰 값을 표현할수 있기때문에 그것들이 그 값들의 모든 자릿수를 표현할수 있을것으로 흔히 잘못 가정된다. 큰 동작범위를 가지기 위해서 floating-point 숫자들은 정해진 수의 정확도와 지수의 비트수를 유지한다. 큰 floating-point 값의 증가는 유효한 정확도 내의 값으로의 변경이 아닐수도 있다.
다른 구현테들은 다른 정밀도제한을 가지며, 코드 이식성 유지를 위해서는 floating-point 변수들을 loop counter로 사용해서는 안된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_FLP32_C</rule>
    <ruleTitle><![CDATA[수학함수가 안전하게 사용되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C99 Section 7.12.1 은 math.h에 있는 수학함수들에 대한 두 타입의 error를 정의하고 있다.   [ISO/IEC 9899:1999]:domain error 는 입력인자가 정의된 함수의 domain을 초월했을때 error를 일으킨다.  range error 는 함수의 수학계산 결과가 명세된 타입의 object에 표현될수 없다면( extreme magnitude 로인한 경우 등) error를 일으킨다. Domain errors 는 함수 호출 전 bounds checking 으로 예방될수 있다. Range errors 는 거의 예방할수 없지만, range errors를 예방하는 대신 그것을 탐지하고 range error가 발생했을때의 사후처리를 해야한다 ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_FLP34_C</rule>
    <ruleTitle><![CDATA[floating type의 expression의 값을 다른 type으로 묵시적 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 부동소수점 값이 더 작은 범위나 정밀도를 가진 부동소수점 값으로 변환되거나 정수로 변환되는 경우, 혹은 정수가 부동 소수점으로 변환되는 경우 값은 변환될 타입으로 표현 가능해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_FLP36_C</rule>
    <ruleTitle><![CDATA[integer 타입을 floating 타입으로 묵시적인 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 작은 primitive 타입은 더 큰 타입으로 묵시적으로 변환될 수 있다. 이런 변환은 정수형 사이에서는 정확한 값을 가지지만 실수형 사이에서는 정확성이 떨어질 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_INT01_C</rule>
    <ruleTitle><![CDATA[사이즈 타입 비교 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ size_t 타입은 일반적으로 전체 공간의 주소를 커버한다. ISO/IEC TR 24731-1-2007 는 새로운 타입 rsize_t 를 소개한다. 그것은 size_t로 정의되지만 명시적으로 단일한 object의 크기를 고정하기 위해 사용된다[Meyers 2004]. 이 목적을 문서화한 rsize_t 타입을 사용하는 코드에서 object의 크기는 그것이 RSIZE_MAX보다 크지 않음을 확인하기 위해 검사될수 있다. 일반적인 단일 object의 최대크기인 RSIZE_MAX는 라이브러리 함수에 대한 추가적인 입력 validation을 제공한다. TR 24731-1 의 추가 논의사항에 대해서는 제안 STR07_C 참조. 
object의 크기를 표현하기위해 사용되는 어떤 변수 (크기,인덱스,loop counter,길이로 사용되는 integer값을 포함하는)는 가능한한 rsize_t로 선언되어야 한다. 그렇지 않을경우에는 size_t 로 선언되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_INT02_C</rule>
    <ruleTitle><![CDATA[정수 변환 규칙을 이해하고 사용하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 서로다른 타입에 대해 연산을 처리할 때에는 주의해야 한다. 정수 승계, 정수 변환 순위를 잘 이해하여 정수 변환 규칙에서 발생하는 변환들을 알고 있어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_INT03_C</rule>
    <ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
    <ruleDesc><![CDATA[ integer 취약점에 대한 방어의 최일선은 범위검사, 명시적이거나 엄격한 타입검사 이다. 신뢰할수 없는 출처로부터의 integer 값을 강제로 제한하는것도 한가지 접근방법이다(제안 INT04_C 참조). 그러나 제어될수 없는 다양한 입력 변수들이 프로그램의 어딘가의 연산에 에러를 일으키는것을 보장하기 어렵다. 
대안 혹은 보조적인 접근은 개개의 연산을 보호하는것이다. 그러나 이러한 문제에 영향받기 쉬운 큰 수의 integer연산과 예외적 상태를 방지하기 위해 요구되는 많은 검사들 때문에, 이 접근은 엄청나게 노동집약적이고 고비용의 구현이 될수 있다. 
이 문제의 좀더 경제적인 해법은 하나 또는 그 이상의 입력들이 신뢰할수 없는 출처와 결과값에 의해 영향을 받을수 있는 곳, 잘못되면 보안상 헛점을 일으킬수 있는 곳에서 integer에 대한 모든 연산에 대해 secure integer library를 사용하는것이다. 

IntegerLib 

secure integer library 의 한 예는 CERT/CC 에 의해 개발되어 자유롭게 사용 가능한 IntegerLib 이다. 
이 라이브러리의 목적은 integer overflow, integer truncation, sign error등과 같은 일반적인 integer문제로부터 자유로운, C 프로그램을 쓰는 소프트웨어개발자들을 도울수 있는 유틸리티 함수들의 모음을 제공하는것이다. 이 문제들은 소프트웨어취약점의 일반적인 출처이다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_INT05_C</rule>
    <ruleTitle><![CDATA[scanf, fscanf 사용 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 문자를 입력받고 그들을 integer로 변환하는 함수가 모든 가능한 입력에 대한 에러를 다룰수 없다면 그 함수들을 사용하지 말아야한다. 예를들면, 문자열 데이터를 stdin 또는 (fscanf()와 vscanf() 의 경우) 다른 입력 stream 으로부터 읽는데 사용될수 있는 scanf(), fscanf(), vscanf(), vfscanf() 와 같은 formatted input 함수들. 이 함수들은 올바른 integer값에 대해서는 잘 동작하지만 잘못된 값에 대해서는 강인한 에러처리가 부족하다. 
대안으로,  null-terminated 바이트 문자열로 문자 데이터를 입력받고 integer 값으로 변환하는데 strtol() 또는 관련된 함수를 사용한다. (제안 INT06_C 참고) ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_INT06_C</rule>
    <ruleTitle><![CDATA[문자를 integer로 변환하는 함수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ atoi(), atol(), atoll() 등을 이용하여 문자열 토큰을 integer로 변환하는 방법은 예상하지 못하는 오류들을 발생시킬 가능성이 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_INT07_C</rule>
    <ruleTitle><![CDATA[숫자 값의 용도로 사용되는 char에 명시적으로 signed나 unsigned를 사용하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 세 개의 타입 char, signed char, unsigned char를 통틀어 문자 타입이라고 한다. 컴파일러는 그것이 signed char이든 unsigned char이든 간에 char가 같은 범위, 표현, 동작을 갖도록 정의한다. 하지만 어느 것을 고르든 char는 나머지 두 개의 타입과는 분리된 타입이고 서로 호환되지 않는다. 숫자 값이나 저장공간으로 쓸 때는 항상 signed char나 unsigned char를 사용하라. 이렇게 하는 것이 문자 타입의 부호와 상관없이 호환 가능한 코드를 만드는 유일한 방법이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_INT09_C</rule>
    <ruleTitle><![CDATA[열거형 상수가 유일한 값으로 매핑되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C의 열거형 타입은 정수로 매핑된다. 일반적으로 각 열거형 타입이 개별 값으로 매핑된다고 생각하지만, 열거형 타입 멤버들이 서로 같은 값을 갖는 명확하지 않은 에러가 종종 만들어지기도 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_INT10_C</rule>
    <ruleTitle><![CDATA[% 연산자를 쓸 때 나머지가 양수라고 가정하지 마라 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C99 정의에서 % 연산자에 대한 결과의 부호는 피제수(표현식의 첫 번째 연산자)의 부호를 따른다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_INT11_C</rule>
    <ruleTitle><![CDATA[pointer type과 integer type 간 명시적 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 정수와 포인터를 서로 변환하는 일이 C에서 일반적이기는 하지만, 포인터에서 정수로, 정수에서 포인터로 변환하는 것은 구현마다 다르게 정의하고 있다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_INT12_C</rule>
    <ruleTitle><![CDATA[int bit 필드에 명시적으로 signed나 unsigned를 사용하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 저장 공간을 절약하기 위해 플래그나 작은 범위를 갖는 정수 값을 같은 공간에 저장하려고 비트 필드를 사용할 수 있다. 그런데 비트 필드에서 int가 signed int와 같은 타입인지 혹은 unsigned int와 같은 타입인지는 구현마다 다르다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_INT13_C</rule>
    <ruleTitle><![CDATA[bitwise 연산자에 signed underlying type 피연산자 사용금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 비트 연산자는 signed 정수에 대한 비트 연산이 구현마다 다르게 정의돼 있기 때문에 unsigned 정수 피연산자와만 사용돼야 한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_INT14_C</rule>
    <ruleTitle><![CDATA[bitwise 연산자와 산술 연산자가 혼용되면 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 동일한 데이터에 비트 연산자와 산술 연산자를 수행하면 안된다. 최적화를 위해 간혹 산술적 수치 값에 비트 연산을 수행하는 경우가 있다. 비트 연산자에는 단항 연산자 ~와 이항 연산자 <<, >>, &, ^, |가 있다. 이런 연산은 유효하고 컴파일도 되지만, 코드의 가독성을 떨어뜨린다. 숫자 값이나 비트맵을 포함하고 있는 변수를 선언할 때, 프로그래머의 의도가 분명하게 보여야 코드의 유지보수가 용이해진다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_INT15_C</rule>
    <ruleTitle><![CDATA[typedef 타입을 변환 포맷에 사용 시 오버플로 방지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 사용자가 지정한 타입들은 printf() 같은 포맷이 지정된 출력 함수나 scanf() 같은 포맷이 지정된 입력 함수와 사용하면 문제를 일으킨다. C99의 intmax_t와 uintmax_t 타입은 같은 부로를 갖는 정수 타입으로 표현될 수 있는 모든 값을 표현할 수 있다. 이로 인해 프로그래머가 정의한 정수 타입과 intmax_t, uintmax_t 간의 변환도 가능하다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_INT30_C</rule>
    <ruleTitle><![CDATA[unsigned integer 타입의 상수에 대한 wrap around가 일어나면 안됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[ unsigned 정수 연산은 결과 값이 정수 표현 범위를 벗어나는 경우 래핑될 수 있다. 이러한 래핑이 발생하면 버퍼 오버플로를 초래하거나 공격자로 하여금 임의 코드를 수행하게 한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_INT31_C</rule>
    <ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ integer 변환(묵시적, 명시적 모두 포함)은 데이터의 손실이나 부호의 변동을 가져오면 안된다. 이런 변환은 배열의 참조자, 포인터 연산, 객체의 사이즈나 길이 등에서 신뢰하지 못하는 코드를 유발할 수 있다. 단, 해당 변환에 대해 미리 인지하고 검사를 완료한 코드는 허용한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_INT32_C</rule>
    <ruleTitle><![CDATA[signed 정수 연산이 오버플로되지 않도록 보장해야 한다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 정수 오버플로는 undefined behavior를 유발한다. 따라서 signed 정수에서의 연산이 signed 오버플로를 발생시키지 않도록 보장해야 한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_INT33_C</rule>
    <ruleTitle><![CDATA[division by zero가 발생하면 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ /, % 연산자의 두 번째 피연산자로 0(zero)가 오면 undefined behavior가 발생한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_INT34_C</rule>
    <ruleTitle><![CDATA[범위를 벗어난 값으로 shift 연산자를 사용하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 비트 시프트에서 피연산자가 정수 타입인 경우 정수 승계가 일어나며, 왼쪽 피연산자의 승계된 타입이 결과값의 타입이 된다. 만일 오른쪽 피연산자의 값이 음수이거나 승계된 왼쪽 피연산자의 값과 같거나 큰 경우 정의되지 않은 동작이 일어난다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_INT35_C</rule>
    <ruleTitle><![CDATA[정수 표현식으로 비교하거나 할당할 때 더 큰 타입으로 표현하여 묵시적인 변환을 방지하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 정수 표현식이 더 큰 정수와 비교되거나 더 큰 정수에 할당되는 경우 정수 표현은 반드시 피연산자 중 하나를 명시적으로 캐스팅해 큰 타입에서 평가하게 해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_KCWE_02_04</rule>
    <ruleTitle><![CDATA[취약한 암호화 알고리즘 사용 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 보안이 취약하거나 위험한 암호화 알고리즘을 사용해서는 안된다. 표준화되지 않은 암호화 알고리즘을 사용하는 것은 공격자가 알고리즘을 분석하여 무력화실킬 수 있는 가능성을 높일 수 있다. 몇몇 오래된 암호화 알고리즘의 경우는 컴퓨터의 성능이 향상되어 취약해지기도 해서 예전에는 해독하는데 몇 십억년이 걸리던 알고리즘이 몇 일이나 몇 시간내에 해독되기도 한다. RC2, RC4, RC5, RC6, MD4, MD5, SHA1, DES 알고리즘이 여기에 해당한다.
[관련규칙 - CWE-327] ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_KCWE_04_03</rule>
    <ruleTitle><![CDATA[적절하지 않은 예외처리 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 프로그램 수행 중에 함수의 결과 값에 대한 적절한 처리 또는 예외상황에 대한 조건을 적절하게 검사하지 않을 경우, 예기치 않은 문제를 야기할 수 있다.
[관련규칙 - CWE-754] ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_KCWE_05_01</rule>
    <ruleTitle><![CDATA[널(Null) 포인터 역참조 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 널 포인터 역참조는 '일반적으로 그 객체가 널(Null)이 될 수 없다'라고 하는 가정을 위반했을 때 발생한다. 공격자가 의도적으로 널 포인터 역참조를 발생시키는 경우, 그 결과 발생하는 예외 상황을 이용하여 추후의 공격을 계획하는 데 사용될 수 있다.
[관련규칙 - CWE-476] ]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_KCWE_05_02</rule>
    <ruleTitle><![CDATA[부적절한 자원 해제 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 프로그램의 자원, 예를 들면 열린 파일디스크립터, 힙 메모리, 소켓 등은 유한한 자원이다. 이러한 자원을 할당받아 사용한 후, 더 이상 사용하지 않는 경우에는 적절히 반환하여야 하는데, 프로그램 오류 또는 에러로 사용이 끝난 자원을 반환하지 못하는 경우이다. 자원을 획득하여 사용한 다음에는 반드시 자원을 해제하여 반환한다.
[관련규칙 - CWE-404] ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MEM01_C</rule>
    <ruleTitle><![CDATA[free된 포인터에 즉시 새로운 값을 저장하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ Dangling pointer는 exploitable 이중 free와 free된 메모리 접근 취약점을 이용하도록 유도할수 있다. Dangling pointer를 제거하고 많은 메모리관련 취약점을 피하는 간단하지만 유효한 방법은 포인터에 그들이 free된 후 또는 그들을 다른 적절한 object에 지정한 후에 NULL값을 지정하는것이다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MEM02_C</rule>
    <ruleTitle><![CDATA[메모리 할당 함수의 반환 값을 즉시 할당된 타입의 포인터로 변환하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ void * 타입의 object는 일반적인 data포인터이다. 그것은 어떤 object라도 가리킬수 있다. 어떤 incomplete 나 T 타입 object 에 대해, C는 T* 에서 void* 로, 또는 void* 에서 T* 로의 묵시적 변환을 허용한다. Standard C Library는 다른 타입의 object들에 대해 동작하도록 디자인된 함수의 파라메터와 return 타입을 선언하기 위해 void* 를 사용한다. 표준 메모리 할당함수 malloc(), calloc(), realloc() 의 경우가 그러하다. 
예를들면 c library 는 malloc()을 다음과 같이 선언한다. 

void *malloc(size_t); ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MEM04_C</rule>
    <ruleTitle><![CDATA[특정 함수의 특정 인자로 검증되지 않은 변수 또는 0(constant zero) 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 메모리 할당 시에 사이즈를 0으로 입력하는 것에 대한 처리는 implementation-defined이다. 또한 메모리 할당 함수가 non-null 포인터를 반환하는 경우 할당된 메모리를 읽거나 쓰는 것에 대해서는 undefined behaviord이다. 따라서 메모리 할당 함수에 전달되는 사이즈가 0인지 검사하고 사용해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MEM05_C</rule>
    <ruleTitle><![CDATA[함수의 array type parameter에 사이즈 명시 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 과도한 스택할당을 피하라. 특히 스택의 확장이 제어될수 있는 상황이나 공격자에 의해 영향을 받을수 있는 상황에서. 
C99는  variable-length arrays (VLAs) 를 지원한다 [ISO/IEC 9899:1999]. 만약 배열 길이가 신뢰할수 없는 출처에 기인한다면 공격자는 스택에 과도한 할당을 수행하는 프로세스를 일으킬수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MEM08_C</rule>
    <ruleTitle><![CDATA[realloc()의 인자의 타입과 cast되는 타입이 다른지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C standard에 의하면, recalloc(ptr, size) 호출은 ptr이 가리키는 구 객체를 할당해제 하고 size에 의해 크기가 명세되는 새 객체를 반환한다. 새 객체의 내용은 새 객체와 구 객체중 작은쪽의 크기까지 할당해제 전의 구 객체의 내용과 같다, 구 객체의 크기 너머의 새 객체의 바이트들은 결정되지 않은 값들을 가진다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MEM30_C</rule>
    <ruleTitle><![CDATA[free된 포인터 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ [ISO/IEC 9899-1999] 에 따르면, free() 또는 realloc()함수 호출에 의해 해제된 공간을 참조하는 포인터 값을 사용하는 프로그램의 동작은 undefined. (undefined behavior 168 of Annex J 참조) 
한번 free된 메모리에 접근하는것은 heap을 관리하는 자료구조를 파괴할수 있다. 해제된 메모리로의 참조는 dangling pointer로의 참조가 된다. dangling pointer에 접근하는것은 취약점을 드러내는 결과가 될수 있다. 
메모리가 해제될때, 재할당 또는 해제된 chunk를 재활용 할때의 메모리 관리자의 재량권 때문에 그 내용은 아직 변형없이 남아있고 접근 가능하다. 해제된 위치의 데이타는 문제없이 보일수 있다. 그러나 이것은 불시에 변경될수 있고 프로그램을 unintended behavior로 유도한다. 결과적으로 한번 해제된 메모리가 읽거나 쓰이지 않음을 보장할 필요가 있다 ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MEM31_C</rule>
    <ruleTitle><![CDATA[중복 free 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 중복해서 메모리를 free하는것은 free된 후에 메모리에 계속해서 접근히는것과 유사하다. (MEM30_C 참조) 
먼저, 할당해제된 메모리에 대한 포인터를 읽는것은 undefined behavior이다. 포인터값이 애매하고 trap representation 을 가지기 때문이다. 후자의 경우 그렇게 하는것은  hardware trap을 일으킨다. free된 포인터를 읽는것이 trap을 일으키지 않을때, heap을 관리하는 자료구조가 프로그램에 보안 취약점을 전파할수 있는 방식으로 깨질수 있다. 이런형태의 이슈는 double-free 취약점으로 지칭된다. 실제  double-free 취약점은 엉뚱한 코드를 실행하도록 활용될수 있다. 
double-free 취약점을 제거하기 위해, 동적으로 할당된 메모리가 정확히 한번만 해제되도록 보장할 필요가 있다. 프로그래머는 반복이나 조건문에서 메모리를 free할때 주의해야한다. 코드가 잘못되면, 이런 구조는 double-free 취약점으로 유도될수 있다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MEM32_C</rule>
    <ruleTitle><![CDATA[메모리 할당 함수의 할당 성공 여부 반환값이 검증되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 메모리 할당 함수의 반환 값은 할당의 성공이나 실패 여부를 의미한다. C99에 따르면 calloc(), malloc(), realloc()는 메모리 할당이 실패할 경우 null 포인터를 반환한다. 따라서 메모리 함수의 최종 상태를 확인한 뒤 문제가 발생한 경우에는 적절한 가이드를 해줘야 한다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MEM33_C</rule>
    <ruleTitle><![CDATA[유연한 배열 원소에 정확한 문법을 사용하라 ]]></ruleTitle>
    <ruleDesc><![CDATA[ flexible array member는 유용하지만 주의깊에 사용될 필요가 있다.  
struct flexArrayStruct {	 
int num;	 
int data[];	 
};	 
이 정의는 저장소에 할당될때, 첫번째 멤버 num 만이 고려된다는 것을 의미한다. 따라서 flexArrayStruct type 구조체 변수의 member data 접근 결과는 undefined 이다. 규칙 DCL38_C 이 flexible array member를 가진 구조체를 선언하는 올바른 방법을 설명한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MEM34_C</rule>
    <ruleTitle><![CDATA[동적할당이 없는 포인터에 free 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 동적으로 할당되지 않은 메모리를 해제하는것은 규칙 MEM31_C 에서 논의된사항들과 유사한 심각한 에러를 유발할수 있다. 이 에러의 구체적인 결과는 구현체에 의존적이지만 그 범위는 아무것도 아닌것에서 프로그램 종료에까지 걸쳐있다. 구현체를 막론하고, 동적메모리 할당 함수(malloc() 같은것)에 의해 반환된 포인터가 아닌 다른 어떤것에는 free() 호출을 피해야 한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MEM35_C</rule>
    <ruleTitle><![CDATA[malloc, memcpy 함수 사용시 오버플로가 발생하면 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 특정 함수 호출 시 전달되는 size가 size_t 타입의 범위를 벗어나는 경우 오버플로가 발생할 수 있다. 따라서 size_t 타입의 사용을 권장한다. 만약 expression 인자의 결과가 size_t 타입의 범위 내라는 보장이 있다면 전체 expression을 size_t로 casting 하기를 권장한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MSC04_C</rule>
    <ruleTitle><![CDATA[중첩된 C 스타일 주석 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 주석 내에서 /*를 사용하지 마라. 주석 마침 표시를 누락하면 에러가 발생할 소지가 많으며, 대부분 실수처럼 보이기 때문에 이런 식의 주석 사용은 권하지 않는다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MSC05_C</rule>
    <ruleTitle><![CDATA[time_t 타입에 대해 직접 산술 연산을 수행하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ time_t 타입은 '시간을 표시할 수 있는 산술적인 타입'으로 정의돼 있다. 하지만 이 산술 타입으로 시간을 어떻게 인코딩하는지는 정의돼 있지 않기 때문에 이 타입에 대해 직접 산술 연산을 수행하는 것은 안전하지 않다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MSC06_C</rule>
    <ruleTitle><![CDATA[메모리 초기화 관련 함수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 컴파일러가 프로그램 생성 시 사용되지 않거나 필요하지 않은 코드를 제거할 수 있다. 일반적으로 이런 방식은 이득이 되지만, 컴파일러가 필요 없다고 판단해 제거한 코드가 사실은 보안상의 이유로 추가된 것일 수 있다. 민감한 데이터를 저장하는데 사용한 버퍼를 지우기 위해 덮어쓰기를 수행하는 경우를 예로 들 수 있다. 따라서 민감한 데이터를 다룰 때는 의도한 대로 동작하는지 확인해봐야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MSC07_C</rule>
    <ruleTitle><![CDATA[도달 불가능한 코드 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 전혀 실행되지 않는 코드는 죽은 코드라고 불린다. 일반적으로 죽은 코드는 프로그램 자체나 환경의 변화로 인해 논리 에러가 발생했음을 암시한다. 죽은 코드는 컴파일되는 동안 프로그램에서 최적화되어 날아가는 게 일반적이다. 하지만 논리 에러가 해결됐음을 보장하고 프로그램의 가독성을 높이기 위해 죽은 코드를 찾아 파악한 후 제거해야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Dead Code</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MSC11_C</rule>
    <ruleTitle><![CDATA[assert 매크로 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ runtime assert는 incorrect assumptions 을 확인하기 위해서만 사용해야 하고, runtime error checking 에서는 사용해서는 안된다. 결과적으로 runtime assertions 은 일반적으로  unsuitable 하다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MSC12_C</rule>
    <ruleTitle><![CDATA[side effect 가 없고 제어흐름의 변화를 일으키지 않는 문장 사용금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 실행되기는 하지만 아무 일도 발생하지 않거나 의도하지 않은 효과가 나타나는 경우는 대부분 코딩 에러로 인해서이며, 기대하지 않은 동작을 초래할 수 있다. 아무 효과도 없는 문장이나 표현식은 발견 후 제거해야 한다. 대부분 최근 컴파일러는 아무 효과도 발생하지 않는 코드에 대해 경고 메시지를 보내준다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Performance Resource Leak</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MSC13_C</rule>
    <ruleTitle><![CDATA[미사용 변수 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 사용되지 않은 변수의 존재는 중요한 논리적 오류를 나타낼수 있다. 이러한 오류를 방지하기 위해, 사용되지 않은 변수들은 코드로부터 확인되고 제거되어야 한다. 
이 제안은 MSC12_C의 구체적인 케이스이다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MSC14_C</rule>
    <ruleTitle><![CDATA[unsigned integer 타입에 ~ 연산자 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ unsigned integer 타입의 정수에 보수 연산자(~)를 사용하는 것은 일반적으로 사용 가능하지만 표준으로 보장되지는 않는다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MSC16_C</rule>
    <ruleTitle><![CDATA[function pointer 변수에 함수의 pointer를 직접 대입 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수의 메모리 위치는 compile 시점에 계산되며, 프로그램이 늦게 사용하는 순서로 정렬된다. 공격자가 특정 함수 포인터를 덮어 쓸 수 있다면, 임의적인 코드가 수행 될 수 있다. 따라서 이러한 공격에 대비하기 위하여 함수 포인터는 암호화되어 저장하고 사용 시점에 복호화되어 수행되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MSC17_C</rule>
    <ruleTitle><![CDATA[문장이 있는 모든 switch 절이 break문으로 끝나는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ switch문에서 case절에 break문이 없으면 fall through가 발생한다. 만약 의도적으로 break문을 생략한 것이 아니라면, 의도하지 않은 control flow가 발생하게 된다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MSC20_C</rule>
    <ruleTitle><![CDATA[Switch label(case, default)을 포함하는 가장 가까운 문장이 switch 문인지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ switch 문에서 새로운 블록이 시작되고 그 안에 case 절이 존재하게 되어 case 절들의 scope이 서로 달라질 수 있다. 만약 루프에 case절이 존재하게 되면 루프 안으로 jump가 발생하게 될 것이다. 이러한 경우 발생하는 행동은 정의되어있지 않다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MSC21_C</rule>
    <ruleTitle><![CDATA[for의 조건에서 equality 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ for 또는 while 문장이이 loop counter를 사용한다면, loop 종료를 위해서 inequality (연산자 !=) 연산자를 사용하기보다는 관계연산자(<등)를 사용하는것이 더 안전하다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MSC30_C</rule>
    <ruleTitle><![CDATA[rand() 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ rand()를 사용하여 생성되는 무작위 수는 예측 가능한 수다. 따라서 무작위 수를 사용해야 할 경우에 이 함수를 호출하는 것은 바람직하지 못하다. 대안으로는 srandom()과 현재 시간을 조합하는 방법 또는 윈도우에서 제공하는 CryptGenRandom()를 사용하는 방법이 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MSC31_C</rule>
    <ruleTitle><![CDATA[time_t, size_t 타입과 integer 타입간 비교 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 함수는 표준에서 반환 타입을 부분적으로 지정한 경우 동일한 타입의 리터럴 상수 값으로 비교돼야 한다. 부분적으로 지정된 타입이 unsigned char나 unsigned short로 구현된 경우 타입 값은 어떤 아키텍처에서 -1과 같은 정수 리터럴에 대해 같은 값을 갖고 있음에도 동일하다고 평가되지 않을 수 있다. C99에서 time_t 타입은 시간을 표현할 수 있는 산술 타입이 되도록 요구하고 있다. 시간을 표시하는 최선의 산술 타입을 결정하는 일은 구현에서의 몫이다. 만일 time_t가 signed int보다 작은 unsigned 정수 타입으로 구현됐다면, 항상 정수 리터럴 -1과 같지 않게 된다. 마찬가지로 size_t가 어떻게 구현됐는지에 따라 정수 리터럴 -1과 비교할 때 기대한 대로 평가되지 않을 수 있다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MSC33_C</rule>
    <ruleTitle><![CDATA[특정 함수의 특정 인자로 검증되지 않은 변수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ asctime 함수는 struct tm *timeptr을 인자로 받아서 sprintf로 조합시킨 최대 길이 26(마지막 널 캐릭터 포함)의 string을 반환한다. 만약 인자로 전달된 timeptr의 값에 문제가 있다면 sprintf에서 오버플로가 발생하게 된다. 따라서 asctime 함수에 전달되는 인자는 검증되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MSC34_C</rule>
    <ruleTitle><![CDATA[사용이 권장되지 않거나 구형의 함수 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 어떤 함수들은 사용이 권장되지 않거나 새로운 함수를 통해 대체가 가능하다. 이러한 함수들의 사용이 발생하지 않도록 검사한다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MSC35_C</rule>
    <ruleTitle><![CDATA[switch문에서 첫번째 case 레이블 이전에 어떤 실행문도 포함 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ switch 문장 안에서 첫번째  case 레이블 앞에는 어떤 실행문도을 포함하지 말라. 그런 문장들은 컴파일러가 무시하기 때문에 결코 실행되지 않는다. 
만약 프로그래머가 변수를 선언하고 그것들을 첫번째 cast문장의 앞에서 초기화 하고 어떤 case문장들 안에서 그 변수들을 사용하려는 시도들 한다면 그 변수들은 switch 블록 scope 안의 scope를 가질것이지만 초기화되지는 않을것이며 따라서 쓰레기값을 가지게 될것이다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MSC36_C</rule>
    <ruleTitle><![CDATA[alligned_alloc()으로 할당된 포인터를 가지고 realloc() 사용금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 만약 포인터가 aligned_alloc() 로부터 alignment 를 가지고 반환되었고 realloc() 이 다른 alignment로 메모리를 재할당하였다면, undefined behavior이다. 이 룰은  C1X standard [Jones 2009]를 준수하는 컴파일러에만 적용된다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MSC37_C</rule>
    <ruleTitle><![CDATA[non-void return type의 함수에서 명시적 return이 존재하는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 반환 타입이 void가 아닌 함수에서 마지막 brace가 끝나기 전에 return문이 존재하지 않았다면 해당 함수의 반환 값은 정의되어 있지 않다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MSC38_C</rule>
    <ruleTitle><![CDATA[표준 라이브러리에 있는 매크로 이름은 재사용 되어선 안된다. ]]></ruleTitle>
    <ruleDesc><![CDATA[ 표준 라이브러리에 있는 매크로를 재정의하면 안된다.  ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_MSC40_C</rule>
    <ruleTitle><![CDATA[내용이 없는 무한 루프를 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 루프 바디 내에서 아무것도 하지 않는 비어있는 무한루프는 좋은 해법이 아니며, 그것을 사용하는 코드는 없어야 한다. 그 해법은 그것이 아무것도 하지 않으면서도 CPU cycle을 소비하기 때문에 좋은 해법이 아니다. 최적화된 컴파일러는 그런 루프를 제거할수 있고, 그것은 예상치 못한 결과를 유도할수 있다. C1X 위원회 문서 [ISO/IEC 9899:201x] Section 6.8.5.6 에 의하면, volatile 객체들에 접근하지 않는 입/출력연산을 수행하지 않고, 바디,제어식 또는 (for 문장의 경우에서) 그것의 expression-3 안에서 동기화 또는 atomic 연산을 수행하지 않는 반복문장은, 구현체에 의해 종료로 가정될수 있다. 
이것은 컴파일러에게 그러한 빈 루프가 종료됨을 증명할수 없더라도 그것을  제거하는 식으로 변형시키는것을 허락하도록 의도된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_POS30_C</rule>
    <ruleTitle><![CDATA[readlink() 함수의 반환값이 검증되었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ readlink() 함수는 링크가 가리키는 곳이 어디인지 읽어온다. 하지만 2번 째 인자로 오는 버퍼에 널 종료문자를 남기지 않는다. 대신 이 함수는 버퍼에 기록된 글자 수를 반환한다. 따라서 반환된 숫자가 -1이 아닌지 확인 후 버퍼를 사용해야 한다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_POS33_C</rule>
    <ruleTitle><![CDATA[vfork() 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ vfork() 함수는 많은 이식성과 보안상의 이슈를 가지고 있다. 모든 상황에서 vfork()보다 fork()의 사용을 권장한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_POS34_C</rule>
    <ruleTitle><![CDATA[putenv의 인자로 자동 지속성을 갖는 type 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ POSIX 함수 putenv()는 환경 변수를 설정하기 위해 사용하는 함수다. putenv()는 인자로 전달된 문자열의 사본을 만들지 않고 문자열 포인터를 환경 변수 배열에 그대로 삽입한다. 만일 자동 지속성을 갖는 버퍼 포인터가 putenv()의 인자로 전달된다면 함수가 반환되고 스택 메모리가 다른 용도로 사용될 시점에 버퍼로 할당됐던 메모리 영역이 다른 데이터로 덮어 쓰였을 가능성이 있다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_POS39_C</rule>
    <ruleTitle><![CDATA[시스템 간에 데이터를 전송할 때 정확한 byte ordering을 사용하였는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 서로 다른 엔디언의 시스템 사이에 데이터를 전송할 때, 프로그래머는 시스템이 데이터를 풀이하기 전에 바이트 순서에 반전되는지에 대해 주의를 기울여야만 한다. htonl(), htons(), ntohl(), ntohs()는 network 바이트 순서와 host의 바이트 순서 간의 변환이 가능하도록 해주는 함수들이다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_POS44_C</rule>
    <ruleTitle><![CDATA[스레드를 종료시키는 시그널 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 스레드를 종료시키는 잡을 수 없는 시그널을 사용하는 것은 비단 해당 시그널 뿐만 아니라 프로세스 전체를 종료시킬 수 있기 때문에 사용하지 말아야 한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_PRE00_C</rule>
    <ruleTitle><![CDATA[함수 매크로 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 매크로는 사용법이 함수와 비슷하지만 문법은 다르기 때문에 위험하다. C99에서는 C 프로그래밍 언어에 인라인 함수를 도입했는데, 인라인 함수와 매크로를 모두 사용할 수 있는 경우라면 인라인 함수를 사용하는 편이 좋다. 인라인 함수를 사용하면 우리가 알고 있는 함수 호출 프로시저가 인라인으로 치환되기 때문에 함수 호출이 빨라진다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_PRE01_C</rule>
    <ruleTitle><![CDATA[함수 매크로의 파라미터가 괄호로 감싸졌는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 매크로 정의는 모든 매개변수 이름에 괄호를 사용해야 한다.  ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_PRE02_C</rule>
    <ruleTitle><![CDATA[매크로로 치환될 영역이 괄호로 감싸졌는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 매크로로 치환될 영역을 괄호로 둘러싸면 근처의 표현식으로 인해 우선순위가 바뀌는 일을 방지할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_PRE04_C</rule>
    <ruleTitle><![CDATA[표준 헤더를 ""로 include 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 표준 헤더와 같은 이름의 파일이 포함 파일 탐색 경로에 존재하면 undefined behavior이다. 
다음 목록은 표준 헤더를 나열한다.
<assert.h> 	<complex.h> 	<ctype.h> 	<errno.h> 	<fenv.h>
<float.h> 	<inttypes.h> 	<iso646.h> 	<limits.h> 	<locale.h>
<math.h> 	<setjmp.h> 	<signal.h> 	<stdarg.h> 	<stdbool.h>
<stddef.h> 	<stdint.h> 	<stdio.h> 	<stdlib.h> 	<string.h>
<tgmath.h> 	<time.h> 	<uchar.h> 	<wchar.h> 	<wctype.h>
표준 헤더파일 이름, system-specific 헤더파일 이름, 또는 다른 헤더파일 이름을 재활용해서는 안된다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_PRE06_C</rule>
    <ruleTitle><![CDATA[헤더 파일 중복 금지를 위한 처리가 되어있는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 헤더 파일을 포함하는 부분에서 중복된 헤더파일 때문에 문제가 일어날 수 있다. 각 헤더에 '이미 포함됐음' 이라는 의미의 심볼을 정의하여 전체 헤더를 인클루전 가드로 둘러 쌈으로써 해결할 수 있다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_PRE07_C</rule>
    <ruleTitle><![CDATA[연속되는 물음표 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 물음표를 두 개 이상 연속해서 사용하는 경우 삼중자 표기로 오해할 수 있다.  ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_PRE08_C</rule>
    <ruleTitle><![CDATA[헤더파일 중복 include 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 포함되는 헤더파일이 유일한지 확인해야한다. C99[ISO/IEC 9899:1999] 에 따르면 
구현체는 period (.)와 하나의 nondigit가 뒤따르는 하나 또는 그 이상의 nondigit 또는 digit(6.4.2.1)들로 구성된 연속체에 대한 유일한 매핑을 제공해야한다. 첫번째 문자는 숫자여서는 안된다. 구현체는 알파벳 대소문자를 무시할 수 있고, period 앞 기호문자들을 8개로 매핑을 제한할수 있다. 
이것은 다음을 의미한다.
* 파일명의 처음 8문자만이 의미있음을 보증한다.
* 파일은 파일명에서 period 뒤에 단 하나의 nondigit 문자를 가진다.
* 파일명의 대소문자는 의미를 보증하지 않는다.
헤더파일 이름이 유일함을 보증하기 위해 모든 포함파일들은 그들의 처음 여덟자가 다르거나 그들의 (단일문자) 파일 확장자가 달라야한다.
이 제안을 따르는것이 짧을 파일명 사용을 요구하는것은 아니며, 단지 파일명이 유일해야한다는 것이다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_PRE10_C</rule>
    <ruleTitle><![CDATA[복수 구문 매크로를 do-while 루프로 묶었는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 매크로는 다수의 연속된 문장집합을 실행하는데 자주 사용된다. 
인라인 함수는, 일반적으로, 이런 일에 적합하다. (제안 PRE00_C를 참조). 그러나 때때로 그들은 실행가능하지 않다(매크로가 다른 타입들의 변수들에 대해 연산을 수행할때 등). 
매크로에서 다수의 문장이 사용될때, 그들은 do-while 루프 안에 함께 묶여있어야 한다. 그렇게 해서 매크로는 절 또는 단일 문장이 나타날것이 기대되는 위치 또는 문장 블록에 안전하게 나타날수 있다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_PRE11_C</rule>
    <ruleTitle><![CDATA[매크로 정의 시 semicolon으로 끝나는지 검사 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 매크로는 소스코드의 가독성을 높이기 위해 자주 사용된다. 매크로정의는 그것들이 하나의 또는 다수의 문장들로 확정되는지에 관계없이, 세미콜론으로 끝나서는 안된다. (제안 PRE10_C 참고) 필요하다면 세미콜론은 매크로 확장 안에 포함되어야한다. 의도치 않게 매크로 정의 끝에 세미콜론을 넣는것은 프로그램의 제어흐름을 변화시킬수 있다. 
이 문제를 피하는 다른 방식은 함수형 매크로 대신 inline이나 static함수를 사용하는것이다 (제안 PRE00_C 참고). 
일반적으로, 프로그래머는 매크로 정의의 끝에 세미콜론이 없음을 확인해야한다. 이러한 매크로를 사용하는 동안에 필요한곳에서 세미클론을 가지게 하는것에 대한 책임은 매크로를 사용하는 사람에게 위임되어야 한다. ]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_PRE30_C</rule>
    <ruleTitle><![CDATA[여러 문자열을 붙여서 유니버설 문자열 이름을 만드는 매크로 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C99는 identifier들, 문자 상수들, 기본 문자집합에 없는 문자들로 된 string literal들에 쓰일수 있는 universal character name을 지원한다. universal character name \Unnnnnnnn 는 그것의 8자리의 identifier 가 nnnnnnnn 인 문자들을 지시한다. 유사하게, universal character name \unnnn 는 그것의 4자리의 identifier 가 nnnn 인 문자들을 지시한다. 그리고 그것의 8자리의 identifier는 0000nnnn이다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_PRE31_C</rule>
    <ruleTitle><![CDATA[매크로 함수에 side-effect가 있는 인자 사용 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 안전하지 않은 함수형 매크로는 코드 확장에서 파라메터를 한번 이상 평가하거나 전혀 평가하지 않는다. 안전하지 않은 매크로를 절대 할당, 증가, 감소, volatile 접근, 입/출력, 또는 다른 side effect가 있는 인자와 같이 사용해서는 안된다. (함수 호출도 side effect를 일으킬수 있다). 
안전하지 않은 매크로에 대한 문서화는 매크로 사용시 side effect를 일으키는것에 대해 반드시 경고해야 하지만, 매크로 사용의 책임은 프로그래머에게 있다. 그들의 사용에 관련된 위험요소들때문에, 안전하지 않은 매크로함수를 만들지 말것이 제안된다. (제안 PRE00_C 참고) 
aseert() 매크로는 안전하지 않은 매크로의 좋은 예이다. 그것의 인자는 한번 또는 전혀 평가되지 않을수 있고, NDEBUG 매크로에 의존적이다. 더 자세한 정보는 규칙 EXP31_C 참고. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_PRE32_C</rule>
    <ruleTitle><![CDATA[함수 매크로 사용시 인자 부분에 Preprocessor directive가 들어가면 안됨 ]]></ruleTitle>
    <ruleDesc><![CDATA[ 매크로의 인자는 전처리 지시자를 포함하는 것은 정의되지 않은 행동을 유발한다. ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_SIG30_C</rule>
    <ruleTitle><![CDATA[시그널 핸들러에서는 비동기적으로 안전한 함수만 호출하라 ]]></ruleTitle>
    <ruleDesc><![CDATA[  signal handler안에서는 비동기적으로 안전한(asynchronous-safe)함수만을 호출해야한다. 이 제한은 어플리케이션에 정의된 함수뿐만 아니라 라이브러리 함수들에게도 적용된다. 
C Rationale [ISO/IEC 2003] 의 7.14.1.1 에 따르면, signal이 발생할때, 프로그램의 일반적인 제어흐름은 인터럽트된다. signal handler에 의해 잡히는 signal 발생하면 handler가 불려진다. 그것이 종료될때, signal이 발생했던 지점에서 실행이 계속된다. 이 장치는 signal handler가 signal 시점에 실행되는 라이브러리 함수를 부른다면 문제를 일으킬수 있다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_SIG31_C</rule>
    <ruleTitle><![CDATA[시그널 핸들러에서 변수 사용 제한 ]]></ruleTitle>
    <ruleDesc><![CDATA[ signal handler 에서 공유객체에 접근하거나 변경하는것은 일관성 없는 상태에 데이타를 남겨놓는 race condition을 일으킬수 있다. 이 규칙의 예외는 volatile sig_atomic_t 변수를 읽고 쓰는것이다. volatile 키워드의 필요성은 규칙 DCL34_C에 기술되어있다. 그것은 signal handler로부터 다른 어떤 타입의 객체에 접근하는 프로그램의 동작을 아는데 중요하다 (C99 의 Appendix J 의 undefined behavior 125 참고). 
sig_atomic_t 타입은 비동기적 interrupt 상황에서도 atomic entity로서 접근할수 있는 객체의 integer 타입이다. sig_atomic_t 타입은 구현체에 정의된다. SIG_ATOMIC_MIN 에서 SIG_ATOMIC_MAX 범위의 integer 값들은, 안전하게 해당 타입의 변수에 저장될수 있다. 추가적으로 sig_atomic_t 가 signed integer 타입일때, SIG_ATOMIC_MIN 는 -127보다 클수 없고 SIG_ATOMIC_MAX 는 127보다 작을수 없다. 그 외에는 SIG_ATOMIC_MIN 은 0이어야 하고 SIG_ATOMIC_MAX sms 255보다 작지 않다. SIG_ATOMIC_MIN 와 SIG_ATOMIC_MAX 매크로는 헤더 <stdint.h> 정의되어있다. ]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_SIG32_C</rule>
    <ruleTitle><![CDATA[시그널 핸들러에서는 longjmp() 함수 호출 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ signal handler안에서 longjmp() 함수를 호출하는것은 undefined behavior 를 유도할수 있다. 비동기적으로 안전하지 않은 (non-asynchronous-safe)함수를 호출하게 된다면, 프로그램의 완전성(integrity)이 손상받기 쉽다. longjmp() 뿐만 아니라 POSIX siglongjmp() 또한 signal handler안에서 호출되어서는 안된다. 
이 규칙은 SIG30-C와 밀접하게 연관되어있다. ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_SIG33_C</rule>
    <ruleTitle><![CDATA[raise() 함수 재귀적으로 호출 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ C99는 raise() 함수의 재귀적 호출을 불허한다. C99, Section 7.14.1.1#4[ISO/IEC 9899:1999] 에 따르면, 
abort 또는 raise 함수 호출의 결과로 signal이 발생하면, signal handler는 raise 함수를 호출해서는 안된다. 
(Annex J 의 undefined behavior 124 참조) ]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>KEPCO_Security</ruleSetName>
    <ruleSetDesc><![CDATA[한전 보안 규칙 모음]]></ruleSetDesc>
    <rule>KEPCO_SIG34_C</rule>
    <ruleTitle><![CDATA[interruptible signal handlers 안에서 signal() 함수 호출 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[ signal handler들은 자신의 signal을 다루는 목적을 재설정 하지 않아야 한다. 이것은 지속성이 없는(nonpersistent) 플랫폼에서 자주 일어난다. signal을 받는 플랫폼은 연결된 signal handler의 호출 전에 signal에 대한 disposition 을 리셋한다. 
signal handler는 비동기적으로 안전(asynchronous-safe)하게 될 필요가 없을때에만 singal() 을 호출하는것이 좋다. (다른말로하면 모든 해당 signal들은 mask되어야 하고, handler는 interrupt되어서는 안된다.) ]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding_For_Runtime</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding to Runtime Error by Suresoft.
If you activate this ruleset, It may be possible for analyzing the project to take the time longer.]]></ruleSetDesc>
    <rule>SC_Access_Buffer_Using_Src_Buffer_Size</rule>
    <ruleTitle><![CDATA[소스 버퍼 크기를 사용하여 버퍼 접근]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 소프트웨어는 대상 버퍼에서 읽거나 쓸 때 소스 버퍼 크기를 사용하여 버퍼를 벗어난 메모리에 접근할 수 있으며 이때 대상 크기가 소스 크기보다 작으면 버퍼오버플로우가 발생할 수 있다]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding_For_Runtime</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding to Runtime Error by Suresoft.
If you activate this ruleset, It may be possible for analyzing the project to take the time longer.]]></ruleSetDesc>
    <rule>SC_Add_Or_Subtract_Scaled_Int_To_Ptr</rule>
    <ruleTitle><![CDATA[포인터에 크기가 자동으로 조정된 정수의 덧셈 및 뺄셈 연산 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약: 포인터에 산술연산을 수행할 때 포인터에 더해지거나 빼지는 피연산자 값은 포인터가 가리키는 객체 타입에 맞게 자동적으로 조정되므로 주의해야 한다. 그렇지 않을 경우 심각한 연산 오류나 버퍼 오버플로우 등을 초래할 수 있다.<br><br>

포인터 연산을 수행할 때 더하는 값 자체는 바이트 수를 의미하지 않는다. 다시 말해 연산에서 더해지는 값은 자동적으로 포인터가 가리키는 객체의 타입으로 조정된다. 예를 들어, 4바이트 정수를 가리키는 포인터에 특정 정수를 더하는 연산을 진행하게 되면 더해지는 값은 자동적으로 4가 곱해진 뒤 포인터에 더해진다. 위와 같이 스케일링되는 방식을 이해하지 못할 경우, 포인터는 전혀 다른 주소 등을 가리키게 된다. 그 결과 연산의 결과가 다르거나 심각한 연산 오류 및 상황에 따라 버퍼 오버플로우 등을 초래할 수 있다. 또한 최악의 경우 악의적 해커가 삽입한 임의의 공격 코드를 수행하게 될 수도 있다. 따라서 포인터 연산에 대하여 정확히 이해하고 의도한 연산이 정확히 수행되도록 보장해야 한다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding_For_Runtime</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding to Runtime Error by Suresoft.
If you activate this ruleset, It may be possible for analyzing the project to take the time longer.]]></ruleSetDesc>
    <rule>SC_Avoid_Assign_Return_Of_Local_Var_Addr</rule>
    <ruleTitle><![CDATA[지역 변수 주소 반환 및 할당 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약: 함수의 스택 메모리 영역의 주소를 반환하거나 전달해서는 안 된다. 이는 의도치 않은 프로그램의 동작을 야기한다.<br><br>

함수 내에서 지역 변수를 선언할 경우 이는 스택 메모리 영역에 저장된다. 바꾸어 말하면 어떤 함수 func()를 호출하면 스택 구조에는 함수 func()의 수행이 끝나면 복귀할 복귀 주소와 지역 변수를 위한 공간 등이 할당된다. 그리고 함수 func()를 수행하고, 수행이 끝나면 지역 변수에 할당한 스택 공간을 해제하고 복귀할 주소를 스택에서 꺼내어 func()를 호출한 함수로 복귀하게 된다. 이때 함수의 반환과 동시에 해당 스택은 해제되기 때문에 해당 지역 변수의 주소는 더 이상 유효한 주소가 아니다. 따라서 선언한 지역 변수의 주소를 반환하는 행위는 유효하지 않은 주소를 반환하는 행위와 같다. 또한 이 주소를 참조할 경우 유효하지 않은 주소에 대한 참조로 인하여 시스템의 충돌, 비정상적인 종료를 비롯한 의도되지 않은 동작을 유발할 수 있다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding_For_Runtime</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding to Runtime Error by Suresoft.
If you activate this ruleset, It may be possible for analyzing the project to take the time longer.]]></ruleSetDesc>
    <rule>SC_Avoid_Compare_Not_Checking_Min_Value</rule>
    <ruleTitle><![CDATA[최소값 검사 없이 수치 범위 비교 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 어플리케이션에서 값이 최대값 이하인지 확인하지만 최소값보다 크거나 같은지 확인하지 않음으로 인해 문제가 발생하게 되는 것을 예방하여야 한다.<br><br>

일부 프로그램은 값이 양수 또는 0으로만 예상되는 경우에도 부호 있는 정수 또는 부동소수점을 사용한다. 입력 유효성 검사는 값이 양수라고 가정하고 최대값만 검사한다. 값이 음수이지만 코드에서 값이 양수인 것으로 가정하면 일로 인해 오류가 발생할 수 있다. 음수 값이 메모리 할당, 배열 접근, 버퍼 접근 등에 사용되는 경우에 오류로 인하여 버퍼 오버 플로우 또는 다른 유형의 메모리 손상이 발생할 수 있다. 양수 전용 컨텍스트에서 음수를 사용하면 다른 유형의 리소스에 영향을 끼칠 수 있다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding_For_Runtime</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding to Runtime Error by Suresoft.
If you activate this ruleset, It may be possible for analyzing the project to take the time longer.]]></ruleSetDesc>
    <rule>SC_Avoid_Out_Of_Bound_Ptr_Or_Arr_inx</rule>
    <ruleTitle><![CDATA[배열의 메모리 읽기, 쓰기 작업 시 인덱스가 유효 범위 안에 있음을 보장]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 배열의 메모리 버퍼에 값을 쓰거나 참조하는 경우 잘못된 인덱스를 사용하여 배열의 유효범위를 초과해서는 안 된다. <br><br>

유효하지 않은 배열의 인덱스를 사용하여 배열에 읽기, 쓰기 동작을 할 경우 의도치 않은 메모리 영역에 값을 쓰거나 다른 중요한 데이터 메모리 영역을 덮어 씌우는 등의 취약점을 발생시킬 수 있다. C언어에서는 직접 주소를 통한 메모리 접근은 허용하는 반면, 메모리가 참조하는 위치의 유효성에 대해서는 보장하지 않는다. 따라서 잘못된 인덱스를 통해 접근한 메모리 위치에서의 읽기, 쓰기 동작은 임의의 메모리 공간의 값을 변경하거나 잘못된 값을 참조하게 된다. 악의적 공격자는 해당 보안 약점을 악용하여 악의적 코드 수행을 위해 제어 흐름을 변경하거나 중요 데이터의 값을 변경하는 등의 메모리 무결성 훼손 및 비정상적인 프로그램 수행 등의 취약점을 발생시킬 수 있다. 또한 데이터의 유출 등을 통하여 기밀성을 훼손할 수도 있다.
]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding_For_Runtime</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding to Runtime Error by Suresoft.
If you activate this ruleset, It may be possible for analyzing the project to take the time longer.]]></ruleSetDesc>
    <rule>SC_Buffer_Underwrite</rule>
    <ruleTitle><![CDATA[버퍼 시작 지점 이전에 쓰기]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 포인터나 인덱스를 통해 버퍼 시작 지점 이전에 데이터를 기록하는 오류이다.<br><br>

포인터 또는 인덱스가 최저 위치보다 적은 위치에 데이터를 기록하는 경우 발생하며 루프내에서 범위 점검 없이 포인터 감소 연산을 계속했을 경우 발생하게 된다. 이를 예방하기 위하여 버퍼에 인덱스나 포인터를 사용해서 데이터를 기록할 때 인덱스가 음수 값이 되거나 포인터 연산의 결과가 버퍼 이전의 값을 가지지 않도록 점검 후 사용한다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding_For_Runtime</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding to Runtime Error by Suresoft.
If you activate this ruleset, It may be possible for analyzing the project to take the time longer.]]></ruleSetDesc>
    <rule>SC_Cast_Between_Ptr_And_Int</rule>
    <ruleTitle><![CDATA[포인터와 정수형과의 형변환 시 주의]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 만약 형변환된 포인터가 메모리에 잘못 배치되었거나 잘못된 주소의 객체를 가리키거나,혹은 객체가 없는 주소의 메모리를 가리킨다면 정수형 타입을 포인터 타입으로 바꾸면 안 된다.
<br><br>
프로그래머는 종종 C언어에서 포인터와 정수형을 번갈아가면서 사용한다. 또한, 정수형과 포인터 간의 형변환은 의도치 않은 결과를 가져올 수 있는데 이는 구현 환경에 따라서 다른 결과를 가져온다. C표준에서는 “정수는 포인터 타입으로 형변환 될 수 있다. 결과는 구현 환경에 따라 다르다. 메모리 상에 잘못 배치될 수도 있고, 잘못된 주소의 객체를 가리킬 수도 있다. 또한 객체가 없는 주소의 메모리를 가리킬 수도 있다.” 명시하고 있다. 만약 형변환된 포인터가 메모리에 잘못 배치되거나 잘못된 주소의 객체를 가리키거나 혹은 객체가 없는 주소의 메모리를 가리킨다면 정수형 타입을 포인터 타입으로 바꾸면 안 된다. 또한, 만약 결과가 정수형 타입으로 표현될 수 없다면, 포인터 타입을 정수형 타입으로 바꾸면 안 된다.
<br><br>
예외상황<br>
- intptr_t, uintptr_t 타입으로 형변환<br>
- 상수 0 형변환<br>
- void pointer형변환<br>
- intptr_t, uintptr_t 타입으로 형변환<br>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding_For_Runtime</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding to Runtime Error by Suresoft.
If you activate this ruleset, It may be possible for analyzing the project to take the time longer.]]></ruleSetDesc>
    <rule>SC_Compiler_Removal_Code_To_Clear_Buffer</rule>
    <ruleTitle><![CDATA[컴파일러의 버퍼를 지우는 코드 제거 오류]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 메모리에 저장된 중요한 또는 민감한 정보 사용 후 메모리에서 제거하는 작업을 수행하는 코드가 존재함에도 컴파일러 최적화로 인해 해당 부분의 코드가 삭제되어 중요 정보가 그대로 메모리에 잔존하게 된다.<br><br>

컴파일러 최적화 오류는 다음과 같은 순서로 발생하게 된다.<br>
1. 메모리에 기밀 데이터가 저장된다.<br>
2. 기밀 정보 사용 후, 해당 메모리에 담긴 내용을 덮어쓰는 작업을 통해 기밀데이터 제거<br>
3. 이때, 소스코드는 최적화된 컴파일러를 사용하여 컴파일 수행시, 앞서 덮어 씌워진 메모리는 이후 코드 실행 시 더 이상 사용하지 않기 때문에 컴파일러는 데드공간 덮어쓰기 기능을 불필요하다고 판단하여 해당 코드를 삭제한다.<br>
기밀 정보를 제거하는 코드가 컴파일러 최적화 과정에서 삭제되었기 때문에 이후, 중요 기밀정보는 그대로 메모리에 저장되고 잔존하게 되며 중요 정보 노출 위험에 놓이게 된다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding_For_Runtime</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding to Runtime Error by Suresoft.
If you activate this ruleset, It may be possible for analyzing the project to take the time longer.]]></ruleSetDesc>
    <rule>SC_Divide_By_Zero</rule>
    <ruleTitle><![CDATA[나눗셈이나 모듈로 연산에서 ‘0으로 나누기 (Divide by Zero)’에러가 발생하지 않도록 보장]]></ruleTitle>
    <ruleDesc><![CDATA[요약: 나눗셈이나 모듈로 연산이 0으로 나누는 에러를 발생시키지 않음을 보장해야 한다.<br><br>

나눗셈 연산(/)이나 모듈로 연산(%)에 대해서 두 번째 피연산자인 제수가 0이 되지 않도록 보장해야한다. 제수가 0이 될 경우 ‘0으로 나누기(Divide By Zero)’ 에러가 발생 가능하다. 차량 단말기에서 본 보안 약점은 개발자의 실수로도 발생 가능하지만, Normal CAN, CCP(CAN Calibration Protocol) 등을 비롯하여 진단 통신, 텔레매틱스 입력 등의 외부로부터 유입된 데이터나 이런 데이터를 이용한 연산의 결과가 검증 절차 없이 제수로서 사용될 경우 악의적 해커에 의해 강제 발생될 수 있다. 특히 이와 관련하여 수신되는 CAN 데이터 등이 0 값이 들어오지 않는다고 개발자가 판단하여 검증 절차 없이 제수로 사용하는 경우가 빈번히 발생되는데, 이는 정상적인 수행 흐름에서는 문제가 발생하지 않지만 악의적 해커에 의해 조작된 CAN 데이터가 수신될 경우 충분히 문제가 발생 가능하다. ‘0으로 나누기’ 에러의 경우 기본적으로는 비정상적인 프로그램 종료와 서비스 거부 상태를 초래할 수 있다. 그러나 이와 같은 가용성의 문제와 더불어 악의적 해커가 본 보안 약점을 이용할 경우 최악의 경우 ‘0으로 나누기’를 시작으로 악의적 코드 수행의 시작점이 될 수도 있다. 악의적 해커가 임의의 악의적 코드를 특정 메모리 번지에 삽입을 하고 ‘0으로 나누기’ 에러가 발생될 경우, 수행하게 되는 예외 처리기(exception handler)에 이 특정 메모리 번지로 점프하도록 수정을 한다면 ‘0으로 나누기’ 에러는 악의적 행위의 트리거 포인트 역할을 하게 된다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding_For_Runtime</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding to Runtime Error by Suresoft.
If you activate this ruleset, It may be possible for analyzing the project to take the time longer.]]></ruleSetDesc>
    <rule>SC_Free_Needless_Dyn_Alloc_Memory</rule>
    <ruleTitle><![CDATA[더 이상 필요하지 않을 때 동적으로 할당된 메모리 해제 처리 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 할당된 메모리가 더 이상 필요하지 않을 때, 메모리를 동적으로 할당 해제해야 한다.<br><br>

메모리 할당 함수에 대한 호출의 반환 값을 저장하고 있는 포인터의 생명주기가 끝나기 전에 해당 포인터를 free()로 올바르게 할당 해제해야 한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding_For_Runtime</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding to Runtime Error by Suresoft.
If you activate this ruleset, It may be possible for analyzing the project to take the time longer.]]></ruleSetDesc>
    <rule>SC_Length_Parameter_Inconsistency</rule>
    <ruleTitle><![CDATA[for문과 같은 반복문에서 배열 등에 접근 시 길이 매개변수 처리에 주의]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 반복문에서 배열 등의 버퍼에 접근하는 경우 반복문의 길이 매개변수 처리에 주의해야 한다. 잘못된 길이 매개변수의 사용은 버퍼 오버플로우 등의 문제를 발생시킬 수 있다.<br><br>

일반적으로 배열 등의 버퍼에 순차적으로 접근하여 값을 읽거나 쓰는 경우, for문과 같은 반복문을 사용하는 경우가 많다. 이때 반복문의 길이 매개변수(예, for(i=0; i<x; i++)에서 x)를 잘못된 값으로 사용하면 배열 등의 버퍼 범위를 초과하여 접근하게 되고 버퍼 오버플로우 등의 문제를 발생시킬 수 있다. 따라서 길이 매개변수를 올바르게 설정함으로써, 반복문을 통하여 배열에서 특정 원소를 찾을 때에는 배열의 경계값 내에서 반드시 찾을 수 있도록 하거나 배열의 경계 밖 메모리 영역에 대하여 데이터를 읽거나 쓰지 못하도록 제한하는 것이 매우 중요하다. 악의적 공격자는 본 보안 약점의 버퍼 오버플로우를 이용하여 임의의 악의적 코드를 수행하거나 시스템의 충돌을 일으키고 시스템을 무한 반복에 빠지게끔 할 수 있다. 또한 실제 사례로 범위 초과 읽기를 발생시키는 잘못된 길이 매개변수를 이용하여 개인 암호화 키와 기타 민감한 정보 등이 포함된 메모리를 반환하는 공격 또한 발생된 바 있다(CVE-2014-0160).]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding_For_Runtime</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding to Runtime Error by Suresoft.
If you activate this ruleset, It may be possible for analyzing the project to take the time longer.]]></ruleSetDesc>
    <rule>SC_Null_Pointer_Dereference</rule>
    <ruleTitle><![CDATA[널 포인터 역참조 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 널 포인터 역참조(null pointer dereference)가 발생되지 않도록 항상 보장해야 한다. 널(NULL) 포인터 역참조 오류는 일반적으로 시스템의 비정상적인 종료뿐만 아니라 다양한 보안 취약점을 유발할 수 있다.<br><br>

널 포인터 역참조는 포인터의 값이 널(NULL)인 것을 고려하지 못하고 포인터가 유효하다고 가정한 상태에서 널 값을 가지는 포인터가 가리키는 값을 참조할 때 발생하는 오류를 말한다. 널 포인터를 역참조하면 일반적으로 시스템의 충돌 또는 비정상적인 종료를 야기한다. 뿐만 아니라 악의적 공격자가 의도적으로 널 포인터 역참조를 발생시키는 경우, 이로 인해 발생하는 예외 사항을 추후 공격으로 사용하거나 임의의 코드를 실행할 수도 있다. 따라서 개발자는 널 포인터 역참조가 발생되지 않도록 항상 보장해야 한다. 이를 위해서 신뢰할 수 없는 입력의 모든 포인터에 대해서 그리고 널 포인터가 할당될 가능성이 있는 포인터에 대해서는 사용 전 포인터가 유효한지 널 포인터 검사를 하고 사용해야 한다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding_For_Runtime</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding to Runtime Error by Suresoft.
If you activate this ruleset, It may be possible for analyzing the project to take the time longer.]]></ruleSetDesc>
    <rule>SC_Omitted_Break_Stmt_In_Switch</rule>
    <ruleTitle><![CDATA[switch문에서 break 생략 금지]]></ruleTitle>
    <ruleDesc><![CDATA[switch 문에서 break 문을 생략하여 여러 조건과 관련된 코드가 실행되도록 할 때 임의의 하나의 조건만을 실행하려고 할 때 문제가 발생한다. <br><br>

switch 문 내부 break 문은 컴파일러에 이 switch 문 사용이 완료되었음을 알려준다. 만일 개발자가 break 문을 생략한 경우 의도한 조건 하나만 실행이 불가능하며 소프트웨어에서 fall-through가 발생하며 의도하지 않은 오류를 발생시킬 수 있다. 이를 예방하기 위해서는 구현 단계에서 모든 논리적 가능성을 조사하여야 한다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Dead Code</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding_For_Runtime</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding to Runtime Error by Suresoft.
If you activate this ruleset, It may be possible for analyzing the project to take the time longer.]]></ruleSetDesc>
    <rule>SC_Race_Cond_In_Switch</rule>
    <ruleTitle><![CDATA[switch 경쟁 조건]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : switch 코드가 포함된 코드에서 switch 변수를 수정할 수 있는 경우 예기치 않은 동작이 발생한다.<br><br>

이 문제는 폴-스루(fall-through) 스타일 case 문이 포함된 switch 구문(예 : 중단으로 끝나지 않는 문)의 경우에 특히 중요하다. 실행중인 변수가 실행 과정에서 변경되면 수행된 작업으로 인해 프로세스 상태가 모순되는 상태가 되거나 메모리 손상이 발생할 수 있다. 이러한 이유로, switch 명령문과 관련된 모든 변수는 명령문이 시작되기 전에 잠기고 명령문이 종료될 때 잠금 해제되어야 한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Interface</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding_For_Runtime</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding to Runtime Error by Suresoft.
If you activate this ruleset, It may be possible for analyzing the project to take the time longer.]]></ruleSetDesc>
    <rule>SC_Read_Uninitialized_Memory</rule>
    <ruleTitle><![CDATA[초기화되지 않은 메모리 참조(접근, 읽기) 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 초기화되지 않은 지역 변수, 배열 등의 메모리를 참조하거나 그 값을 사용하면 의도치 않은 결과를 초래할 수 있으므로 사용하지 않아야 한다. 또한 초기화는 가급적 명시적 초기화를 이용해야 한다.<br><br>

초기화되지 않은 지역 변수, 배열 등의 메모리를 참조할 경우 그 결과는 예측 불가능하다. 초기값을 정의하지 않고 선언만 된 변수나 메모리만 할당된 배열은 기존 스택 메모리에 저장되어 있던 임의의 값(기본 값) 등을 갖게 되고, 해당 변수를 참조할 경우 임의의 값에 대한 참조가 이루어지게 된다. 이는 C99에서 함수의 스택 메모리 초기화에 대하여 ‘정의되지 행동(undefined behavior)’으로 분류하여 컴파일러나 아키텍처에 따라 다른 결과를 만들기 때문이다. 따라서 초기화되지 않은 변수나 배열 등의 메모리를 참조해서는 안 된다. 일반적으로 초기화되지 않은 변수 등은 소프트웨어 신뢰성 문제로 결부된다. 만약 악의적 공격자가 초기화되지 않은 변수를 의도적으로 이용한다면 프로그램에 손상을 주면서 ‘서비스 거부 공격’ 등을 유발할 수 있다. 또한 중요 정보에 대하여 명시적 초기화를 진행하지 않으면 문제가 발생하기도 한다. 명시적 초기화가 진행되지 않아 기본 값으로 초기화가 진행되는 경우 이 임의의 값 중에는 프로그램의 로직에 따라 보안에 영향을 끼칠 수도 있다. 실 사례로 보안 관련 주요 변수에 명시적 초기화가 올바르게 진행되지 않아 인증 시스템이 잘못 동작하여 악의적 임의 코드가 수행된 사례(CVE-2008-0081)와 시드키 알고리즘에서 랜덤 함수의 시드를 초기화하지 않아 보안 사고가 발생한 사례(CVE-2007-2728) 등이 있다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding_For_Runtime</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding to Runtime Error by Suresoft.
If you activate this ruleset, It may be possible for analyzing the project to take the time longer.]]></ruleSetDesc>
    <rule>SC_Shared_Resource_With_Improper_Sync</rule>
    <ruleTitle><![CDATA[부적절한 동기화로 공유 자원을 사용하여 동시 실행(레이스 조건) 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 다른 코드와 동시에 실행할 수 있는 코드 시퀀스가 포함되어 있으며 코드 시퀀스에는 공유 자원에 대한 일시적인 독점적인 접근이 필요하지만 동시에 작동하는 다른 코드 시퀀스에 의해 공유 자원을 수정할 수 있는 타이밍 윈도우가 존재하게 된다.<br><br>

사용자 인증 여부를 기록하거나 외부의 영향을 받지 않아야 하는 중요한 상태 정보 수정과 같이 예상되는 동기화가 보안에 중요한 코드이 경우 보안에 영향을 줄 수 있다. 경쟁 조건은 동시 환경에서 발생하며 사실상 코드 시퀀스 속성이다. 컨텍스트에 따라 코드 시퀀스는 함수 호출, 적은 수의 명령어, 일력의 프로그램 호출 중의 형태일 수 있다. 경쟁 조건은 다음과 같은 속성을 위반한다.<br><br>

<table align="center" border="1" cellpadding="6">
<tr align="center" >

<tr align="center" >
<td rowspan="2"><b>조건</b></td><td rowspan="2"><b>설명</b></td>
</tr>

<tr align="center">
</tr>

<tr align="center">
<td>독립성 </td><td>코드 시퀀스에는 공유 자원에 대한 독점 접근 권한이 부여되어 원래 시퀀스가 실행을
완료하기 전에는 다른 시퀀스가 공유 리소스의 속성을 수정할 수 없다.</td>
</tr>

<tr align="center">
<td>원자성</td><td>코드 시퀀스는 동작성 원자적이다. 즉, 다른 스레드나 프로세스가 동일한 리소스에 대한
동일한 시퀀스의 명령(또는 하위 집합)을 동시에 실행할 수 없다.</td>
</tr>

</table>
<center>[표 15 경쟁조건의 위반 속성]</center><br><br>

간섭코드 시퀀스가 여전히 독점을 위반하여 공유 자원에 접근할 수 있는 경쟁 조건이 존재한다. 개발자는 특정 코드 시퀀스가 너무 빨리 실행되어 간섭 코드 시퀀스의 영향을 받지 않는다고 가정할 수 있다. 그렇지 않으면 원자성을 위반한다. 예를 들어, 단일 'x++'은 코드 계층에서 원자적으로 나타날 수 있지만 실제로는 명령 계층에서 원자가 아니다. 이는 읽기(원래 x의 값)와 계산(x+1)이 포함되어 있고 이후 쓰기를(결과를 x에 저장) 하기 때문이다.]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding_For_Runtime</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding to Runtime Error by Suresoft.
If you activate this ruleset, It may be possible for analyzing the project to take the time longer.]]></ruleSetDesc>
    <rule>SC_Signed_Integer_Overflow</rule>
    <ruleTitle><![CDATA[부호 있는 정수의 연산이 오버플로우 되지 않도록 보장 ]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 부호 있는 정수(signed type)에 대해서 연산을 수행할 때에는 항상 정수형 오버플로우(integer overflow)가 발생되지 않도록 보장해주어야 한다. 이는 정상적인 기능 수행에 문제가 될 뿐만 아니라 다양한 보안 취약점을 유발할 수 있다.<br><br>

C표준(C99)에서는 정수 오버플로우(integer overflow)를 정의되지 않은 동작(undefined behavior)으로 분류하고 있다. 즉, 정수 오버플로우를 처리하는 방법에 대해서는 아키텍처나 컴파일러 및 구현 방식에 따라 달라질 수 있다. 컴파일러에 따라서는 정수 오버플로우에 대해서 감지를 하는 컴파일러도 존재하지만, 오버플로우가 전혀 발생하지 않는다고 가정하고 객체를 생성하는 컴파일러도 있다. 따라서 개발 과정에서 부호 있는 정수의 연산이 정수 오버플로우를 발생시키지 않도록 보장해야 한다. 차량 단말기 개발 단계에서는 특히 외부의 신뢰할 수 없는 값과 연관되어 연산이 일어날 때 정수 오버플로우가 발생하기 쉽다. 만약 일반 CAN, CCP, 진단통신과 같은 외부 통신 등으로부터 입력된 값이 연산에 사용되어 정수 오버플로우를 발생시킬 소지가 존재한다면 악의적 해커는 이 값들을 변조하는 공격을 수행할 수 있다. 정수 오버플로우된 값이 하기 항목 중에 사용된다면, 취약점을 발생시킬 수 있을 뿐만 아니라 “CWE-680 : Integer Overflow to Buffer Overflow”와 같이 정수 오버플로우가 버퍼 오버플로우로 확장될 수도 있다.<br><br>
1. 배열의 인덱스<br>
2. 포인터 연산<br>
3. 객체 길이나 크기<br>
4. 배열의 경계(예, 반복문 카운터)<br>
5. 메모리 할당 함수의 인수 (텔레매틱스 등의 경우)<br>
6. 기타 보안에 민감한 코드<br>
대부분의 정수 연산에서는 결과값이 사용하는 자료형으로 표현되지 못하는 경우 오버플로우가 발생한다. 아래 표에서는 오버플로우가 발생 가능한 연산자를 나타내고 있다. 더불어 주요 연산(덧셈, 뺄셈, 곱셈, 나눗셈, 모듈로, 단항 부정, 왼쪽 시프트 연산자)에서의 오버플로우에 대하여 상세 설명을 나누어 진행한다.<br><br>
<table align="center" border="1" cellpadding="6">
<tr align="center" >

<tr align="center" >
<td rowspan="2"><b>연산자</b></td><td rowspan="2"><b>오버플로우</b></td>
<td rowspan="2"><b>연산자</b></td><td rowspan="2"><b>오버플로우</b></td>
<td rowspan="2"><b>연산자</b></td><td rowspan="2"><b>오버플로우</b></td>
<td rowspan="2"><b>연산자</b></td><td rowspan="2"><b>오버플로우</b></td>
</tr>

<tr align="center">
</tr>

<tr align="center">
<td>+ </td><td>발생</td>
<td>+= </td><td>발생</td>
<td>^= </td><td>미발생</td>
<td>< </td><td>미발생</td>
</tr>

<tr align="center">
<td>-</td><td>발생</td>
<td>-= </td><td>발생</td>
<td><< </td><td>발생</td>
<td>> </td><td>미발생</td></tr>

<tr align="center">
<td>* </td><td>발생</td>
<td>/= </td><td>발생</td>
<td>>> </td><td>미발생</td>
<td>>= </td><td>미발생</td></tr>

<tr align="center">
<td>/ </td><td>발생</td>
<td>%= </td><td>발생</td>
<td>& </td><td>미발생</td>
<td><= </td><td>미발생</td></tr>

<tr align="center">
<td>% </td><td>발생</td>
<td><<= </td><td>발생</td>
<td>| </td><td>미발생</td>
<td>== </td><td>미발생</td></tr>

<tr align="center">
<td>++ </td><td>발생</td>
<td>>>= </td><td>미발생</td>
<td>^ </td><td>미발생</td>
<td>!= </td><td>미발생</td></tr>

<tr align="center">
<td>-- </td><td>발생</td>
<td>&= </td><td>미발생</td>
<td>~ </td><td>미발생</td>
<td>&& </td><td>미발생</td></tr>

<tr align="center">
<td>= </td><td>미발생</td>
<td>|= </td><td>미발생</td>
<td>! </td><td>미발생</td>
<td>|| </td><td>미발생</td>
</tr>
</table>
<center>[표 9 오버플로우를 야기할 수 있는 연산자 집합]</center>]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding_For_Runtime</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding to Runtime Error by Suresoft.
If you activate this ruleset, It may be possible for analyzing the project to take the time longer.]]></ruleSetDesc>
    <rule>SC_Use_After_Free</rule>
    <ruleTitle><![CDATA[해제된 메모리 참조 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약: 메모리 관리 함수에 의해서 할당 해제된 메모리에 대한 포인터의 역참조, 포인터 산술 및 형변환은 정의되지 않은 동작을 야기한다.<br><br>

메모리 관리 함수에 의해서 할당 해제된 메모리에 대한 포인터의 역참조, 포인터 산술 및 형변환은 정의되지 않은 동작을 야기한다. 이 때 할당 해제된 메모리를 가리키는 포인터를 ‘댕글링 포인터(Dangling  ointer) 또는 허상 포인터’라고 부른다. 댕글링 포인터에 접근하는 것은 취약점로 이어질 수 있다. C표준에 따르면 free() 혹은 realloc() 함수를 호출하여 할당 해제된 메모리를 참조하는 것은 정의되지 않은 동작을 야기한다. 할당 해제된 메모리를 읽는 것은 정의되지 않은 동작을 야기하는데, 해당 포인터의 값이 정의되지 않은 값이기 때문이다. 하여 소멸된 메모리를 가리키는 모든 포인터들은 유효하지 않은 상태가 되고 할당된 공간을 접근할 수 없는 소멸된 공간을 만들면서 메모리의 내용들을 운영체제로 반환하거나 비활성화된다. 결과적으로 소멸된 메모리로부터 데이터를 읽거나 쓰려고 하면 안 된다]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding_For_Runtime</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding to Runtime Error by Suresoft.
If you activate this ruleset, It may be possible for analyzing the project to take the time longer.]]></ruleSetDesc>
    <rule>SC_Use_Compare_Instead_Of_Assign</rule>
    <ruleTitle><![CDATA[할당 연산자 대신 비교 연산자를 사용하는 경우에 주의]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 할당 연산자 대신 비교 연산자를 사용하는 등의 잘못된 연산자를 사용하는 경우에 주의해야 한다. 보안 관련된 기능의 경우 의도치 않은 결과를 초래할 수 있다.<br><br>

할당 연산자를 사용해야 할 구문에 비교 연산자를 사용하는 경우는 대부분의 경우 개발자의 오탈자로 인한 버그이다. 이는 특정 연산 전에 사전 값의 설정이 이루어 지지 않는 등의 문제를 발생시켜 의도치 않은 수행 결과를 초래할 수 있다. 또한 할당 연산자 대신 비교 연산자를 사용하는 경우에는 컴파일러에 따라 경고를 주는 컴파일러도 존재하지만 대부분의 경우 경고나 오류 없이 컴파일되는 경우가 많아 사용자가 간과하기 쉽다. 이와 같은 문제는 보안 관련 기능에서 발생 시 치명적인 보안 사고를 유발할 수 있다. 예를 들어 인증 결과를 반환하는 함수에서 인증 거부 결과가 제대로 반환 값으로 설정되지 않는다면 실제와 무관하게 항상 인증되는 결과 등이 나타날 수 있다.]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding_For_Runtime</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding to Runtime Error by Suresoft.
If you activate this ruleset, It may be possible for analyzing the project to take the time longer.]]></ruleSetDesc>
    <rule>SC_Use_Valid_Format_String</rule>
    <ruleTitle><![CDATA[유효한 포맷 문자열 사용 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 알 수 없거나 유효하지 않은 변환 명세(conversion specification) 혹은 플래그 문자, 정밀도, 길이 수정자, 변환 명세자의 잘못된 조합을 I/O 함수에서 사용해서는 안 된다. 마찬가지로 포맷 문자열에 사용된 변환 명세자의 인수 타입과 일치하지 않는 인수를 I/O 함수에게 전달하면 안 된다.
<br><br>
포맷화된 문자열을 출력하는 함수들 (fprintf() 혹은 연관되어 있는 함수들)은 포맷 문자열 인수를 변환 및 출력한다. C표준은 “포맷은 초기 시프트 상태에서 시작하고 끝나는 멀티바이트 문자 시퀀스이다. 포맷은 0개 이상의 지시문으로 구성된다. 일반 멀티 바이트 문자(% 제외)는 변경되지 않고 출력 스트림에 복사되며, 변환되는 인수들은 0개 이상의 후속 인수를 가지고 오고, 변환 명세자에 따라서 변환하여 결과를 출력 스트림에 작성한다.”고 명시하고 있다. 각 변환 명세(conversion specification)는 % 문자와 그 이후 아래의 속성들을 갖는다.
<br>
- 변환 명세(conversion specification)는 0개 혹은 그 이상의 플래그
- 최소 필드 너비(옵션)
- 특정 변환 명세자에 대해서 최소 자릿수를 표시(옵션)
- 인자(argument)의 크기를 지정하는 길이 수정자(옵션)
- 변환 타입을 적용하기 위해 변환 명세 문자
- 포맷 문자열을 만들 때, 잦은 실수는 다음과 같다.
- 포맷 문자열에 대해 잘못된 인수의 개수를 제공하는 경우
- 잘못된 변환 명세자를 사용하는 경우
- 변환 명세자와 호환되지 않는 플래그 문자를 사용하는 경우
- 변환 명세자와 호환되지 않는 길이 수정자를 사용하는 경우
- 인수 타입 및 변환 명세자가 불일치하는 경우

<table border="1" cellpadding="3" cellspacing="0">
        <tbody>
          <tr class="row0" align="center">
            <td style="background:#E2DFB7">Conversion Specifier Character</td>
            <td style="background:#E2DFB7">SPACE, +,  - </td>
            <td style="background:#E2DFB7">#</td>
            <td style="background:#E2DFB7">0</td>
            <td style="background:#E2DFB7">h</td>
            <td style="background:#E2DFB7">hh</td>
            <td style="background:#E2DFB7">l</td>
            <td style="background:#E2DFB7">ll</td>
            <td style="background:#E2DFB7">L</td>
            <td style="background:#E2DFB7">Argument Type</td>
          </tr>
          <tr class="row1" align="center">
            <td >d, i</td>
            <td >O</td>
            <td >X</td>
            <td >O</td>
            <td >short</td>
            <td >signed char</td>
            <td >long</td>
            <td >long long</td>
            <td >X</td>
            <td class="column9 style4 s">Signed integer</td>
          </tr>
          <tr class="row2" align="center">
            <td >o</td>
            <td >O</td>
            <td >O</td>
            <td >O</td>
            <td >unsigned short</td>
            <td >unsigned char</td>
            <td >unsigned long</td>
            <td >unsigned long long</td>
            <td >X</td>
            <td class="column9 style4 s">Unsigned integer</td>
          </tr>
          <tr class="row3" align="center">
            <td >u</td>
            <td >O</td>
            <td >X</td>
            <td >O</td>
            <td >unsigned short</td>
            <td >unsigned  char</td>
            <td >unsigned long</td>
            <td >unsigned long long</td>
            <td >X</td>
            <td class="column9 style4 s">Unsigned integer</td>
          </tr>
          <tr class="row4" align="center">
            <td >x, X</td>
            <td >O</td>
            <td >O</td>
            <td >O</td>
            <td >unsigned short</td>
            <td >unsigned char</td>
            <td >unsigned long</td>
            <td >unsigned long long</td>
            <td >X</td>
            <td class="column9 style4 s">Unsigned integer</td>
          </tr>
          <tr class="row5" align="center">
            <td >f, F</td>
            <td >O</td>
            <td >O</td>
            <td >O</td>
            <td >X</td>
            <td >X</td>
            <td class="column6 style5 s">N/E</td>
            <td class="column7 style5 s">N/E</td>
            <td >long double</td>
            <td >double or long doucle</td>
          </tr>
          <tr class="row6" align="center">
            <td >e, E</td>
            <td >O</td>
            <td >O</td>
            <td >O</td>
            <td >X</td>
            <td >X</td>
            <td class="column6 style5 s">N/E</td>
            <td class="column7 style5 s">N/E</td>
            <td >long double</td>
            <td >double or long double</td>
          </tr>
          <tr class="row7" align="center">
            <td >g, G</td>
            <td >O</td>
            <td >O</td>
            <td >O</td>
            <td >X</td>
            <td >X</td>
            <td class="column6 style5 s">N/E</td>
            <td class="column7 style5 s">N/E</td>
            <td >long double</td>
            <td >double, long double</td>
          </tr>
          <tr class="row8" align="center">
            <td >a, A</td>
            <td >O</td>
            <td >O</td>
            <td >O</td>
            <td >X</td>
            <td >X</td>
            <td class="column6 style5 s">N/E</td>
            <td class="column7 style5 s">N/E</td>
            <td >long double</td>
            <td >double or long double</td>
          </tr>
          <tr class="row9" align="center">
            <td >c</td>
            <td >O</td>
            <td >X</td>
            <td >X</td>
            <td >X</td>
            <td >X</td>
            <td >wint_t</td>
            <td >X</td>
            <td >X</td>
            <td >int or wint_t</td>
          </tr>
          <tr class="row10" align="center">
            <td >s</td>
            <td >O</td>
            <td >X</td>
            <td >X</td>
            <td >X</td>
            <td >X</td>
            <td class="column6 style4 s">NTWS</td>
            <td >X</td>
            <td >X</td>
            <td class="column9 style4 s">NTBS or NTWS</td>
          </tr>
          <tr class="row11" align="center">
            <td >p</td>
            <td >O</td>
            <td >X</td>
            <td >X</td>
            <td >X</td>
            <td >X</td>
            <td >X</td>
            <td >X</td>
            <td >X</td>
            <td >void*</td>
          </tr>
          <tr class="row12" align="center">
            <td >n</td>
            <td >O</td>
            <td >X</td>
            <td >X</td>
            <td >short*</td>
            <td >char*</td>
            <td >long*</td>
            <td >long long*</td>
            <td >X</td>
            <td class="column9 style4 s">Pointer to integer</td>
          </tr>
        </tbody>
    </table>
<br>
다음 표에서는 다양한 변환 지정의 규칙을 요약하고 있다. 첫 번째 컬럼은 하나 이상의 변환 명세자를 포함한다. 다음 네 개의 컬럼에서는 지정 기호 문자와 다양한 플래그(어퍼스트로피 [‘], -, +, 공백 문자, # 및 0)의 조합을 나타낸다. 다음 8개의 열은 다양한 길이 수정자(h, hh, l, ll, j, z, t, L)와 지정자 문자의 조합을 고려한다. 유효한 조합은 타입 이름으로 표시된다. 변환 명세와 일치하는 인수는 해당 타입으로 해석된다. 마지막 컬럼에는 원래 지정 문자와 일치하는 예상 인수 타입을 나타낸다. 표에 표시되지 않는 사양을 사용하거나 예기치 않은 타입의 인수를 사용하는 것은 정의되지 않은 동작을 야기할 수 있다.
위의 표에서 공백은 “ “ 문자, N/E는 효과 없음, NTBS는 널 문자로 끝나는 문자열을 가리키는 char* 인수, NTWS는 널 문자로 끝나는 wide 문자열을 가리키는 wchar_t* 인수를 의미한다. 형식화된 입력 함수(fscanf() 및 관련 함수)도 마찬가지로 지정된 포맷 문자열을 사용하여 포맷 문자열 및 인수에 유사한 제한을 적용한다. 알 수 없거나 유효하지 않은 변환 명세 혹은 플래그 문자, 정밀도, 길이 수정자, 변환 명세자의 잘못된 조합을 I/O 함수에서 사용하면 안 된다. 마찬가지로 포맷 문자열에 사용된 변환 명세자의 인수 타입과 일치하지 않는 인수들을 I/O 함수에 전달하면 안 된다.
]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>RTE_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_All_Exit_Handler_Return_Normally</rule>
    <ruleTitle><![CDATA[모든 종료 처리기는 반드시 정상적으로 반환 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 모든 종료 처리기는 반드시 정상적으로 반환되어야 한다. 종료 함수의 중첩 호출 혹은 종료 처리기에서 longjmp 함수의 호출은 정의되지 않은 동작을 야기할 수 있다.<br><br>

C표준에서는 _Exit(), exit() 및 quick_exit()와 같이 응용 프로그램을 정상적으로 종료시키는 세 가지 함수를 제공하고 있다. 이러한 함수들은 종료 함수라고 일컫는다. exit() 함수가 호출되면 atexit()에 등록된 함수를 자동으로 호출한다. 또한, quick_exit() 함수가 호출되면 at_quick_exit()에 등록되어 있는 함수가 호출된다. 이러한 기능들을 종료 처리기라고 일컫는다. 반면에 _Exit() 함수를 호출할 때는 어떠한 종료 처리기나 신호 처리기도 호출되지 않는다.
종료 처리기는 반드시 반환되어 종료되어야 한다. 모든 종료 처리기가 반환되어 정리 작업을 수행할 수 있도록 하는 것이 매우 중요하다. 특히 프로그래머가 라이브러리를 사용할 때, 라이브러리 내에 설치되어 있을 수도 있는 종료 처리기에 대해 알지 못할 때 위험할 수 있다. exit 함수에 대해 중첩으로 호출을 하거나 longjmp 호출로 종료 처리기 호출을 중간에 종료하는 문제가 발생할 수 있다.
종료 함수를 중첩 호출하는 것은 정의되지 않은 동작을 야기한다. 이 동작은 종료 처리기 내에서 exit 함수가 호출되거나 exit 함수가 신호 처리기 내에서 호출될 때 발생한다. atexit()에 등록된 종료 처리기 함수에서 longjmp 함수를 호출하여 처리기 함수를 종료하게 되면, 마찬가지로 정의되지 않은 동작을 야기하게 된다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Allocate_Sufficient_Memory_Size</rule>
    <ruleTitle><![CDATA[객체에 충분한 메모리 할당 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 메모리를 할당할 때는 객체의 크기를 포함할 수 있는 충분한 범위를 충족해야 한다.
<br><br>

malloc(), calloc(), realloc() 혹은 aligned_alloc() 함수에 인수로 전달되는 크기 인수는 반드시 저장될 객체의 크기를 포함할 수 있는 충분한 범위를 충족해야 한다. 만약 크기 인수가 옳지 않거나 공격자에 의해 조작될 수 있다면, 버퍼 오버플로우가 발생할 수 있다. 옳지 않은 크기 인수, 적절하지 않은 범위 검사, 정수 오버플로우, 혹은 객체 잘림은 적절하지 않은 사이즈의 버퍼를 할당하는 결과로 이어질 수 있다. 전형적으로 할당되는 메모리의 양은 할당되려는 객체 타입의 사이즈와 일치한다. 배열의 공간을 할당할 때는 배열 객체의 크기는 배열의 요소의 개수가 곱해져서 계산된다. 또한 가변 배열 멤버를 포함하는 구조체의 공간을 할당할 때는, 가변 배열 멤버는 배열 멤버 크기에 포함되지 않기 때문에 배열 멤버의 크기가 반드시 구조체에 추가되어야 한다. 따라서 할당할 메모리 크기를 계산할 때는 올바른 유형의 객체를 사용해야 한다.
]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Access_Incompatible_Ptr_Type</rule>
    <ruleTitle><![CDATA[호환되지 않는 타입의 포인터를 통한 변수 접근 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약: 호환되지 않는 타입의 포인터를 통해 변수의 값을 참조하거나 수정하는 것은 예측할 수 없는 결과를 야기할 수 있다. 개발자는 C표준에서 제시하는 규칙을 따라서 변수의 값을 수정하거나 참조해야 한다.
<br><br>
- 호환되지 않는 타입의 포인터를 통해 변수의 값을 수정하는 것은 예측할 수 없는 결과를 야기할 수 있다. (단, unsigned char는 제외) 이러한 문제는 객체에 다른 별명(해당 객체를 가리키는 또 다른 포인터)을 붙일 때 규칙을 위반함으로써 발생한다. C표준은 이러한 규칙들에 대해서 다음과 같이 명시한다. 객체의 값을 또 다른 포인터가 가리킬 때는 아래와 같은 타입을 따르는 lvalue 표현식에 의해서만 접근이 가능해야 한다.


]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Format</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Add_Subtract_Non_Arr_Obj_Ptr</rule>
    <ruleTitle><![CDATA[비배열 객체 포인터에 정수 덧셈 혹은 뺄셈 연산 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 배열의 원소를 참조하는 포인터에 대해서만 정수의 산술 연산을 수행해야 한다. 배열이 아닌 객체에 대한 포인터에 정수를 더하거나 빼면 유효하지 않은 포인터를 얻게 된다.<br><br>

C표준에서는 포인터 산술 연산에 대하여 포인터에 정수를 더하거나 빼는 표현식의 결과 값은 피연산자의 포인터 타입을 갖는다고 정의하고 있다. 이 때 만약 포인터 피연산자가 배열 객체의 원소를 참조하고 배열이 충분히 크다면, 결과로 반환되는 포인터는 원래 참조하고 있던 원소로부터의 (원소 단위) 오프셋을 반환한다. 그 결과 원래의 배열 원소와 반환된 포인터가 가리키는 원소의 위치 차이는 표현식에서 사용되었던 정수와 같다. 그러나 만약 배열의 원소가 아닌 구조체 내의 필드(멤버) 등에 대해 정수를 더하거나 빼는 연산을 진행한다면 그 필드 등이 메모리에 연속적으로 정렬되어 있다고 보장할 수 없기 때문에 유효하지 않은 포인터를 얻게 되어 취약점이 발생하게 된다. 따라서 배열의 원소를 참조하는 포인터에 대해서만 정수의 산술 연산을 수행해야 하며 산술 연산의 결과는 해당 정수만큼 오프셋이 차이가 나는 위치의 포인터가 된다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Assign_In_Specific_Operation</rule>
    <ruleTitle><![CDATA[특정 연산자에서 할당 연산 수행 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약: 특정 연산자를 사용할 때 할당을 수행하는 피연산자를 전달하면 안된다.
<br><br>
아래와 같은 연산자를 사용할 때 피연산자로써 할당을 수행하면 안된다.
<br>
<table align="center" border="1" cellpadding="6">
<tr align="center" >
<td rowspan="2"><b>Statement</b></td><td rowspan="2"><b>Expression</b></td>
</tr>

<tr align="center">
</tr>

<tr align="center">
<td>if </td><td>조건식</td>
</tr>

<tr align="center">
<td>while </td><td>조건식</td>
</tr>

<tr align="center">
<td>do ... while </td><td>조건식</td>
</tr>

<tr align="center">
<td>for </td><td>2번째 피연산자</td>
</tr>

<tr align="center">
<td>?: </td><td>피연산자 전체</td>
</tr>

<tr align="center">
<td>&& </td><td>피연산자 전체</td>
</tr>

<tr align="center">
<td>|| </td><td>피연산자 전체</td>
</tr>

<tr align="center">
<td>, </td><td>2번째 피연산자</td>
</tr>

</table>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Bitwise_Operator_In_Bool_Type</rule>
    <ruleTitle><![CDATA[Boolean 피연산자에 bitwise 연산자 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 비트 연산자와 관계 연산자를 함께 사용할 때는 항상 주의해야 한다.<br><br>

비트 연산자(bitwise operator)와 관계 연산자(relational operator)를 표현식에서 함께 사용하는 것은 문제가 될 수 있다. AND, OR 혹은 XOR 연산자를 _Bool 타입의 피연산자 혹은 관계연산자와 함께 사용하면 안 된다. 만약 비트 연산자를 함께 사용하고 싶다면 괄호를 이용하여 올바르게 사용하여야 한다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Call_System_Function</rule>
    <ruleTitle><![CDATA[system() 함수 호출 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : C표준의 system() 혹은 이와 유사한 함수(명령어 주입 공격에 대한 취약점을 가졌다고 알려진 명령어 수행 함수)를 통해 명령 프로세서를 호출하여 명령을 실행하면 안 된다.<br><br>

C표준에서 system() 함수는 윈도우 운영체제에서의 CMD.EXE 혹은 UNIX 운영체제에서의 SHELL 같은 명령 프로세서를 호출하여 지정된 명령을 실행한다. POSIX의 popen()과 윈도우에서의 _popen() 함수는 명령 프로세서를 호출하면서 호출 프로그램과 실행된 명령 사이에 파이프를 작성하여 파이프를 읽거나 쓰는데 사용할 수 있는 스트림에 대한 포인터를 반환한다.<br><br>

system() 함수를 사용하면 최악의 경우에는 임의의 시스템 명령을 실행할 수 있는 취약점이 발생할 수 있다. system() 함수 호출의 위험이 높은 상황은 다음과 같다.<br>
1. 옳지 않은 출처에서 생성된 부적절한 명령 문자열을 검사없이 전달할 때<br>
2. 명령이 경로 이름 없이 지정되고 명령 프로세스 경로 이름이 공격자로부터 접근이 가능한 경우<br>
3. 실행 파일에 대한 상대 경로가 지정되어 있고 공격자가 현재 작업 디렉터리에 대한 제어권을 접근할 수 있는 경우<br>
4. 지정된 실행 프로그램이 공격자에 의해 스푸핑 될 수 있는 경우<br>
위와 같은 이유로 system() 함수 혹은 유사한 함수(명령어 주입 공격에 대한 취약점을 가졌다고 알려진 명령어 수행 함수)를 통해 명령 프로세서를 호출하면 안 된다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Calling_Realloc</rule>
    <ruleTitle><![CDATA[realloc() 함수를 호출하여 객체의 정렬 수정 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 엄격한 정렬 요구사항을 갖고 할당된 메모리 주소는 realloc() 함수를 통해 기본 정렬 요구사항을 갖는 메모리로 재할당하면 안 된다.<br><br>

malloc() 함수에 의해 할당된 공간보다 더 엄격한 정렬 요구사항을 갖고 할당된 객체의 크기에 대해서 realloc() 함수를 이용하여 수정하면 안 된다. 예를 들어, 표준 aligned_alloc() 함수에 의해 호출되어 할당된 공간은 일반적인 정렬 요구사항보다 더 엄격한 정렬 요구사항을 갖는다. C표준은 realloc() 이 반환한 포인터가 기본 정렬 요구사항을 가진 모든 유형의 객체에 대한 포인터에 할당될 수 있도록 적절하게 정렬되어야 한다고 요구한다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Calling_Va_Arg_In_Specific_Case</rule>
    <ruleTitle><![CDATA[정해지지 않은 값을 가진 va_list에 va_arg() 호출 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약: va_list 객체를 함수의 인자로 전달할 때, 호출된 함수에서 va_list 객체에 접근하면 호출자 함수가 가진 va_list의 값이 정해지지 않아 예상치 못한 동작을 발생할 수 있다.
<br><br>
가변 인자 함수는 va_start() 함수를 사용하여 va_list 객체를 초기화한 후에 va_arg()를 통해 값에 접근한다. va_list 객체는 다른 함수로 전달할 수는 있지만, 전달받은 함수에서 va_list는 정의되지 않은 값을 갖게 된다. 결과적으로 va_list를 초기화하지 않고 변수를 읽는 것은 정의되지 않은 동작을 야기한다.]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Cast_to_Strictly_Aligned_Ptr</rule>
    <ruleTitle><![CDATA[포인터를 더 엄격하게 정렬되는 포인터 타입으로 캐스팅 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 더 엄격하게 정렬되는 타입으로 포인터를 캐스팅하면 안 된다. 변환된 포인터가 옳지 않게 메모리에 정렬되어 있을때, 그 포인터를 역참조하면 정의되지 않은 동작을 야기할 수 있기 때문이다.<br><br>

포인터를 더 엄격하게 정렬되는 포인터 타입으로 캐스팅하면 안 된다. 객체의 타입이 다르면 객체가 메모리에 정렬되는 방법도 다르다. 포인터가 강제 캐스팅되거나 void 형 포인터로 변환되는 경우, 객체의 메모리 정렬은 바뀔 수 있다. C표준에서는 “변환된 포인터가 옳지 않게 메모리에 정렬되어 있다면, 그 포인터를 역참조하면 정의되지 않은 동작을 야기한다”라고 명시하고 있다. 또한 C표준에서 char *와 void *타입의 포인터가 가장 엄격하지 않은 포인터라고 규정한다. 예를 들어, char *포인터가 int *형태의 포인터로 강제 캐스팅된다면, 더 엄격하게 정렬되는 포인터 타입으로 캐스팅되기 때문에 정보의 손실이나 역참조로 인한 오류를 야기할 수 있다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Compare_Two_Ptr_Not_Same_Arr</rule>
    <ruleTitle><![CDATA[같은 배열을 참조하지 않는 두 개의 포인터 뺄셈 혹은 비교 연산 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 동일한 배열을 참조하지 않는 포인터끼리 뺄셈을 수행하거나 비교 연산을 진행해서는 안된다. 이 경우 에러를 유발할 수 있다.<br><br>

두 개의 포인터로 뺄셈을 수행하기 위해서는 두 포인터가 같은 배열을 참조하고 있거나 적어도 메모리 영역 상 배열의 마지막 요소의 다음 부분을 가리키고 있어야 한다. 이때 결과 값은 배열에서의 두 원소 간 거리가 된다. 즉, 포인터 뺄셈은 두 포인터 간의 바이트 수가 아닌 객체의 수를 나타낸다. 또한 포인터를 서로 비교할 경우 포인터 간의 상대적인 위치 차이를 알 수 있다. 단, 동일한 배열을 참조하지 않는 포인터끼리 뺄셈을 수행하거나 비교하면 에러를 유발할 수 있다. 따라서 동일한 배열과 같이 일련 된 메모리 영역을 참조하는 경우에만 포인터끼리 뺄셈이나 비교 연산을 수행해야 한다. 구조체 struct 객체 내에서 두 멤버 포인터를 빼거나 비교하는 것은 가능하다. 그러나 이 때에는 구조체 내 멤버의 정렬(alignment)이나 패딩(padding)에 대해 고려해야 한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Concat_UCS</rule>
    <ruleTitle><![CDATA[문자열 결합을 통한 국제문자세트(UCS)의 문자 이름 생성 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약: 토큰을 결합(concatenation)하여 국제 문자 세트(UCS, Universal Character Set, 범용 문자 집합)의 문자 이름을 만들면 정의되지 않은 동작을 야기한다.<br><br>

C표준에서는 국제 문자 세트(UCS, Universal Character Set, 범용 문자 집합)의 문자 이름을 이용하여 식별자, 문자 상수, 문자열들을 정의할 수 있도록 허용한다. 국제 문자 세트는 전 세계의 문자를 모두 표현하기 위해 만들어진 범용 문자 집합으로 \uNNNN(16비트) 혹은 \uNNNNNNNN(32비트)로 표현한다. (여기서 N은 16진수로 표현되는 값) <br>
C표준에서는 “만약 토큰을 결합(concatenation token)하여 국제 문자 세트의 문자 이름을 만든다면, 정의되지 않은 동작을 야기한다.”라고 명시하고 있다. 따라서, 식별자 정의 시 국제 문자 세트의 문자 이름을 사용하지 말아야 한다.]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Naming</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Declare_Define_Reserved_ID</rule>
    <ruleTitle><![CDATA[예약된 식별자 선언 및 정의 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약: C표준에서 예약되어 있는 식별자를 재정의하면 안 된다.<br><br>

C표준에서는 밑줄과 대문자로 시작하거나 혹은 밑줄 2개로 시작하는 모든 식별자는 예약되어 있는 식별자다. 밑줄로 시작하는 모든 식별자는 파일 스코프 범위(파일 스코프란, 모든 항목들은 하나의 파일 내에서만 접근 가능한 범위를 의미, static 변수가 해당)를 갖는 식별자로 예약되어 있다. 코드에서 포함하는 헤더 파일에 존재하는 매크로 이름은 예약되어 있는 식별자다. 또한, 외부 링크에 연결되어 있는 모든 식별자와 errno 키워드는 예약되어 있는 식별자다. 위와 같이 예약되어 있는 식별자를 재정의하면 안 된다.]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Declare_Incompatible_Obj</rule>
    <ruleTitle><![CDATA[호환되지 않는 함수 혹은 객체 선언 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약: 같은 함수 혹은 변수에 대하여 두 개 혹은 그 이상의 호환되지 않는 선언은 옳지 않은 결과를 야기한다.
<br><br>
C표준은 다음과 같이 함수 혹은 객체에 대해 호환되지 않는 선언으로 인해 옳지 않은 결과를 야기할 수 있는 네 가지 상황을 제시하고 있다.<br>
1. 호환되지 않는 객체 혹은 함수가 같은 이름으로 두 개가 선언되는 경우<br>
2. 무시될 수 있는 문자로 인해 호환되지 않는 식별자가 선언되는 경우<br>
3. 호환되지 않는 객체 식별자에 접근하는 경우<br>
4. 호환되지 않는 함수 식별자에 접근하는 경우<br>
<br><br>
동일한 프로그램에 단순히 나타나는 두 개의 호환되지 않는 선언은 대부분의 구현 환경에서 문제가 없는 것처럼 보일 수도 있지만, 함수의 정의와 호환되지 않는 함수를 호출하는 것은 매우 불안전하다. 마찬가지로, 호환되지 않는 객체에 접근하는 것은 의도하지 않은 정보 노출이나 메모리 덮어쓰기로 이어질 수 있다.]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Declare_Same_Var</rule>
    <ruleTitle><![CDATA[내외부 연결에 동일한 변수 동시 선언 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약: 한 번역 단위(translation unit) 내에서 식별자를 내부적 그리고 외부적으로 동시에 연결하여 사용하는것은 정의되지 않은 동작을 야기한다.<br><br>

연결이란 다른 범위에 속하는 변수들을 서로 연결하는 것을 의미한다. C에서는 외부 연결(External linkage), 내부 연결(Internal linkage), 무 연결(No linkage) 세 개의 연결 종류가 있다. 외부 연결이란, 일반적으로 하나의 프로그램은 여러 개의 소스파일로 이루어지는데 이 경우에 외부 연결은 특정 소스 파일에 선언된 변수들이 다른 소스 파일에서도 사용이 가능한 것을 의미한다. 예를 들어, 특정 파일에서 전역변수를 선언하고, 다른 소스 파일에서 extern 지정자를 사용하여 해당 전역 변수를 연결할 수 있게 한다. 내부 연결이란, 소스 파일에 선언된 이름들이 그 파일 내에서만 사용할 수 있음을 의미한다. 이들은 외부 파일들에 연결되지 않는다. 전역 변수에 static 이 선언되면 내부연결이 된다. 즉, 하나의 소스 파일 내에서만 사용이 가능하다. 전역 변수에 static 이 선언되지 않으면 내부 연결은 외부 연결로 바뀌게 된다. 무 연결이란, 지역변수가 가지는 특성으로 다른 블록과 연결을 갖지 않는 것을 의미한다. 이때, 한 번역 단위 내에서 식별자를 내부적 그리고 외부적으로 동시에 연결하여 사용하는 것은 정의되지 않은 동작을 야기한다. 이때, 번역 단위는 헤더 파일과 #include를 이용하여 포함하고 있는 모든 소스 파일을 포함한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Hard Coding</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Declare_Var_Before_First_Case</rule>
    <ruleTitle><![CDATA[switch 문 내에서 첫 번째 case 구문이 시작하기 전 변수 선언 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약: switch 문 내에 존속기간을 가지고 있는 변수는 초기화되지 않으므로 정의되지 않은 값을 가지게 된다.<br><br>

switch 문에서 사용하기 위한 변수는 첫 번째 case 구문에 진입하기 전에 초기화 되어야 한다. 또한, switch 문 내의 존속기간을 가지고 있는 변수는 초기화되지 않기 때문에 정의되지 않은 값을 가지게 된다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Env_Ptr_After_Invalidate_Ptr</rule>
    <ruleTitle><![CDATA[환경변수 포인터를 무효화 시키는 연산이 포함된 함수가 호출된 후 환경변수 포인터 참조 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : setenv() 혹은 _putenv_s() 함수를 이용하여 환경변수를 수정한 후, main 함수에 전달되는 세 번째 인수(envp)로 환경변수에 접근하면 안 된다.<br><br>

일부 C 구현 환경에서는 main() 함수가 envp라는 세 번째 인수인 환경 포인터를 제공한다. 이 환경 포인터는 main() 함수가 호출되는 시점에서는 유효한 값을 가지고 있다. 하지만 이 후 환경변수를 수정하게 되는 연산을 하고나면 유효하지 않은 값을 가질 수 있다. C표준에서는 다음과 같이 명시한다. “main() 함수는 null 문자로 끝나는 char 포인터 배열을 세 번째 인수(char *envp[])로 받는다. 이 인수는 각 실행을 위한 환경변수에 대한 정보를 제공하는 문자열을 가리킨다.” 따라서 main()의 수정된 형식을 통해 환경변수에 접근할 수 있다.<br>
<pre>
main(int argc, char *argv[], char *envp[]){ /* ... */ }

하지만 환경변수를 수정하면 환경변수 메모리가 다시 할당되어 envp가 잘못된 위치를 참조하게 된다.

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
extern char **environ;
int main(int argc, const char *argv[], const char *envp[]) {
   printf("environ: %p\n", environ);
   printf("envp: %p\n", envp);
   setenv("MY_NEW_VAR", "new_value", 1);
   puts("--Added MY_NEW_VAR--");
   printf("environ: %p\n", environ);
   printf("envp: %p\n", envp);
   return 0;
}

예를 들어, 위의 코드를 GCC 4.8.1로 컴파일하고 32비트 Intel GNU/Linux 시스템에서 실행한 결과는 아래와 같다.

% ./envp-environ
environ: 0xbf8656ec
envp: 0xbf8656ec
--Added MY_NEW_VAR—
environ: 0x804a008
envp: 0xbf8656ec

이러한 결과로부터 setenv() 함수를 호출한 결과로 환경변수가 메모리상에서 재배치되었음을 알 수 있다. 외부 변수 environ은 현재 환경을 참조하도록 업데이트 되지만, envp 매개변수는 업데이트 되지 않는다. *envp 환경변수 포인터는 getenv()의 호출에 의해서 무효가 될 수도 있다.</pre>]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Float_Type_Var_as_Loop_Counter</rule>
    <ruleTitle><![CDATA[부동 소수점 변수를 반복문의 카운터로 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 코드의 이식성을 보장하고 유지하려면 부동 소수점 변수를 반복문의 카운터 변수로 사용하면 안 된다.<br><br>

대부분의 프로그래머들은 부동 소수점 숫자는 실수를 나타내기 때문에 정확하게 소수점을 나타낼 수 있다고 가정한다. 하지만 부동 소수점 숫자는 정수와 마찬가지로 표현 상의 제약을 받으며 2진 부동 소수점 숫자는 모든 실수를 정확하게 표현할 수 없다. 또한 프로그래머들은 부동 소수점 숫자는 큰 값을 나타낼 수 있기 때문에 해당 값의 모든 유효 자리 수를 나타낼 수 있다고 생각하지만 부동 소수점 숫자는 고정된 소수점 수(precision bit, 혹은 유효숫자) 및 지수로 표현할 수 있는 유효 자릿수를 제한한다. 따라서 코드의 이식성을 보장하고 유지하려면 부동 소수점 변수를 반복문의 카운터 변수로 사용하면 안된다. 반복문의 카운터는 보통 do, while 혹은 for 반복문의 제어 표현식으로 사용되는 피연산자를 나타낸다. 카운터 변수는 반복문이 진행될 때마다 고정된 양만큼 증가 또는 감소하는 변수를 나타낸다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Getlogin_In_Multithread</rule>
    <ruleTitle><![CDATA[멀티스레드 어플리케이션에서 getloin 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약: 멀티스레드 컨텍스트에서 gtinloin() 함수를 사용하여 잠재적으로 잘못된 값을 리턴하게 된다.<br><br>

사용자 계정은 멀티스레드 환경에서 잠금 장치를 하지 않고 얻을 수 있다. 이러한 경우 다른 스레드가 사용 중인 사용자 계정을 읽어올 수 있다. getloin() 함수는 호출된 스레드와 연관된 사용자 이름을 리턴하는 함수이다. 이를 다중 스레드 환경에서 사용하면 리턴 받은 사용자 이름값이 다른 스레드에 의해 변경될 수 있어 정확하지 않은 값을 얻을 수 있다. 이를 예방하기 위하여 getloin() 함수를 사용한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Information_Leakage_For_Struct</rule>
    <ruleTitle><![CDATA[신뢰 경계를 통한 구조체 데이터 전달 시 정보 누수 회피 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 다른 도메인으로 구조체 포인터를 전달할 때, 구조체 내의 패딩 바이트가 민감한 정보를 포함하고 있지 않다는 것을 보장해야 한다.
<br><br>
C언어에서는 구조체를 메모리에 배치할 때, 구조체의 필드 사이 혹은 구조체의 끝에 패딩 바이트를 포함할 수도 있다. 게다가, 구조체 멤버를 초기화하는 것은 패딩 바이트의 초기화를 보장해주지는 않는다. C표준에서는, “구조체 객체에 값을 저장할 때, 패딩 바이트는 정의되지 않은 값을 포함한다”고 명시하고 있다. 신뢰 경계(trust boundary)란 프로그램 데이터나 실행이 자신의 신뢰 수준을 변경하는 범위를 말할 때 사용된다. 신뢰 경계를 통해 다른 도메인으로 구조체 포인터를 전달할 때, 개발자는 구조체 내의 패딩 바이트들이 민감한 정보를 포함하고 있지 않다는 것을 보장해야 한다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Invocation_Of_Func_Like_Macro</rule>
    <ruleTitle><![CDATA[함수형 매크로 호출 시 전처리 지시자 인수 전달 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 매크로로 구현된 함수를 호출할 때, 함수 인수에 전처리 지시자를 포함하면 안 된다.<br><br>

매크로 인수에는 #define, #ifdef, #include 와 같은 전처리 지시자가 포함되면 안 된다. C 표준에서는 “전처리 토큰 중 전처리 지시자로써 사용되는 게 있다면, 정의되지 않은 동작을 야기한다”고 명시한다. 이러한 규칙은 표준 라이브러리 함수인 memcpy(), printf(), assert() 와 같이 매크로를 사용하여 구현될 수 있는 함수들에도 적용된다.]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Modifing_Constant_Object</rule>
    <ruleTitle><![CDATA[상수 객체 수정 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 객체의 값을 non-const 자격의 타입으로 수정하려 한다면, 정의되지 않은 동작을 야기할 것이다.<br><br>

C표준에서는 “const 자격이 주어진 타입의 객체의 값을 non-const 자격의 타입으로 수정하려 한다면, 정의되지 않은 동작을 야기할 것이다.”라고 명시한다. const 객체를 수정할 때 경고 메시지를 띄우지 않는 컴파일러들이 존재하기 때문에 “강제 캐스팅하여 const 자격을 해제하지 마라.”라는 경고 메시지 없이 const 객체의 값을 임의로 수정이 가능하다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Multiple_Atomic_Var_Reference</rule>
    <ruleTitle><![CDATA[표현식에서 atomic 변수 두 번 이상 참조 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 한번의 atomic 연산은 스레드 안전성을 제공하지만, 그 이상의 atomic 연산은 스레드 안전성을 제공하지 않는다. 따라서 atomic 연산을 위해 atomic 변수를 두 번 이상 참조하면 안 된다.<br><br>

일반적으로 프로그램에서 잠금 정책이란, 여러 스레드가 공유 자원에 동시에 접근하거나 수정할 수 없음을 보장하는 것을 의미한다. Atomic 변수는 특정 작업이 수행될 때 스레드 안전성을 보장함으로써 잠금이 필요하지 않도록 한다. Atomic 변수의 스레드 상에서 안전한 연산은 C표준에 정의되어 있다. Atomic 연산이 여러 개가 조합되어 사용될 수 있지만, 연산이 조합될 때는 각 atomic 연산이 제공하는 스레드 안전성을 더 이상 제공하지 않게 된다. atomic 변수는 언제나 ‘*=’와 같은 복합 연산자를 포함하여 할당 연산자의 왼쪽에 위치한다. atomic 변수에 가산 연산자(++) 혹은 감산 연산자(--)를 사용하는 것은 atomic 읽기-쓰기 연산을 구성하는 것이며, 스레드 안전성을 제공한다. 표현식의 어느 곳에서나 atomic 참조 변수는 별개의 atomic 읽기 연산으로 판단한다. 만약 같은 atomic 변수가 표현식에서 두 번 사용되었다면, 두 개의 atomic 읽기 혹은 atomic 읽기와 쓰기 연산이 사용된 것이다. 위에서도 언급했듯이, 이러한 atomic 연산의 쌍(2번)은 스레드 안전성을 보장하지 않는다. 다른 스레드가 두 개의 연산 사이에 atomic 변수를 수정할 수 있기 때문이다. 결과적으로 atomic 변수는 같은 표현식에 두 번 참조되어서는 안 된다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Operand_Rely_On_Side_Effect</rule>
    <ruleTitle><![CDATA[sizeof, _Alignof, _Generic에 피연산자로 변수의 값을 바꾸는 표현식 전달 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약: sizeof, _Alignof, _Generic 연산자를 사용할 때는 변수의 값을 바꾸는 표현식을 전달하면 안 된다.
<br><br>
C언어에서 몇몇 연산자는 피연산자로써 변수의 값을 바꾸는 표현식을 전달하여도 변수의 값을 바꾸지 않는다. 이러한 연산자를 사용할 때는 변수의 값을 바꾸는 표현식을 전달하면 안 된다. sizeof 연산자는 피연산자의 크기(바이트)를 반환한다. sizeof는 피연산자에서 특정 변수의 값을 바꾸는 것은 무시한다. 하지만 피연산자의 타입이 가변 길이 배열 타입(variable length array type)일 경우는 예외이다. sizeof의 피연산자가 가변 길이 배열 타입의 크기로 전달되는 경우에는 표현식이 유효가 되어 값이 바뀔 수 있는데, 만약 피연산자의 표현식이 유효가 되었지만 이러한 표현식이 무의미하다면 사용하지 않는 것이 좋다. _Alignof도 전달되는 피연산자의 변수의 값을 바꾸지 않는다. _Alignof는 가변 길이 배열 타입인 경우에도 값을 바꾸지 않는다. _Generic의 피연산자도 마찬가지로 피연산자의 변수의 값을 바꾸지 않는다. 이렇게 피연산자로 전달되는 표현식의 변수의 값이 바뀌지 않음에도 불구하고 이러한 표현식을 sizeof, _Alignof, _Generic 연산자에 넘기는 것은 프로그래머에게 프로그램 상태를 올바르게 인지하지 못하도록 만들 수 있다.]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Dead Code</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_PRNG_Seed_Generator</rule>
    <ruleTitle><![CDATA[PRNG 방식으로 난수 생성 시 rand() 함수 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : C언어의 표준 난수 발생기 함수인 rand()는 통계적인 분포에 대한 보장이 없어서 예측이 용이한 경우가 많다. 보안 기능을 구현할 때는 강력한 랜덤 숫자가 필요하기 때문에 rand() 함수는 사용하지 않아야 한다.<br><br>

Pseudo Random Number Generator(PRNG) 결과의 통계적 분포는 True Random Number Generator(TRNG)와 비슷해야 예측의 난이도가 높아진다. 하지만 C언어 표준 난수 발생기인 rand() 함수는 출력에 대한 통계적 분포에 보장이 없어서 예측이 용이한 경우가 있다. 보안 기능 구현 시, 통계적 분포 보장이 가진 임의 숫자 필요하기 때문에 rand() 함수를 사용하지 말아야 한다. 가급적으로는 보안 강도가 높은 HW 난수 발생기 (TRNG) 사용을 권장한다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Padding_Data_Comparison</rule>
    <ruleTitle><![CDATA[패딩 데이터 비교 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약: 구조체 내에 패딩 비트가 정의되지 않은 값을 갖고 있는 상태에서 구조체 간 바이트 단위의 비교를 시도하면 잘못된 결과를 발생할 수 있다.
<br><br>
구조체 객체 내에 이름이 없는 패딩이 있을 수 있다. 패딩 비트는 구조체 시작 부분에는 들어 있지 않고 보통 구조체 혹은 유니온(union)의 끝 부분에 들어있다. 구조체와 유니온 객체 내에 이름이 없는 멤버들은 초기화에 참여하지 않는다. 그러므로 구조체에 이름이 없는 멤버는 초기화 후에도 정의되지 않은 값을 갖게 된다. 패딩 비트가 0으로 초기화되는 경우는 정적 혹은 스레드 존속 범위의 객체가 묵시적으로 초기화되었을 때다. C++ 표준에서는 아래와 같이 언급하고 있다: 만약 지역 변수 객체가 명시적으로 초기화되어 있지 않다면 그 값은 정해져 있지 않은 값이다. 만약 정적 혹은 스레드 존속 범위의 객체가 명시적으로 초기화되어 있지 않다면,
1. 객체가 aggregate 타입이라면, 모든 멤버의 패딩은 0 비트로 초기화된다.
2. 객체가 union 타입이라면, 첫 번째로 명명된 멤버의 모든 패딩은 0으로 초기화된다.
구조체 내에 패딩 비트가 정의되지 않은 값을 갖고 있는 상태에서 구조체 간 바이트 단위의 비교를 시도하면 잘못된 결과를 발생할 수 있다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Race_Condition_Using_Lib_Func</rule>
    <ruleTitle><![CDATA[라이브러리 함수를 사용할 때 경쟁 상태 방지 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 데이터 경쟁이 발생할 수 있는 라이브러리를 고려하여 경쟁 상태(race condition)를 피해야 한다.<br><br>

일부 C표준 라이브러리 함수는 스레드에 대해 경쟁상태를 항상 피할 수 있다는 것을 보장하지 않는다. strtok() 및 asctime()과 같은 함수는 함수 할당 메모리에 저장된 결과에 대한 포인터를 각 프로세스 별로 반환한다. rand()와 같은 다른 함수는 상태 기반 정보를 프로세스 단위로 함수 할당 메모리에 저장한다. 이러한 함수를 동일하게 호출하는 여러 스레드는 동시성 문제를 야기할 수 있다. 이로 인해 비정상적인 동작이 발생하고 비정상 종료, 서비스 거부 공격(denial of service attack) 및 데이터 무결성 위반과 같은 더 심각한 취약성이 발생할 수 있다. C표준에 따르면 다음 표에 나열된 라이브러리 함수는 여러 스레드에서 호출될 때 데이터 경쟁이 발생할 수 있다.
<br>
<table align="center" border="1" class="wrapped confluenceTable tablesorter tablesorter-default">
<tbody>
<tr>
<td><b>함수</b></td><td><b>해결 방안</b></td>
</tr>
<tr>
<td class="confluenceTd" colspan="1"><code>asctime()</code>,&nbsp;<code>ctime()</code>,<br /><code>localtime()</code>,&nbsp;<code>gmtime()</code></td>
<td class="confluenceTd" colspan="1">C11의 asctime_s(), ctime_s(), localtime_s(), gmtime_s() 사용</td>
</tr>
<tr>
<td class="confluenceTd" colspan="1"><code>ATOMIC_VAR_INIT</code>,&nbsp;<code>atomic_init()</code></td>
<td class="confluenceTd" colspan="1">멀티스레드에서 atomic 변수를 초기화하지 말아야 한다</td>
</tr>
<tr>
<td class="confluenceTd"><code>getenv()</code>,&nbsp;<code>getenv_s()</code></td>
<td class="confluenceTd">일부 함수들로부터 반환된 포인터를 저장하지 않는다. [CERT-C ENV34-C]</td>
</tr>
<tr>
<td class="confluenceTd" colspan="1"><code>mbrtoc16()</code>,&nbsp;<code>c16rtomb()</code>,<br /><code>mbrtoc32()</code>,&nbsp;<code>c32rtomb()</code></td>
<td class="confluenceTd" colspan="1">null 값의 mbstate_t * 인자를 사용하여 함수를 호출하지 않는다.</td>
</tr>
<tr>
<td class="confluenceTd"><code>rand()</code>,&nbsp;<code>srand()</code></td>
<td class="confluenceTd">유사 난수를 생성하는 rand()함수를 사용하지 않는다. [C-MSC-003]</td>
</tr>
<tr>
<td class="confluenceTd" colspan="1"><code>setlocale()</code></td>
<td class="confluenceTd" colspan="1">뮤텍스를 사용하여 보호</td>
</tr>
<tr>
<td class="confluenceTd" colspan="1"><code>strerror()</code></td>
<td class="confluenceTd" colspan="1">C11의 strerror_s() 사용 POSIX의 strerror_r() 사용</td>
</tr>
<tr>
<td class="confluenceTd"><code>strtok()</code></td>
<td class="confluenceTd">C11의 strtok_s() 사용 POSIX의 strtok_r() 사용</td>
</tr>
<tr>
<td class="confluenceTd" colspan="1"><code>tmpnam()</code></td>
<td class="confluenceTd" colspan="1">C11의 tmpnam_s() 사용 POSIX의 tmpnam_r() 사용</td>
</tr>
</tbody>
</table>]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Rejoin_Detached_Thread</rule>
    <ruleTitle><![CDATA[이전에 결합 또는 분리된 스레드를 재결합이나 분리 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약: 이미 결합되거나 분리된 스레드를 다시 결합하거나 분리하면 안 된다.
<br><br>
C표준은 “이미 결합되거나 분리된 스레드를 다시 결합하면 안 된다. 마찬가지로, 이미 결합되거나 분리된 스레드를 다시 분리하면 안 된다. 둘 중 하나라도 위배될 때에는 정의되지 않은 동작을 야기한다” 라고 명시한다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Ret_Compute_Except_Sig_Handler</rule>
    <ruleTitle><![CDATA[연산 예외 신호 처리기에서 반환 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약: SIGFPE, SIGILL, SIGSEGV 및 SIGBUS(POSIX)와 같은 연산 예외 신호에 등록되어 있는 신호 처리기로부터 제어가 반환되면 안 된다.
<br><br>
C표준에 따르면, “연산 예외 사항(SIGFPE, SIGILL, SIGSEGV와 같은 신호)으로 신호 처리기에 진입했을 때 신호 처리기에서 제어가 반환된다면, 정의되지 않은 동작을 야기한다.”라고 명시한다. 운영체제 인터페이스(POSIX)는 SIGBUS를 연산 예외 신호 처리기로 간주한다. kill(), sigqueue(), raise()에 의해 생성되지 않은 SIGBUS, SIGFPE, SIGILL, SIGSEGV 신호의 신호 포착(signal-catching) 함수에서 정상적으로 반환되는 경우에 정의되지 않은 동작을 야기한다. 신호가 어떻게 생성되던 관계없이 SIGFPE, SIGILL, SIGSEGV, SIGBUS(POSIX) 혹은 연산 예외에 해당하는 신호에 등록되어 있는 신호 처리기로부터 반환하여 제어권이 다시 돌아오면 안 된다.]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Side_Effect_In_Parameters</rule>
    <ruleTitle><![CDATA[변수의 값을 변경하는 문자열 인수를 getc(), putc(), getwc() 혹은 putwc()에 호출 금지 ]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 변수의 값을 변경하는 부수효과를 가진 표현식 인수를 getc(), putc() 또는 wide 문자와 관련된 함수 getwc() 및 putwc()를 호출하면 안 된다.<br><br>

getc(), putc(), getwc(), putwc() 함수들은 안전하지 않은 매크로로 구현되어 있을 수 있기 때문에, 변수의 값을 변경하는 표현식 인수가 매크로 내에서 여러 번 동작하여 프로그래머가 의도하지 않은 결과를 나타낼 수 있다. 단, 스트림이 아닌 문자를 인수로 전달하는 경우에는 putc() 및 putwc() 함수는 한 번만 실행한다는 것을 보장하기 때문에 이 규칙은 해당되지 않는다.]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Signal_Function_In_Multithread</rule>
    <ruleTitle><![CDATA[멀티스레드 프로그램에서 signal() 함수 호출 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약: 멀티스레드 프로그램에서 signal() 함수를 사용하면 안 된다.
<br><br>
멀티스레드 프로그램에서 signal() 함수를 호출하는 것은 정의되지 않은 동작을 야기한다.
<br><br>
예외 상황
<br>
멀티쓰레드 환경에서 정의된 행동을 제공하는 POSIX(예. sigaction 함수) signal 함수를 사용하는 경우 해당 규칙 위배 대상에서 제외한다.
]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Store_Returned_Object</rule>
    <ruleTitle><![CDATA[특정 함수의 반환값이 참조하는 객체 수정 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : C에서 getenv(), setlocale(), localeconv(), asctime(), strerr()함수들은 수정할 수 없는 객체의 포인터를 반환한다. 따라서 임의로 수정하면 정의되지 않는 동작이 발생할 수 있으니 const 자격을 갖는 것처럼 사용해야 한다.<br><br>

C언어에서는 수정할 수 없는 객체의 포인터를 반환하는 getenv(), setlocale(), localeconv(), asctime(), strerr()와 같은 특정 함수들이 존재한다. 이 경우, 함수 호출 결과는 const 자격을 갖는 것처럼 사용해야 한다. C표준은 “getenv() 함수가 반환하는 문자열 포인터는 프로그램 내에서 수정해서는 안 되며 getenv() 함수를 다시 호출하여 문자열을 덮어 쓸 수는 있다. getenv() 함수가 지정한 이름을 찾을 수 없는 경우에는 null 포인터가 반환된다.”와 같이 명시하고 있다.<br><br>

- getenv()로 반환된 문자열을 변경해야 하는 경우 로컬 복사본을 만들어야 한다. getenv()에 의해 반환된 문자열을 변경하면 정의되지 않은 동작이 발생한다.<br>
- setlocale() 함수에 의해 반환된 문자열 포인터는 프로그램 내에서 수정해서는 안되며, setlocale 함수를 다시 호출하면 문자열을 덮어 쓸 수 있다.<br>
- localeconv() 함수는 객체의 포인터를 반환한다. 반환값이 가리키는 구조체는 프로그램에 의해 수정해서는 안되며, 다시 localeconv() 함수를 호출하여 덮어 쓸 수 있다. 또한 LC_ALL, LC_MONETARY 혹은 LC_NUMERIC범주의 setlocale 함수를 호출하면 구조체의 내용을 덮어 쓸 수 있다.<br>
- setlocale() 혹은 localconv()에 의해 반환된 구조체로부터 얻는 문자열을 변경하면 정의되지 않은 동작을 야기한다.<br>
- strerror() 함수는 문자열에 대한 포인터를 반환한다. 가리키고 있는 배열은 프로그램 내에서 수정해서는 안되며, 이후에 다시 strerror() 함수를 호출하면 덮어 쓸 수 있다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Thread_Terminate_Using_Signal</rule>
    <ruleTitle><![CDATA[신호를 사용하여 스레드 종료 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 신호(signal)를 통해 스레드를 종료하면 스레드 뿐만 아니라 해당 프로세스까지 전체 종료하게 된다. 따라서 신호를 사용하여 스레드를 종료하면 안 된다.<br><br>

스레드를 종료하기 위해서 처리되지 않는 신호(uncaught signal)를 보낼 때는 스레드만 종료되는 것이 아니라 해당 프로세스까지 모두 종료된다. POSIX에서는 스레드를 종료하는 함수로 pthread_cancel(), pthread_setcancelstate() 및 pthread_setcanceltype() 함수가 있는데 이들은 비동기적인 안전성을 지원한다. 하지만 가급적 비동기적으로 스레드를 종료하는 것을 권장하지는 않는다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Treating_Predefined_ID_As_Obj</rule>
    <ruleTitle><![CDATA[사전 정의된 식별자가 매크로식으로만 정의된 경우 해당]]></ruleTitle>
    <ruleDesc><![CDATA[요약: C표준의 assert, errno, math_errhandling, setjmp, va_arg, va_copy, va_end 및 va_start 함수들은 매크로식으로 정의되어 있기 때문에 객체나 함수처럼 접근하면 정의되지 않은 동작이 발생한다.<br><br>

C표준은 “각 라이브러리 함수에 대한 매크로를 제공하더라도 각 라이브러리 함수에 대한 실제 함수를 제공해야 함을 의미한다.”라고 명시한다. 그러나 이 표준에는 예외가 몇 개 있다. 이 예외에 해당하는 매크로는 assert, errno, math_errhandling, setjmp, va_arg, va_copy, va_end 및 va_start이다. 이 매크로들은 동일한 이름을 가진 일반 라이브러리 함수가 존재하지 않기 때문에 함수처럼 접근하면 정의되지 않은 동작을 야기한다.]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Undefined_Behavior_Restrict_Ptr</rule>
    <ruleTitle><![CDATA[restrict 자격이 있는 포인터 사용 시 정의되지 않은 동작이 발생하지 않도록 주의 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약: restrict 포인터를 사용하여 메모리를 역참조하는 포인터를 다수 생성해도 컴파일 에러가 발생하진 않지만 , 컴파일러가 최적화할 때 문제가 생기므로 논리적 오류를 범할 가능성이 있다.<br><br>

restrict는 C99 표준으로 프로그래머에 의해 의도된 포인터 선언 방법이다 . restrict 는 특정 메모리 영역에 접근할 수 있는 포인터가 단 하나임을 보장하는 키워드로, 프로그래머가 컴파일러에게 이 포인터 이외엔 그 메모리 영역에 접근하는 수단이 없다고 미리 알려 컴파일러가 더 나은 최적화를 하도록 도와주는 키워드이다 . 따라서 restrict 키워드를 통해 특정 객체의 값을 캐시하는 것은 록의 시작 부분에서 정의하는 것이 안전하다. restrict 키워드는 명시적 제약이다 . restrict 포인터를 사용하면서 메모리를 역참조하는 포인터를 다수 만들어도 컴파일 에러가 발생하진 않지만, 컴파일러가 최적화할 때 문제가 생기므로 논리적 오류를 범할 가능성이 있다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Unsafe_Macro_Args</rule>
    <ruleTitle><![CDATA[불안전한 매크로에 특정 변수 값 변환 인자 전달 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 안전하지 않은 함수형 매크로에는 특정 변수의 값을 변화시키는 인자(증감 연자자와 함께 사용하거나, 메모리 변수 접근 및 함수 호출하는 인자)를 넘기면 안 된다.<br><br>

안전하지 않은 함수형 매크로(unsafe function-like macro)란 파라미터에 값이 변할 수 있는 인자를 넘겼을 때 인자가 함수 매크로 안에서 사용되지 않거나 두 번 이상 값이 변하는 수식을 포함하고 있는 매크로 함수를 의미한다. 안전하지 않은 함수형 매크로에는 가산, 감산과 같은 변수의 값을 변화시키는 인자를 넘기면 안 된다. 안전하지 않은 함수형 매크로에 변수의 값을 변화시키는 인자를 전달하게 되면 의도하지 않은 결과를 야기할 수 있다.]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Use_Path_Without_Max_Size</rule>
    <ruleTitle><![CDATA[최대크기 버퍼 없이 경로 조작 기능 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 소프트웨어는 경로 또는 파일 이름을 규정하는 함수를 호출하지만 PATH_MAX와 같이 가능한 최대 크기보다 작은 출력 버퍼 사용을 금지하여야 한다.<br><br>

부절절한 크기의 출력 버퍼를 경로 조작 함수에 전달하면 버퍼오버플로우가 발생할 수 있다. 이러한 함수에는 realpath(), readlink(), PathAppend()등이 있으며, 대부분의 함수는 버퍼 길이가 MAX_PATH 바이트 이상이어야 하지만 각 함수에 대해서는 개별적으로 확인해야 한다. 버퍼가 조작 결과를 저장하기에 충분히 크기 않으면 버퍼오버플로우가 발생할 수 있다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Avoid_Vfork_Func</rule>
    <ruleTitle><![CDATA[vfork() 사용 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : POSIX 규격의 vfork() 함수는 알려진 보안 취약점이 많기 때문에 사용하지 않아야 한다.<br><br>

POSIX 규격의 vfork() 함수는 정의되지 않은 동작을 발생하는 경우가 많다. 또한 vfork() 함수를 사용하면 경쟁 상태(race condition)가 발생할 가능성이 높다. 권한 높은 프로세스가 vfork() 함수를 호출하여 자식 프로세스가 execve() 함수를 호출하게 되면, 자식 프로세스가 부모 프로세스보다 권한이 낮지만 자식 프로세스가 실행되는 동안 부모 프로세스는 중지하게 된다. 따라서 공격자는 자식 프로세스를 연속적으로 요청하여 부모 프로세스가 중지된 상태를 유지하여 서비스 거부 공격(denial of service attack)을 실행할 수 있다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Check_Dyn_Arr_Struct</rule>
    <ruleTitle><![CDATA[가변 배열 멤버를 포함하는 구조체는 동적으로 복사 및 할당 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 가변 배열 멤버를 포함하고 있는 구조체는 항상 동적으로 할당 및 복사되고, 함수 인자에 전달할 때는 동적으로 전달(call by reference)해야 한다.<br><br>

C표준은 “둘 이상의 멤버를 가지고 있는 구조체의 마지막 멤버는 가변 배열 멤버를 가질 수 있다.
구조체의 크기를 정하는 대부분의 경우에는 가변 배열 멤버는 무시된다.”라고 명시한다. 다음은 가변 배열 멤버를 가지고 있는 구조체의 예이다.<br>
<pre>
struct flex_array_struct {
     int num;
     int data[];
};
</pre>
이러한 정의에서 구조체의 크기를 계산할 때 첫 번째 멤버인 num만 고려한다. 구조체의 객체에 대한 메모리를 할당할 때 가변 배열 멤버의 적절한 크기가 명시적으로 추가되지 않으면, 포인터 타입이 아닌 구조체 flex_array_struct 변수의 멤버 데이터에 접근할 때 정의되지 않은 동작을 야기한다. 잠재적으로 정의되지 않은 동작을 피하기 위해서는 가변 배열 멤버를 포함하고 있는 구조체는 항상 동적으로 할당되어야 한다. 가변 배열 구조체는 반드시 아래 규칙을 따라야 한다.<br><br>

1. malloc() 혹은 다른 동적 할당 함수를 통해서 동적으로 저장되어야 한다.<br>
2. memcpy() 혹은 다른 동적 할당 함수를 사용해서 동적으로 복사되어야 한다.<br>
3. 함수의 인수로 전달할 때에는 call by value 가 아닌 call by reference 로 사용해야 한다.]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Check_Empty_Str_Or_Not_After_Str_Func</rule>
    <ruleTitle><![CDATA[fgets() 혹은 fgetws()가 성공 시, 무조건 비어 있지 않은 문자열을 반환할 것이라고 가정 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약: 파일로부터 데이터를 읽을 때 바이너리 데이터 혹은 NULL 문자를 입력 받을 수도 있다. 프로그래머는 이를 항상 염두해 두어야 한다.
<br><br>
데이터를 읽을 때 혹은 프로그래머가 임의로 옳지 않은 가정을 했을 때 에러가 발생할 수 있다. 예를 들어, 사용자 터미널로부터 텍스트를 읽는 대신 바이너리 데이터를 읽거나 프로세스의 아웃풋으로부터 stdin으로 파이프 할 때 문제가 발생할 수 있다. C표준에서는 “fgets 함수는 호출에 성공했을 때, s를 반환한다. 만약 end-of-file(EOF)을 만나거나 혹은 더 이상 배열로 읽을 문자가 존재하지 않을 때에는 NULL 포인터가 반환된다.”라고 명시한다. wide 문자 함수 fgetws()도 마찬가지이다. 그러므로 fgets() 혹은 fgetws()는 NULL 포인터가 아닌 값을 반환하면, 배열이 데이터를 가지고 있다고 가정하는 것이 안전하다. 하지만 데이터가 NULL 문자를 가지고 있을 수도 있기 때문에, fgets() 혹은 fgetws()로 입력 받은 문자열에는 비어 있지 않은 문자열들만 포함하고 있다고만 가정하는 것은 옳지 않다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Check_Errno_After_Calling_Lib_Func</rule>
    <ruleTitle><![CDATA[errno과 관련한 라이브러리 함수 호출 시 주의 사항]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : errno 변수를 이용하여 라이브러리 함수가 오류가 발생했는지 판단할 때는, 먼저 errno 변수를 0으로 초기화해야 한다.<br><br>

errno는 헤더파일에 정의되어 있는 광역 변수이거나 시스템에 따라서 매크로이기도 한 값이다. 이 errno는 라이브러리 함수 실행 중 에러가 발생하면 어떠한 에러가 발생했는지 체크하고자 확인하는 용도로 사용된다. errno 값은 프로그램이 시작할 때 0으로 초기화되지만, 이후에 C표준 라이브러리 함수에 의해서는 0으로 설정되지 않는다. 오류가 있는지 없는지 여부에 관계없이 C표준 라이브러리 함수에 의해서 0이 아닌 값으로 설정될 수 있다. 오로지 에러가 발생한 후에만 errno의 내용을 검사하는 것이 의미가 있다. 즉, errno는 에러가 발생할 때 errno를 설정하는 라이브러리 함수가 에러코드를 반환한 후에만 의미가 있다. 일반적으로 반환 값을 확인하여 오류를 감지하고 errno를 사용하여 “파일을 찾을 수 없음” 혹은 “사용 권한이 거부되었습니다.”와 같은 오류의 다양한 원인을 구별한다. (일반적으로 perror 혹은 stderror를 사용하여 이러한 오류 메시지를 출력한다.) 함수에 오류가 반환되면 errno를 사용하여 오류를 감지하기 위해서는 errno를 0으로 설정하고 함수를 호출한 후에 errno를 테스트하여 오류를 감지해야 한다. (여기서 errno를 0으로 설정하는 것이 중요하다. 라이브러리 함수는 errono를 0으로 설정하지 않는다.)<br>
라이브러리 함수는 다음 범주로 분류된다.<br>
1. errno를 설정하고 out-of-band 에러 지시자를 반환하는 것<br>
2. errno를 설정하고 in-band 에러 지시자를 반환하는 것<br>
3. errno를 설정하지 않는 것<br>
4. 다른 표준 문서가 있는 것<br><br>

1. errno를 설정하고 out-of-band 에러 지시자를 반환하는 라이브러리 함수들<br><br>

C표준은 아래 표에 나열된 함수가 errno를 설정하고 out-of-band 에러 지시자를 반환하도록 지정한다. 프로그램은 함수가 에러 지시자를 반환했는지 먼저 확인하지 않고 errno의 값을 검사해서는 안 된다. 예를 들어, signal()이 실제로 SIG_ERR를 반환하는지 먼저 확인하지 않고 signal()을 호출한 후에 errno를 검사하면 안 된다.<br><br>

<table align="center" border="1" cellpadding="6">
<tr align="center" >
<td rowspan="2"><b>함수명</b></td><td rowspan="2"><b>반환 값</b></td><td rowspan="2"><b>errno 값</b></td>
</tr>

<tr align="center">
</tr>

<tr align="center"><td>ftell()</td><td>-1L</td><td>Positive</td></tr>
<tr align="center"><td>fgetpos(),fsetpos()</td><td>Nonzero</td><td>Positive </td></tr>
<tr align="center"><td>mbrtowc(),mbsrtowcs()</td><td>(size_t)(-1)</td><td>EILSEQ</td></tr>
<tr align="center"><td>signal()</td><td>SIG_ERR</td><td>Positive </td></tr>
<tr align="center"><td>wcrtomb(),wcsrtombs()</td><td>(size_t)(-1)</td><td>EILSEQ</td></tr>
<tr align="center"><td>mbrtoc16(),mbrtoc32()</td><td>(size_t)(-1)</td><td>EILSEQ</td></tr>
<tr align="center"><td>c16rtomb(),cr32rtomb()</td><td>(size_t)(-1)</td><td>EILSEQ</td></tr>

</table>
<center>[표 12 out-of-band 에러 지시자를 반환하는 라이브러리 함수 모음]</center><br>

2. errno를 설정하고 in-band 에러 지시자를 반환하는 라이브러리 함수들<br><br>

C표준은 아래 표에 나열된 함수가 errno를 설정하고 in-band 에러 지시자를 반환하도록 지정한다. 즉, 오류가 발생했을 때의 반환 값은 성공적인 호출의 유효한 반환 값이기도 하다. 예를 들어, strtoul() 함수는 ULONG_MAX를 반환하고 오류를 발생하면 errno를 ERANGE로 설정한다. 이 때 ULONG_MAX가 유효한 반환 값이기 때문에 오류가 실제로 발생했는지 여부를 확인하기 위해 errno를 사용해야 한다. 오류 검사를 위해 errno를 사용하는 프로그램은 이러한 라이브러리 함수 중 하나를 호출하기 전에 0으로 설정하고, 후속 라이브러리 함수 호출 전에 errno를 검사해야 한다. fgetwc() 와 fputwc() 함수는 몇몇 경우에 WEOF를 반환하며 그 중 한 경우만 errno를 설정한다. 문자열 변환 함수는 표현 가능한 최대 혹은 최소값을 반환하고 변환된 값을 데이터 타입으로 나타낼 수 없는 경우 errno를 ERANGE로 설정한다. 그러나 입력이 유효하지 않기 때문에 변환이 발생하지 않으면 함수는 0을 리턴하고 output 포인터 매개변수는 입력 포인터 매개 변수 값에 지정된다.<br><br>

<table align="center" border="1" cellpadding="6">
<tr align="center" >

<tr align="center" >
<td rowspan="2"><b>함수명</b></td><td rowspan="2"><b>반환 값</b></td><td rowspan="2"><b>errno 값</b></td>
</tr>

<tr align="center">
</tr>

<tr align="center"><td>fgetwc(),fputwc()</td><td>WEOF</td><td>EILSEQ</td></tr>
<tr align="center"><td>strtol(), wcstol()</td><td>LONG_MIN 혹은 LONG_MAX</td><td>ERANGE</td></tr>
<tr align="center"><td>strtoll(), wcstoll()</td><td>LLONG_MIN 혹은 LLONG_MAX</td><td>ERANGE</td></tr>
<tr align="center"><td>strtoul(), wcstoul()</td><td>ULONG_MAX</td><td>ERANGE</td></tr>
<tr align="center"><td>strtoull(), wcstoull()</td><td>	ULLONG_MAX</td><td>ERANGE</td></tr>
<tr align="center"><td>strtoumax(), wcstoumax()</td><td>UINTMAX_MAX</td><td>ERANGE</td></tr>
<tr align="center"><td>strtod(), wcstod()</td><td>0 혹은 +-HUGE_VAL</td><td>ERANGE</td></tr>
<tr align="center"><td>strtof(), wcstof()</td><td>0 혹은 +-HUGE_VAFL</td><td>ERANGE</td></tr>
<tr align="center"><td>strtold(), wcstold()</td><td>0 혹은 +-HUGE_VALL</td><td>ERANGE</td></tr>
<tr align="center"><td>strtoimax(), wcstoimax()</td><td>INTMAX_MIN,INTMAX_MAX</td><td>ERANGE</td></tr>

</table>
<center>[표 13 in-band 에러 지시자를 반환하는 라이브러리 함수 모음]</center><br>

3. errno를 설정하겠다고 약속하지 않는 라이브러리 함수<br><br>

C표준은 일부 함수에 대해 errno의 값을 바꾸지 않는다. 예를 들어, setlocale() 함수는 일반적으로 오류가 발생하면 널 포인터를 반환하지만 errno 설정을 하진 않는다. 이러한 함수 중 하나를 호출한 후 오류가 발생했는지 확인하기 위해서는 프로그램은 errno의 값에만 의존해서는 안 된다.<br><br>

4. 표준 문서가 다른 라이브러리 함수<br><br>

이 외의 다른 어떤 함수들은 다양한 표준에서 errno와는 다르게 동작한다. fopen() 함수가 대표적인 예이며, fopen() 함수는 오류가 발생하면 널 포인터를 반환한다. C표준에서는 fopen()을 설명할 때 errno에 대해서는 언급하지 않는다. 그러나 POSIX에서는 fopen()이 에러를 만나면 널 포인터를 반환하지 않고 errno를 에러 값으로 설정한다. 즉, C 프로그램은 윈도우 운영체제에서는 fopen()을 호출한 후에는 errno를 검사해서는 안되지만 POSIX 프로그램에서는 fopen()을 호출한 후에는 errno를 검사해야 한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Check_Improper_Arg_Calling_Asctime</rule>
    <ruleTitle><![CDATA[asctime() 함수 사용 시 부적절한 인자 전달 주의]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : C표준에 정의되어 있는 asctime() 함수는 26글자의 출력 버퍼를 사용한다. 전달 데이터가 예상보다 길이가 긴 경우에는 버퍼 오버플로우가 발생한다.<br><br>

asctime() 함수는 NULL 문자를 포함하여 최대 26글자의 문자열을 반환하도록 구현되어 있다. 이로 인해서 전달 데이터의 유효성이나 범위 검증이 없어 기준보다 긴 데이터를 전달받을 때, 출력 버퍼 오버플로우가 발생한다. asctime()의 함수는 연도(tm_year)를 4글자 이하의 입력으로 받도록 가정되어 있는데 예를 들어 12345년을 입력하면 결과의 길이가 27글자가 되어 버퍼 오버플로우가 발생한다. asctime() 대신 POSIX strftime()이나 C표준의 asctime_s()를 사용하는 것을 권장한다. (비고) asctime_s() 함수 사용을 위해서 C표준 Annex K를 참조한다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Check_Seed_Using_PRNG</rule>
    <ruleTitle><![CDATA[PRNG 사용 시 seed를 올바르게 설정 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약: PRNG 함수 사용 시 seed를 올바르게 설정해야 한다.
<br><br>
PRNG는 난수의 속성에 근사하는 숫자 시퀀스를 생성할 수 있는 결정론적인 알고리즘이다. 각 시퀀스는 PRNG의 초기 상태와 상태를 변경하는 알고리즘에 의해 완전히 결정된다. 대부분의 PRNG는 seed state라고 하는 초기 상태를 설정할 수 있다. 올바른 seed를 설정하는 것을 seeding이라고 한다. 동일한 초기 상태에서 PRNG를 명시적으로 seeding하지 않거나 동일한 값으로 seeding하여 PRNG를 사용하면 프로그램 실행마다 동일한 난수 시퀀스가 생성된다. 결과적으로 부적절하게 seeding된다면 PRNG가 처음 실행된 이후에 공격자는 앞으로 생성될 난수 시퀀스를 예측할 수 있다. 부적절하게 seeding하거나 seeding에 실패한 PRNG를 사용하게 되면 취약점을 발생시킬 수 있으며 특히 보안 프로토콜에서 보증하는 보안성을 제공할 수 없게 만들 수 있다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Check_Thread_Safety_Using_Cond_Var</rule>
    <ruleTitle><![CDATA[조건 변수 사용 시 스레드의 안전성과 생존성 보호 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 조건 변수를 사용할 때는 스레드의 안전성과 생존성을 보장하기 위해 스레드를 다루는 함수인 cnd_wait() 및 cnd_signal() 함수가 적절하게 다루어 져야 한다.<br><br>

조건 변수를 사용할 때에는 스레드의 안전성과 생존성을 고려해야 한다. 스레드의 안전성이란 멀티스레드 환경에서 모든 객체들이 일관된 상태를 유지하도록 하는 것을 의미한다. 스레드의 생존성은 모든 작업이나 함수 호출이 교착 상태와 같은 중단없이 완료되도록 하는 것을 의미한다. 조건 변수는 while 반복문 내에서만 사용되어야 한다. 생존성을 보장하기 위해서는 프로그램에서 스레드를 대기 상태로 두어야 하고, 이를 위해 cnd_wait() 함수를 호출하기 전 while 반복문 조건을 검사해야 한다. 이 조건 검사를 통해 다른 스레드는 통보하였는지 확인한다. 하지만 통보된 후에 스레드가 다시 cnd_wait()을 호출하게 되면 프로그램은 무기한으로 중지된다. cnd_signal() 함수는 중단된 스레드 중 하나를 재개한다. 여러 스레드가 동일한 조건 변수에서 대기 중이면, 스케줄러는 모든 스레드가 동일한 우선 순위 레벨을 가진다고 가정하고 해당 스레드 중 하나를 선택한다. cnd_broadcast() 함수는 중단된 모든 스레드를 재개한다. cnd_broadcast() 함수가 호출된 후에는 스레드의 우선순서가 지정되지 않는다. 따라서 cnd_wait() 함수에서 깨어난 후에도 조건 술어를 검사해야 한다. while 반복문을 이용해 cnd_wait() 호출 전후에 조건 술어를 확인하는 것이 가장 좋은 방법이다. 만약 각 스레드가 고유한 조건 변수를 사용한다면 cnd_signal() 함수를 사용하는 것이 안전하다. 하지만 여러 스레드가 조건 변수를 공유하는 경우에는 cnd_signal() 함수는 다음 조건을 만족하는 경우에만 안전하다.
 -  모든 스레드는 깨어난 후에 동일한 작업 집합을 수행하는 경우. 즉, 어떠한 스레드이던 cnd_signal() 함수를 통해 깨어나도 상관이 없는 경우
 -  신호를 받았을 때 하나의 스레드만 깨어 있어야 하는 경우
cnd_signal() 함수의 사용이 안전하지 않은 경우, 중지된 모든 스레드를 재개하기 위해 cnd_broadcast() 함수를 사용할 수도 있다.]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Check_Wrap_Function_In_Loop</rule>
    <ruleTitle><![CDATA[반복문 내에서 거짓으로 깨어날 수 있는 함수의 래핑 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약: cnd_wait(), cnd_timedwait() 함수는 서술자(predicate)가 있는지 여부를 확인하여 반복문 내에서 호출해야 한다. 서술자(predicate)는 스레드가 깨어났을 때, 스레드가 계속 실행되어도 되는지 판단하는 역할을 한다.
<br><br>
cnd_wait() 함수와 cnd_timedwait() 함수는 일시적으로 뮤텍스의 소유를 양도하여 다른 스레드가 진행될 수 있도록 한다. 대기 스레드는 일반적으로 다른 스레드가 cnd_signal() 혹은 cnd_broadcast() 함수를 호출한 결과로 통지를 받고 실행을 다시 시작한다. cnd_wait(), cnd_timewait() 함수는 서술자(predicate)가 있는지 여부를 확인하여 반복문 내에서 호출해야 한다. 서술자(predicate)는 스레드가 깨어났을 때, 스레드가 계속 실행되어도 되는지 판단하는 역할을 한다.]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Clean_Up_Thread_Storage_After_Assign</rule>
    <ruleTitle><![CDATA[할당 후 스레드 저장소 정리 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약: 스레드별 메모리를 할당한 후에는 항상 저장 영역을 소멸하여 메모리가 누수 되는 것을 방지해야 한다.
<br><br>
tss_create() 함수는 키로 식별되는 스레드 특정 저장 영역의 포인터를 생성한다. 스레드는 스레드별 저장소를 할당하고, 그 저장소를 tss_set() 함수 호출을 통해 고유한 식별자 키와 연관시킬 수 있다. 하지만 스레드별 저장 영역을 제대로 소멸 해제하지 않으면 메모리의 누수가 일어날 수 있다. 프로그램은 항상 스레드별 저장 영역이 메모리 상 소멸되었다는 것을 보장해야 한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Close_Unnecessary_Resource</rule>
    <ruleTitle><![CDATA[사용이 불필요한 파일 닫기 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약: 열려 있는 파일 포인터는 프로그램의 종료 혹은 파일 포인터의 생명주기가 끝나기 전에 fclose() 함수를 통해 닫아야 한다.
<br><br>
fopen() 및 freopen() 함수에서 반환하는 파일 포인터는 프로그램이 정상적으로 종료되기 전 혹은 포인터의 생명주기가 끝나기 전에 반드시 fclose()를 통해서 닫아야 한다. 이 규칙은 POSIX의 open() 및 close() 함수 혹은 Microsoft Windows의 CreateFile() 및 CloseHandle() 함수에도 해당된다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Declaration</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Confuse_Narrow_And_Wide_String</rule>
    <ruleTitle><![CDATA[문자열을 다루는 함수에 인수를 전달할 때 narrow 문자열과 wide 문자열을 정확히 구분 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : wide 문자열 함수에는 wide 문자열을 전달해야 하고, narrow 문자열 함수에는 narrow 문자열을 전달해야 한다.<br><br>

wide 문자열 함수에 narrow 문자열을 전달하거나 narrow 문자열 함수에 wide 문자열을 전달하는 것은 정의되지 않은 동작을 야기할 수 있다. wide 문자열과 narrow 문자열 간 크기의 차이 때문에 문제가 많이 발생한다. wchar_t와 char타입은 다른 타입이기 때문에, 만약 부적절한 함수가 사용되었다면 많은 컴파일러들은 경고 진단 메시지를 띄운다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Consideration_Of_Shift_Operation</rule>
    <ruleTitle><![CDATA[음수 값으로 시프트 또는 피연산자의 비트와 같거나 더 많은 비트로 시프트 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 비트를 시프트할 때 음수 값으로 시프트하거나 피연산자의 비트와 길이가 같거나 더 많은 비트를 시프트하면 안 된다.<br><br>

비트 시프트 연산은 왼쪽 시프트 연산(left-shift operation)과 오른쪽 시프트 연산 (right-shift operation)으로 나뉜다. 시프트 전에는 피연산자들의 표준 정수 형변환이 이루어진다. 이때, 두 번째 피연산자가 음수이거나 첫 번째 피연산자의 너비(비트)와 같거나 더 큰 경우에 정의되지 않은 동작을 야기한다. 첫 번째 피연산자의 정밀도(precision)보다 크거나 같은 수를 시프트하거나 음수 값을 시프트하면 안 된다. 이때, 정수형 타입의 정밀도란 시프트하고자 하는 변수의 값을 나타낼 때 사용되는 비트의 수를 의미하며 부호와 패딩 비트를 제외한 길이를 말한다. 부호가 있는 정수형 타입은 길이(width)가 정밀도+1의 값을 가지는 반면, 부호가 없는 정수형 타입에서는 길이와 정밀도의 길이가 같다. 이 규칙은 길이에 적용되는 것이 아니라 정밀도에 사용된다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Correct_Calculation_Multibyte_Str_Len</rule>
    <ruleTitle><![CDATA[멀티바이트 문자열 길이의 잘못된 계산]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 소프트웨어 와이드 또는 멀티 바이트 문자를 포함할 수 있는 문자열 길이를 올바르게 계산하여야 한다.<br><br>

와이드 또는 멀티 바이트 문자열, 문자열 길이 함수의 출력이 메모리 할당 크기로 사용될 때 이 룰의 위반이 발생한다. 이로 인해 문자열의 문자 수가 출력되지만 문자는 표준 문자열과 함께 단일 바이트가 아닐 가능성이 높다. 따라서 new 또는 malloc에 전송된 크기로 리턴 된 크기를 사용하고 문자열을 새로 할당 된 메모리에 복사하면 버퍼 오버 플로우가 발생한다. 이러한 문자열을 잘못 사용하는 또 다른 일반적인 방법은 단일 문자열에서 표준 문자열과 와이드 또는 멀티 바이트 문자열 기능을 혼합하는 것이다. 이 불일치 정보는 항상 이용 가능한 버퍼 오버 플로우 조건을 생성하게 된다. 이러한 결함이 있는 언어를 사용해야 하는 경우 가장 효과적인 방안은 구현시 코드에 주의를 기울이는 것이다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Detect_Error_Casting_Str_To_Number</rule>
    <ruleTitle><![CDATA[문자열에서 숫자로 형변환 시 에러 감지 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 문자열에서 숫자로 형변환할 때는 해당 정수의 범위가 올바른지, 숫자가 아닌 값을 포함하고 있는지 검사해야 한다.<br><br>

문자열에서 정수 혹은 부동 소수점 숫자를 파싱하는 과정에서 많은 오류가 발생할 수 있다. 문자열에 숫자가 포함되지 않을 수도 있고, 범위를 벗어난 숫자가 포함될 수도 있다. 이러한 오류들은 C표준 라이브러리 기능을 사용하여 문자열–숫자 변환이 수행될 때 감지되고 해결되어야 한다. strtol(), strtoll(), strtoul(), strtoull(), strtoumax(), strtof(), strtod(), strtold() 함수들은 널 문자로 끝나는 바이트 문자열의 처음 부분을 long int, long long int, intmax_t, unsigned long int, unsigned long long int, uintmax_t, float, double 및 long double 표현으로 각각 나타낸다. 문자열에서 정수 혹은 부동 소수로 파싱하기 위해서는 C표준 라이브러리들 중 strto* 로 시작하는 함수들 중 하나를 사용할 수 있다. 이 함수는 더 강력한 오류 처리 기능을 제공한다. 예를 들어, strtol() 함수는 signed int, signed short 및 signed char와 같이 더 작은 signed integer로 변환하고 해당 타입의 범위를 검사한다. 비슷하게, strtoul() 함수는 unsigned int, unsigned short 및 unsigned char와 같이 더 작은 unsigned integer 타입으로 변환하고 해당 타입의 범위에 대해 결과를 테스트한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Distinguish_Between_EOF_And_WEOF</rule>
    <ruleTitle><![CDATA[파일에서 읽는 문자와 파일 끝 문자(EOF 혹은 WEOF)를 구별 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 파일을 읽을 때는 항상 파일로부터 읽는 유효한 문자와 파일 끝 문자(EOF 혹은 WEOF)를 구별해야 한다.<br><br>

EOF 매크로는 음수 값을 나타내며 파일에서 데이터를 읽을 때 파일에 더 이상 읽을 데이터가 남아있지 않음을 나타낸다. 바이트 입출력 함수 fgetc(), getc() 및 getchar()는 모두 스트림에서 문자를 읽고 이를 int로 반환한다. 이 때 스트림이 파일의 끝을 가리키고 있거나 읽기 오류가 발생하면 함수는 EOF를 반환한다. 만약 함수가 성공적으로 끝나면, 반환된 문자는 unsigned char 로 형변환된다. int 타입의 크기가 char 타입의 크기보다 큰 구현 환경일 때, EOF는 음수이므로 unsigned char 값과 일치해서는 안 된다. int 타입과 char 타입의 크기가 같은 구현 환경에서는 문자를 읽는 함수는 EOF 같은 비트 패턴을 가지는 유효한 문자를 읽고 반환할 수 있다. 이러한 경우에는 공격자가 EOF와 비슷한 값을 파일 혹은 데이터 스트림에 삽입해서 프로그램의 동작을 변경할 수 있다. C표준은 int 타입이 +32767(0x7FFF)의 최대 값을 나타낼 수 있어야 하고, char 타입이 int보다 크지 않아야 한다고 요구하고 있다. 흔하지는 않지만, char 타입과 int 타입의 크기가 같은 구현 환경에서는 정수 상수인 EOF가 유효한 문자와 구분할 수 없는 상황을 발생시킬 수 있다. 결과적으로 sizeof(int) == sizeof(char) 구현 환경에서는 파일의 끝을 감지하고 파일 에러를 감지하기 위하여 feof()와 ferror()를 사용하는 것은 EOF 문자를 잘못 판단할 수 있도록 만든다. 이러한 문제는 wide 문자열을 읽을 때 훨씬 더 일반적으로 생긴다. fgetwc(), getwc() 및 getwchar() 함수는 wint_t 타입의 값을 반환한다. 이 값은 그 다음 문자를 읽을 수도 있고 wide 문자의 끝을 나타내는 WOEF를 표현할 수도 있다. 대부분의 구현 환경에서는 wchar_t 타입은 wint_t 와 동일한 크기를 가지고 있으며 이러한 환경은 WEOF와 입력 받는 문자를 구분하지 못하게 한다. 이런 문제 때문에 C표준 feof() 와 ferror() 함수는 파일 끝 및 파일 오류를 확인하는 데 사용해야 한다. 반복문에서 각 반복마다 두 함수를 호출하면 상당한 오버 헤드가 추가되므로 반복문 내에서 보다는 반복문 다음에 feof() 및 ferror()를 사용하여 이를 확인하는 것이 좋다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Evaluation_Order_For_Side_Effect</rule>
    <ruleTitle><![CDATA[부수효과(Side Effect)를 발생시키는 계산(평가) 순서에 주의]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 하위 표현 식의 계산(평가) 순서나 부수효과가 발생하는 순서로 인하여 시퀀스 포인트(Sequence point) 내에서 잘못된 계산이 발생하지 않도록 해야 한다.<br><br>

하위 표현 식의 계산(평가) 순서나 부수효과가 발생하는 순서 등은 C표준(C99)에서 지정되지 않은 행동으로 분류된다. 자세히 살펴보면 함수에 주어진 인수가 평가되는 순서, 할당문에서 피연산자가 평가되는 순서, 초기화 표현 식에서 나열된 객체들이 부수효과를 갖는 순서 등은 정의되어 있지 않기 때문에 플랫폼이나 컴파일러에 따라 다르게 단락 평가가 발생할 수 있다. 따라서 구문에서 다수의 하위 표현식이나 부수효과가 존재하는 경우 그 문맥을 구분하거나 하여 의도된 단락평가만이 가능하도록 작성해야 한다. 이와 관련해서 다음과 같은 항목에 특히 주의해야 한다.<br>
- 수식에 부수효과(Side Effects)가 있는 경우, 연산 순서에 따라 다른 값이 나올 수 있음.<br>
- 함수 호출 순서에 의해 부수효과가 발생하는 경우(논리 연산자 &&, ||, 삼항 연산자의 우항에 함수가 위치하는 경우)<br>
- 논리 연산자 &&, ||의 우항에 부수효과가 존재하는 경우<br>
- &&, ||의 우항에서 volatile 변수에 접근하는 경우(조건문의 연산 순서는 좌항에서 우항이지만, volatile 변수의 값 변화가 좌항에 의존적일 경우 의도하지 않은 동작을 야기시킬 수 있음)<br>
- 기타 순서가 정의되지 않은 하위 표현식 (반환 문에서 할당 연산이 있는 경우 등)]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Float_Point_Cast_Within_Newtype_Range</rule>
    <ruleTitle><![CDATA[부동 소수점 타입 형변환이 새로운 타입의 범위 내에서 이뤄지도록 보장]]></ruleTitle>
    <ruleDesc><![CDATA[요약: 부동 소수점 타입을 형변환할 때는 해당 값을 표현할 수 있는 새로운 타입으로 변환이 이뤄져야 한다.<br><br>

만약 부동 소수점 값이 더 작은 범위의 부동 소수점이나 더 작은 정밀도(precision)의 정수형 타입으로 변환 혹은 정수형 타입이 부동 소수점 타입으로 변환된다면, 값은 반드시 변환되는 타입으로 나타낼 수 있어야만 한다. C표준은 다음과 같이 세 문단을 명시하고 있다.
- 실수형 부동 소수점 타입의 유한 값이 정수형 타입으로 변환될 때, 소수 부분은 폐기된다. 그리고 남은 정수 부분의 값을 정수 타입으로 표현할 수 없다면 정의되지 않은 동작이 발생한다.
- 정수형 타입의 값이 실수형 타입으로 변환될 때 변환되는 값이 정확히 새로운 타입에서 표현될 수 있다면, 그 값은 변하지 않는다. 만약 변환되는 값이 새로운 타입에 정확히 표현될 수 없다면, 결과는 변환되기 전의 값 이상 또는 이하에서 가장 가까운 수이다. 그리고 만약 전환되는 값이 값의 범위를 벗어날 때에는 정의되지 않은 동작을 야기한다.
- 실수형 타입의 값이 실수형 타입으로 변환될 때, 변환되는 값이 정확히 새로운 타입에서 표현될 수 있다면 그 값은 변하지 않는다. 만약 변하는 값이 새로운 타입에 정확히 표현될 수 없다면, 결과는 변환되기 전의 값 이상 또는 이하에서 가장 가까운 수이다. 그리고, 만약 전환되는 값이 값의 범위를 벗어날 때에는 정의되지 않은 동작을 야기한다.]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Handle_Error_Using_POSIX_Library</rule>
    <ruleTitle><![CDATA[POSIX 라이브러리 함수 사용 시 오류 탐지 및 예외 처리 수행 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약: 표준 라이브러리 함수를 사용할 때는 반환 값을 검증하고 올바른 예외 처리를 해야 한다.
<br><br>
프로그래머가 “항상 모든 함수는 성공적으로 실행될 것이다.”라고 가정하는 것은 위험하다. I/O 함수 및 메모리 할당 함수를 포함한 모든 표준 라이브러리 함수는 유효한 값 또는 오류 메시지를 반환하는데, 이러한 함수에 대해서 항상 모두 정상적으로 실행될 것이라고 가정하고 오류 처리를 하지 않는 것은 정의되지 않은 동작을 초래할 수 있다. 표준 라이브러리 함수를 사용할 때는 반환 값을 검사하고 올바른 예외 처리를 해야 한다. POSIX 표준 라이브러리 함수들 중에서 fmemopen(), open_memstream() 및 posix_memalign()는 예외 처리가 특히 중요하기 때문에, 이 함수들은 사용 시에 무조건 반환 값을 검증하고 예외 처리를 해야 한다.
보안과 관련이 없는 printf(), putchar(), puts(), putwchar(), vprint(), vwprintf(), wprintf() 함수들은 반환 값을 검증할 필요가 없다. 위에 포함되지 않은 함수들 중에서도 오류 발생의 영향이 없을 때에는 반환 값을 검증하지 않아도 되지만, 이러한 경우에는 프로그래머의 의도를 표현하기 위해서 해당 함수의 반환 타입을 void 타입으로 바꾸어 주어야 한다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Dead Code</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_IO_Stream_Without_Flush_Position_Call</rule>
    <ruleTitle><![CDATA[플러쉬 혹은 위치 지정 호출 개입 없이 스트림 교대로 입력 및 출력 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : fflush() 혹은 위치 조정 함수 fseek(), fsetpos(), rewind()의 호출 없이 입력 작업과 출력 작업은 교대로 해서는 안 된다.<br><br>

C표준은 스트림에 대하여 “파일이 수정 모드(update mode)로 열렸을 때, 파일에 입력 작업 및 출력 작업 수행이 가능하다. 하지만, fflush 함수의 호출이나 위치조정 함수(fseek, fsetpos, rewind)의 호출 없이 출력 작업이 입력 작업 바로 뒤에 오면 안 된다. 그리고, 입력 작업은 출력 작업 바로 뒤에 fflush 함수의 호출 혹은 위치조정 함수의 호출 없이 위치하면 안 된다.”와 같이 명시하고 있다. 따라서 아래 두 개의 시나리오는 정의되지 않은 동작을 야기할 수 있다.<br>
1. 파일의 끝이 아니면서 출력 작업 직후에 fflush(), fseek(), fsetpos() 혹은 rewind() 함수의 호출 없이 입력 작업을 할 때<br>
2. 파일의 끝이 아니면서 입력 작업 직후에 fseek(), fsetpos(), rewind() 함수의 호출 없이 출력 작업을 할 때<br>
결과적으로 입력과 출력 작업 사이에는 fseek(), fflush(), fsetpos()가 필요하다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Improper_Clear_Heap_Before_Release</rule>
    <ruleTitle><![CDATA[릴리즈 이전 힙 메모리의 잘못된 삭제('Heap inspection')]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 중요한 정보를 저장하는 버퍼의 크기를 조정하기 위해 realloc()을 사용하면 민감한 정보가 메모리에서 제거되지 않아 공격자에게 중요 데이터를 노출시킬 수 있는 위협에 놓이게 되므로 사용에 주의하여야 한다.<br><br>

암호나 암호화 키와 같은 중요한 데이터가 메모리에서 제거되지 않으면 메모리 덤프나 다른 방법을 사용하여 중요한 데이터를 읽는 힙 인스펙션 공격을 통해 공격자에게 노출될 수 있다. realloc() 함수는 일반적으로 할당된 메모리 블럭의 크기를 늘리는데 사용된다. 이 작업은 종종 기존 메모리 블럭의 내용을 새롭고 더 큰 블럭으로 복사해야 한다. 이 작업은 원본 블록의 내용을 그대로 유지하지만 프로그램에 접근할 수 없게 한다. 이는 프로그램이 메모리에서 중요한 데이터를 제거할 수 없게 하는 것이다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Incorrect_Arg_Type</rule>
    <ruleTitle><![CDATA[putenv() 함수에 지역변수를 가리키는 포인터 전달 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : POSIX에서 제공하는 putenv() 함수는 환경 설정하는 데 사용한다. 그러나 환경변수를 설정하기 위해 지역변수를 가리키는 포인터를 전달하면 정의되지 않은 동작을 야기한다.<br><br>

putenv() 함수는 환경변수를 설정하는 데 사용한다. putenv() 함수는 인자로 전달받은 변수의 복사본을 만들지 않고 해당 포인터를 환경변수 배열에 삽입한다. 따라서 지역변수를 가리키는 포인터를 사용할 때, 해당 변수의 값을 가리키는 메모리의 할당 해제 및 재사용이 발생할 가능성이 있다. 이러한 경우에는 환경 설정에 사용되는 값도 덮어 쓸 수 있다. 하지만 정적 존속 기간을 갖는 static 변수의 포인터를 전달하는 것은 문제가 없다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Invalid_Pointer_From_Library_Function</rule>
    <ruleTitle><![CDATA[라이브러리 함수로부터 무효한 포인터]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 배열 혹은 객체를 바꾸는 C 라이브러리 함수에 포인터를 전달할 때는 포인터가 가리키는 배열의 크기가 유효한 범위여야 한다.
<br><br>
배열 또는 객체를 변경하는 C 라이브러리 함수는 배열 또는 객체에 대한 포인터와 배열 또는 객체의 크기 숫자를 인수로 전달받는다. 포인터가 가리키는 배열의 크기는 함수 내에서 배열에 접근하기 때문에 유효한 범위여야 한다. 함수의 인수로 전달할 때 배열을 올바르게 가리키고 있지 않은 포인터 혹은 배열이나 객체의 끝을 지난 포인터를 가리키게 되면 정의되지 않은 동작을 야기한다.

함수 오른쪽에 붙어 있는 첨자가 가리키는 규칙은 아래와 같다.
1. 인수로 두 개의 포인터와 정수 값을 사용하지만, 정수는 입력 버퍼의 길이가 아닌 출력 버퍼의 길이를 나타낸다.
2. 인수로 두 개의 포인터와 정수값을 사용하지만, 정수는 출력 버퍼의 길이가 아닌 입력 버퍼의 길이를 나타낸다.
3. 인수로 두 개의 포인터와 두 개의 정수값을 사용한다. 각 정수 값은 각 포인터에 대한 길이를 나타낸다.
4. 인수로 포인터와 크기와 관련된 두 개의 정수값을 사용한다. 크기와 관련된 첫 번째 정수 인수는 버퍼에서 사용 가능한 바이트의 개수를 의미하고, 두 번째 정수 인수는 버퍼에 쓰여진 바이트 개수를 의미한다.

포인터와 정수값을 취하는 호출들은 포인터가 가리키는 객체나 배열의 실제 크기보다 크면 안 된다.

]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Misinterpreted_Integer_Conversion</rule>
    <ruleTitle><![CDATA[정수 형변환 시 값이 잘리거나 변하지 않도록 보장]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 묵시적 형변환이든 타입 캐스팅을 통한 명시적 형변환이든 형변환에 있어서 데이터 손실이 발생하거나 값이 변하지 않도록 보장해야 한다.<br><br>

정수값의 형변환으로 값이 잘리거나 변하지 않도록 보장해야 한다. 특히 바뀐 값이 배열의 인덱스, 포인터 연산, 배열의 경계(예, 반복문 카운터), 보안에 민감한 코드 등에 사용될 경우 더욱 큰 문제가 발생할 수 있다. 정수의 형변환에 있어서 값이 항상 안전하게 보장될 수 있는 형변환 방법은 부호가 같은 더 큰 정수형 타입으로 형변환을 하는 것이다. 일반적으로 정수를 더 작은 정수 타입으로 변환할 경우 높은 자릿수 비트가 잘리게 된다. 따라서 더 작은 정수 타입으로의 형변환은 항상 값의 잘림을 확인해야 한다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Modify_String_Literal</rule>
    <ruleTitle><![CDATA[문자열 리터럴 수정 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 문자열 리터럴을 const가 아닌 포인터에 할당하거나 캐스팅하면 안 된다.<br><br>

C표준은 “문자열 리터럴은 (“xyz”)와 같이 큰 따옴표로 묶인 0개 혹은 여러 개의 멀티 바이트 문자를 나타낸다. UTF-8 문자열 리터럴은 u8 접두어를 제외하고는 동일하다. wide 문자열 리터럴은 접두어로 L, u, 혹은 U가 붙는 것을 제외하면 똑같다.”라고 명시한다. 컴파일 시에는 문자열 리터럴을 사용하여 문자 시퀀스와 종료 문자를 포함할 수 있는 충분한 길이의 정적 저장 공간 배열을 만든다. 문자열 리터럴은 문자에 대한 포인터 (혹은 배열)로 참조된다. 이상적으로 const_char 혹은 const wchar_t에 대한 포인터(혹은 배열)에만 할당되어야 한다. 문자열 리터럴은 일반적으로 읽기 전용 메모리에 저장되기 때문에 문자열 리터럴을 수정하면 접근 위반이 자주 발생한다. 문자열 리터럴을 const가 아닌 포인터에 할당하거나 캐스팅하면 안 된다. 또한, 아래 라이브러리 함수들에 대해서는 첫 번째 인수가 문자열 리터럴인 경우 반환 값은 반드시 문자열 리터럴이여야 한다.<br>
- strpbrk(), strchr(), strrchr(), strstr()<br>
- wcspbrk(), wcschr(), wcsrchr(), wcsstr()<br>
- memchr(), wmemchr()
]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Only_Free_Dyn_Alloc_Memory</rule>
    <ruleTitle><![CDATA[동적으로 할당된 메모리 해제 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : free() 함수를 통해 할당 해제할 때는 동적으로 할당된 메모리만 해제해야 한다. 또한, realloc() 함수를 통해 할당된 메모리의 크기를 변경할 때는 동적으로 할당된 메모리에 대한 포인터가 전달되어야 한다.<br><br>

C표준은 “free 혹은 realloc 함수의 인수로 받는 포인터가 기존에 메모리 관리 함수에 의해 할당된 메모리에 대한 포인터가 아니거나, 이전에 이미 free 혹은 realloc 함수로 할당 해제된 공간을 가리키는 포인터인 경우 정의되지 않은 동작을 야기한다.”라고 명시한다. 동적으로 할당되지 않은 메모리를 해제하는 것은 힙 공간의 변형을 야기하거나 다른 심각한 에러를 발생시킬 수 있다. 기존 malloc(), calloc(), realloc(), 혹은 aligned_alloc()와 같은 메모리 관리 함수에 의해서 반환된 포인터를 제외하고는 free() 함수를 통해서 메모리를 할당 해제하면 안 된다. realloc() 함수가 비 동적으로 할당된 메모리를 가리키는 포인터를 가리킬 때 비슷한 상황이 발생한다. realloc() 함수는 동적 메모리 블록의 크기를 바꾼다. 만약 realloc() 함수가 표준 메모리 할당 함수에 의해 할당되지 않은 메모리의 포인터를 인수로써 취한다면, 정의되지 않은 동작을 야기한다. 이 규칙은 NULL 포인터에는 적용되지 않는다. 단, free()에 NULL 포인터가 전달됐을 때에는 아무 일도 발생하지 않는다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Operator_Precedence_Logic_Error</rule>
    <ruleTitle><![CDATA[괄호를 사용한 연산자 우선순위의 명확한 처리 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 연산자 우선순위에 의존해서 연산자를 복잡하게 혼용하여 사용하지 말고 괄호로 연산 순서를 명확히 해야 한다.<br><br>

C 표준(C99)에서는 연산자의 우선 순위에 대해 정의하고 있다. 그러나 이 연산자 우선 순위에 대해 잘못 이해하거나 & , | , ^ , << , >> 등 우선 순위가 직관적이지 않은 경우 개발자의 실수로 인하여 잘못된 연산 순서를 만들 수 있다. 따라서 코드를 작성함에 있어서 괄호를 사용하여 그 우선 순위를 정확히 표현해 주는 것이 실수를 예방하는 방어적 프로그래밍을 할 수 있을 뿐만 아니라, 추후 유지 보수성이나 코드 가독성 측면에서도 더 좋다. 설령 C 연산자 우선 순위에만 의존하여 작성한 수식이 올바른 결과를 나오게 할지라도 에러 방지 및 가독성 향상을 위해 괄호를 사용해야 한다. 보안 기능이나 암호 라이브러리 등에서 잘못된 연산 순서를 만들 경우 잘못된 결과를 초래할 뿐만 아니라 그 잘못된 결과로 인하여 보안 기능의 오동작 등을 만들어낼 수 있다. 따라서 괄호를 통한 연산 순서를 명확히 하고 한번에 너무 많은 연산자를 열거해서는 안 된다.]]></ruleDesc>
    <ruleSeverity>Other</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Precision_Casting_Int_To_Float_Point</rule>
    <ruleTitle><![CDATA[정수형 타입에서 부동 소수점 타입으로 형변환 시 정밀도]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 정밀도(precision)를 보장하지 않고 정수형 타입을 부동 소수점 타입으로 형변환하는 것은 데이터의 손실을 가져올 수 있다.<br><br>

좁은 산수형 타입은 숫자 값의 크기에 영향을 주지 않고 넓은 타입으로 캐스팅될 수 있다. 하지만, 정수 타입은 정확한 값을 나타내지만 부동 소수점 타입은 정밀도(precision)가 제한적이다. C표준에서는 “정수 타입의 값이 실수형으로 형변환될 때, 변환되는 값이 정확히 새로운 타입에서 표현될 수 있다면, 그 값은 변하지 않는다. 만약 변하는 값이 새로운 타입에 정확히 표현될 수 없다면, 결과는 변환되기 전의 값 이상 또는 이하에서 가장 가까운 수가 된다. 그리고 만약 변환되는 값이 값의 범위를 벗어날 때에는 정의되지 않은 동작을 야기한다. 일부 암시적 변환의 결과는 새로운 타입이 필요로 하는 것 보다 더 큰 범위와 정밀도로 나타낼 수 있다.”라고 명시한다. 충분한 정밀도를 보장하지 않는 정수형 타입을 부동 소수점 타입으로 형변환하는 것은 정밀도의 손실을 가져올 수 있다. 이때, 정보의 손실에도 불구하고 런타임 예외는 발생하지 않는다.]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Reset_Str_After_Fail_Of_Str_Func</rule>
    <ruleTitle><![CDATA[fgets() 혹은 fgetws() 실패 시 문자열 리셋 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약: fgets() 혹은 fgetws() 함수 호출에 실패했을 때, 배열에 쓰여지는 값은 정의되지 않은 값이므로 다시 유효한 값으로 초기화해야 한다.
<br><br>
C표준 함수인 fgets(), fgetws()함수가 정상처리되지 못하고 실패했을 때 함수 인자로 전달했던 배열에는 정의되지 않은 값이 할당될 수 있다. 따라서 이후에 문자열을 다루는 함수를 호출할 때 에러를 피하기 위해서는 인자로 사용했던 배열을 다시 초기화해 줄 필요가 있다.]]></ruleDesc>
    <ruleSeverity>Minor</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Safe_Async_Func_In_Signal_Handler</rule>
    <ruleTitle><![CDATA[신호 처리기에서 비동기적으로 안전한 함수만 호출 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약: 신호 처리기 내에서는 비동기적으로 안전한 함수만 호출해야 한다. 일반적으로 신호 처리기 내에서 I/O함수를 호출하는 것은 안전하지 않기 때문에 I/O 함수는 호출하면 안 된다.
<br><br>
신호 처리기 내에서는 비동기적으로 안전한 함수만 호출해야 한다. C표준 라이브러리 함수인 abort(), _Exit(), quick_exit() 및 signal()만 신호 처리기 내에서 안전하게 호출할 수 있다. 구현 환경에 따라 추가적으로 비동기적으로 안전한 함수가 존재할 수 있다. 보통 각 구현 환경에서는 비동기적 안전 함수의 목록을 제공하는데, 이러한 함수들은 신호 처리기 내에서 호출될 수 있다. 일반적으로 신호 처리기 내에서 I/O 함수를 호출하는 것은 안전하지 않다. 프로그래머는 신호 처리기에서 코드를 사용하기 전에 코드가 실행될 모든 함수에 대해 구현 환경에서의 비동기 안전 함수 목록에 포함이 되도록 해야 한다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Use_Arg_as_Str_Ended_With_Null</rule>
    <ruleTitle><![CDATA[널 종료 문자로 끝나지 않은 문자열을 라이브러리 함수 전달 금지]]></ruleTitle>
    <ruleDesc><![CDATA[요약: 널 종료 문자로 끝나지 않는 문자열 인수를 라이브러리 함수에 전달하면 안 된다.
<br><br>
많은 라이브러리 함수들은 널 문자로 끝나는 문자열을 인수로 받는다. 이러한 함수에 널 문자로 끝나지 않는 문자열을 전달하면 객체의 경계를 벗어나 메모리에 접근할 수 있다. 널 종료 문자로 끝나지 않는 문자열 인수를 라이브러리 함수에 전달하면 안 된다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Use_Correct_Byte_Ordering</rule>
    <ruleTitle><![CDATA[시스템 간 데이터 통신 시 올바른 바이트 순서 사용 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 다른 바이트 저장 방식을 사용하는 시스템 간 데이터 통신을 할 때, 전송된 데이터는 최종 사용 전에 자신의 시스템에 맞게 바이트 순서를 확인, 변경해야 한다.<br><br>

아키텍처에 따라 LSB와 MSB 방식으로 데이터를 저장하는 시스템이 나뉜다. 예를 들어, IA-32는 little endian(LSB 먼저)은 방식으로 데이터를 저장하며 PowerPC 및 대부분의 네트워크 프로토콜은 big endian(MSB 먼저) 식으로 데이터를 저장한다. 따라서 IA-32를 사용할 경우에는 네트워크 상으로 메시지를 보내기 전 데이터의 순서를 바꿔야 한다. 네트워크에서 사용하는 바이트 순서는 big endian이기 때문이다. POSIX에서 제공하는 htonl(), htons(), ntohl() 및 ntohs() 함수를 이용하여 바이트 저장 순서를 변경할 수 있다. 따라서 시스템 간 데이터 통신을 할 때는 서로의 시스템에서 사용하는 바이트 순서를 잘 파악하여 적절히 바이트 순서를 바꾼 후 원하는 작업을 수행해야 한다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Use_Correct_Integer_Precision</rule>
    <ruleTitle><![CDATA[정수 타입의 옳은 정밀도 사용 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약: 프로그래머는 적합한 정수 타입의 정밀도(precision)를 코드에서 사용해야 하며, sizeof 연산자를 통해 정수형 타입의 정밀도를 계산하면 안 된다.
<br><br>
C에서 정수형 타입은 크기(size)와 정밀도(precision)를 가지고 있다. 크기는 객체가 사용하는 바이트의 개수를 의미하고 sizeof 연산자를 통해서 확인할 수 있다. 정수형 타입의 정밀도는 값을 나타내는 데 사용하는 비트의 개수를 의미한다. 이때, 부호와 패딩 비트는 제외한다. 패딩 비트는 정밀도와는 무관하며 정수의 크기에만 포함이 된다. 결과적으로, 정수형 타입의 정밀도를 크기로 추측하는 것은 잘못된 추측으로 이어질 확률이 높다. 프로그래머는 옳은 정수 타입의 정밀도를 코드에서 사용해야 하며, sizeof 연산자를 통해 정수형 타입의 정밀도를 계산하면 안 된다.]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Dead Code</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Use_Correctly_Readlink_Func</rule>
    <ruleTitle><![CDATA[readlink() 함수의 올바른 사용 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약: POSIX에서 제공하는 readlink() 함수를 사용할 때 버퍼와 링크의 길이가 동일하면 문자열을 완성하기 위한 NULL 문자 추가 시 버퍼 오버플로우가 발생한다.<br><br>

POSIX에서 제공하는 readlink() 함수는 전달받은 링크가 가리키고 있는 장소를 반환한다. 그러나 반환되는 문자열은 마지막에 널 문자로 종료되지 않는 문자열이다. 따라서 반환되는 문자열의 길이가 링크의 길이와 동일한 상태에서 문자열을 완성하기 위해 버퍼의 마지막 문자에 널 문자를 추가하는 경우 버퍼 오버플로우가 발생하거나 마지막 글자가 덮어쓰게 된다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Use_Decl_Of_Shared_Obj_Between_Thread</rule>
    <ruleTitle><![CDATA[스레드들 사이에 공유하는 객체 선언 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약: 다중 스레드 환경에서 한 스레드의 지역 변수 혹은 스레드의 로컬 객체를 다른 스레드에서 접근하면 안 된다.
<br><br>
하나의 스레드에서 다른 스레드의 지역 혹은 스레드 로컬 변수에 접근하는 것은 구현 환경에 따라 다르며 잘못된 메모리에 접근할 수도 있다. 즉 다른 스레드에서 참조된 스택 프레임 혹은 스레드 로컬 변수를 다른 스레드에서 접근하려 할 때 더 이상 유효하지 않을 수 있다. 공유되는 정적 변수는 스레드 동기화 메커니즘으로부터 보호할 수 있다. 그러나 스레드 간 지역 변수는 같은 방법으로 공유될 수 없다. 참조하고 있는 스택 프레임의 스레드가 실행을 중지해야 하거나 참조된 스택 프레임이 여전히 유효한지 보장해야 하기 때문이다. 따라서 한 스레드의 지역 변수 혹은 스레드 로컬 객체를 다른 스레드에서 접근해서는 안 된다.]]></ruleDesc>
    <ruleSeverity>Major</ruleSeverity>
    <ruleType>Size</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Use_Handling_Standard_Library_Error</rule>
    <ruleTitle><![CDATA[표준 라이브러리 에러 탐지 및 처리 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 표준 라이브러리 함수를 사용할 때 오류 처리 정책에 알맞게 모든 오류를 감지하고 적절하게 처리해야 한다.<br><br>

I/O 함수 및 메모리 할당 함수를 비롯해서 대부분의 표준 라이브러리 함수는 유효한 값 혹은 오류를 나타내는 값을 반환한다. 표준 라이브러리 함수의 모든 호출이 끝나고 오류 표시에 대한 반환 값을 확인하지 않는 것은 오류가 발생할 때 예기치 않은 동작이나 정의되지 않은 동작을 초래할 수 있다. 따라서 프로그램이 오류 처리 정책에 따라 모든 오류를 감지하고 적절하게 처리하는 것이 중요하다.<br>
<table align="center" border="1" class="wrapped confluenceTable tablesorter tablesorter-default stickyTableHeaders">
<tbody>
<tr>
<td><b>함수명</b></td><td><b>반환 값</b></td><td><b>errno 값</b></td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>aligned_alloc()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Pointer to space</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>asctime_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>0</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Nonzero</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>at_quick_exit()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>0</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Nonzero</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>atexit()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>0</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Nonzero</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>bsearch()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Pointer to matching element</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>bsearch_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Pointer to matching element</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>btowc()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Converted wide character</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>WEOF</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>c16rtomb()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Number of bytes</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>(size_t)(-1)</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>c32rtomb()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Number of bytes</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>(size_t)(-1)</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>calloc()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Pointer to space</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>clock()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Processor time</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>(clock_t)(-1)</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>cnd_broadcast()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>thrd_success</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>thrd_error</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>cnd_init()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>thrd_success</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>thrd_nomem</code>&nbsp;or&nbsp;<code>thrd_error</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>cnd_signal()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>thrd_success</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>thrd_error</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>cnd_timedwait()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>thrd_success</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>thrd_timedout</code>&nbsp;or&nbsp;<code>thrd_error</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>cnd_wait()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>thrd_success</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>thrd_error</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>ctime_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>0</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Nonzero</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>fclose()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>0</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>fflush()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>0</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>fgetc()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Character read</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>EOF</code><sup>1</sup></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>fgetpos()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>0</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Nonzero,&nbsp;<code>errno &gt; 0</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>fgets()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Pointer to string</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>fgetwc()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Wide character read</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>WEOF</code><sup>1</sup></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>fopen()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Pointer to stream</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>fopen_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>0</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Nonzero</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>fprintf()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Number of characters (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>fprintf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Number of characters (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>fputc()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Character written</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>EOF</code><sup>2</sup></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>fputs()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Nonnegative</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd" colspan="1"><code>fputwc()</code></td>
<td class="confluenceTd" colspan="1">Wide character written&nbsp;</td>
<td class="confluenceTd" colspan="1"><code>WEOF</code></td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>fputws()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Nonnegative</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>fread()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Elements read</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Elements read</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>freopen()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Pointer to stream</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>freopen_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>0</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Nonzero</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>fscanf()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>fscanf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>fseek()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>0</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Nonzero</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>fsetpos()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>0</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Nonzero,&nbsp;<code>errno &gt; 0</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>ftell()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">File position</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>&minus;1L</code>,&nbsp;<code>errno &gt; 0</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>fwprintf()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Number of wide characters (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>fwprintf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Number of wide characters (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>fwrite()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Elements written</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Elements written</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>fwscanf()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>fwscanf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>getc()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Character read</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>EOF</code><sup>1</sup></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>getchar()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Character read</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>EOF</code><sup>1</sup></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>getenv()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Pointer to string</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>getenv_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Pointer to string</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>gets_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Pointer to string</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>getwc()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Wide character read</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>WEOF</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>getwchar()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Wide character read</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>WEOF</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>gmtime()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Pointer to broken-down time</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>gmtime_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Pointer to broken-down time</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>localtime()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Pointer to broken-down time</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>localtime_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Pointer to broken-down time</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>malloc()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Pointer to space</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>mblen(), s != NULL</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Number of bytes</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>&minus;1</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>mbrlen(), s != NULL</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Number of bytes or status</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>(size_t)(-1)</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>mbrtoc16()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Number of bytes or status</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>(size_t)(-1)</code>,&nbsp;<code>errno == EILSEQ</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>mbrtoc32()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Number of bytes or status</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>(size_t)(-1)</code>,&nbsp;<code>errno == EILSEQ</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>mbrtowc(), s != NULL</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Number of bytes or status</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>(size_t)(-1)</code>,&nbsp;<code>errno == EILSEQ</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>mbsrtowcs()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Number of non-null elements</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>(size_t)(-1)</code>,&nbsp;<code>errno == EILSEQ</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>mbsrtowcs_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>0</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Nonzero</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>mbstowcs()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Number of non-null elements</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>(size_t)(-1)</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>mbstowcs_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>0</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Nonzero</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>mbtowc(), s != NULL</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Number of bytes</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>&minus;1</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>memchr()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Pointer to located character</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>mktime()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Calendar time</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>(time_t)(-1)</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>mtx_init()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>thrd_success</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>thrd_error</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>mtx_lock()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>thrd_success</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>thrd_error</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>mtx_timedlock()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>thrd_success</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>thrd_timedout</code>&nbsp;or&nbsp;<code>thrd_error</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>mtx_trylock()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>thrd_success</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>thrd_busy</code>&nbsp;or&nbsp;<code>thrd_error</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>mtx_unlock()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>thrd_success</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>thrd_error</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>printf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Number of characters (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>putc()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Character written</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>EOF</code><sup>2</sup></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>putwc()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Wide character written</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>WEOF</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>raise()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>0</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Nonzero</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9"><code>realloc()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9">Pointer to space</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>remove()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>0</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Nonzero</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>rename()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>0</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Nonzero</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>scanf()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>scanf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>setlocale()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Pointer to string</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>setvbuf()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>0</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Nonzero</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>signal()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Pointer to previous function</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>SIG_ERR</code>,&nbsp;<code>errno &gt; 0</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>snprintf()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of characters that would be written (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>snprintf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of characters that would be written (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>sprintf()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of non-null characters written</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>sprintf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of non-null characters written</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>sscanf()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>sscanf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>strchr()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Pointer to located character</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>strerror_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>0</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Nonzero</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>strftime()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of non-null characters</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>0</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>strpbrk()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Pointer to located character</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>strrchr()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Pointer to located character</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>strstr()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Pointer to located string</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>strtod()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Converted value</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>0</code>,&nbsp;<code>errno == ERANGE</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>strtof()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Converted value</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>0</code>,&nbsp;<code>errno == ERANGE</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>strtoimax()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Converted value</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>INTMAX_MAX</code>&nbsp;or&nbsp;<code>INTMAX_MIN</code>,&nbsp;<code>errno == ERANGE</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>strtok()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Pointer to first character of a token</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>strtok_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Pointer to first character of a token</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>strtol()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Converted value</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>LONG_MAX</code>&nbsp;or&nbsp;<code>LONG_MIN</code>,&nbsp;<code>errno == ERANGE</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>strtold()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Converted value</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>0, errno == ERANGE</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>strtoll()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Converted value</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>LLONG_MAX</code>&nbsp;or&nbsp;<code>LLONG_MIN</code>,&nbsp;<code>errno == ERANGE</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>strtoul()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Converted value</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>ULONG_MAX</code>,&nbsp;<code>errno == ERANGE</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>strtoull()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Converted value</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>ULLONG_MAX</code>,&nbsp;<code>errno == ERANGE</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>strtoumax()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Converted value</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>UINTMAX_MAX</code>,&nbsp;<code>errno == ERANGE</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>strxfrm()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Length of transformed string</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>&gt;= n</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>swprintf()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of non-null wide characters</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>swprintf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of non-null wide characters</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>swscanf()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>swscanf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>thrd_create()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>thrd_success</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>thrd_nomem</code>&nbsp;or&nbsp;<code>thrd_error</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>thrd_detach()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>thrd_success</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>thrd_error</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>thrd_join()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>thrd_success</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>thrd_error</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>thrd_sleep()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>0</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>time()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Calendar time</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>(time_t)(-1)</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>timespec_get()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Base</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>0</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>tmpfile()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Pointer to stream</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>tmpfile_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>0</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Nonzero</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>tmpnam()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Non-null pointer</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>tmpnam_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>0</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Nonzero</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>tss_create()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>thrd_success</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>thrd_error</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>tss_get()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Value of thread-specific storage</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>0</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>tss_set()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>thrd_success</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>thrd_error</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>ungetc()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Character pushed back</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>EOF</code>&nbsp;(see&nbsp;below)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>ungetwc()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Character pushed back</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>WEOF</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vfprintf()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of characters (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vfprintf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of characters (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vfscanf()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vfscanf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vfwprintf()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of wide characters (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vfwprintf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of wide characters (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vfwscanf()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vfwscanf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vprintf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of characters (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vscanf()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vscanf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vsnprintf()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of characters that would be written (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vsnprintf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of characters that would be written (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vsprintf()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of non-null characters (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vsprintf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of non-null characters (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vsscanf()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vsscanf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vswprintf()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of non-null wide characters</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vswprintf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of non-null wide characters</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vswscanf()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vswscanf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vwprintf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of wide characters (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vwscanf()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>vwscanf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wcrtomb()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of bytes stored</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>(size_t)(-1)</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wcschr()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Pointer to located wide character</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wcsftime()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of non-null wide characters</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>0</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wcspbrk()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Pointer to located wide character</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wcsrchr()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Pointer to located wide character</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wcsrtombs()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of non-null bytes</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>(size_t)(-1)</code>,&nbsp;<code>errno == EILSEQ</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wcsrtombs_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>0</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Nonzero</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wcsstr()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Pointer to located wide string</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wcstod()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Converted value</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>0</code>,&nbsp;<code>errno == ERANGE</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wcstof()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Converted value</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>0</code>,&nbsp;<code>errno == ERANGE</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wcstoimax()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Converted value</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>INTMAX_MAX</code>&nbsp;or&nbsp;<code>INTMAX_MIN</code>,&nbsp;<code>errno == ERANGE</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wcstok()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Pointer to first wide character of a token</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wcstok_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Pointer to first wide character of a token</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wcstol()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Converted value</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>LONG_MAX</code>&nbsp;or&nbsp;<code>LONG_MIN</code>,&nbsp;<code>errno == ERANGE</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wcstold()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Converted value</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>0</code>,&nbsp;<code>errno == ERANGE</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wcstoll()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Converted value</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>LLONG_MAX</code>&nbsp;or&nbsp;<code>LLONG_MIN</code>,&nbsp;<code>errno == ERANGE</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wcstombs()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of non-null bytes</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>(size_t)(-1)</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wcstombs_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>0</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Nonzero</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wcstoul()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Converted value</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>ULONG_MAX</code>,&nbsp;<code>errno == ERANGE</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wcstoull()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Converted value</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>ULLONG_MAX</code>,&nbsp;<code>errno == ERANGE</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wcstoumax()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Converted value</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>UINTMAX_MAX</code>,&nbsp;<code>errno == ERANGE</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wcsxfrm()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Length of transformed wide string</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>&gt;= n</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wctob()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Converted character</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>EOF</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wctomb(), s != NULL</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of bytes stored</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>&minus;1</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wctomb_s(), s != NULL</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of bytes stored</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>&minus;1</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wctrans()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Valid argument to<code>&nbsp;towctrans</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>0</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wctype()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Valid argument to<code>&nbsp;iswctype</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>0</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wmemchr()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Pointer to located wide character</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>NULL</code></p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wprintf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of wide characters (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Negative</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wscanf()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
<tr>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>wscanf_s()</code></p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left">Number of conversions (nonnegative)</p>
</td>
<td class="confluenceTd">
<p class="Tabletext9" align="left"><code>EOF</code>&nbsp;(negative)</p>
</td>
</tr>
</tbody>
</table>]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Use_Return_Value_Except_For_Void_Type</rule>
    <ruleTitle><![CDATA[void 반환 타입 이외의 함수들 모두 반환 필요 ]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : void 반환 타입 이외의 함수들은 모두 “}” 중괄호 전에 return 명령어를 사용해서 반환 값을 정의해야 한다.<br><br>

void 반환 타입 이외의 함수들은 모두 “}” 중괄호 전에 return 명령어를 사용해서 반환 값을 정의해야 한다. void 반환 타입 이외의 함수가 반환 값이 정해져 있지 않다면 정의되지 않은 동작이 발생한다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Use_Sufficient_Space_Str_With_Null</rule>
    <ruleTitle><![CDATA[문자열 데이터와 널 종료 문자를 담을 충분한 공간 보유 보장]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 문자열을 자르거나 복사하는 문자열 공간이 널(null) 종료 문자를 포함하여 충분한 공간을 가지고 있음을 보장해야 한다.<br><br>

데이터를 충분하지 않은 공간에 복사하는 것은 버퍼 오버플로우로 이어진다. 문자열을 다룰 때, 버퍼 오버플로우는 종종 일어난다. 이런 에러를 방지하기 위해서는, 문자열을 자르거나 복사하는 문자열 공간이 널 종료 문자를 포함하여 충분한 공간을 가지고 있음을 보장해야 한다. 또한, 문자열이 힙에 배치되어 있을 때는 객체를 위한 메모리는 충분히 할당되어 있어야 한다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Use_Unsigned_Char_As_Arg_in_Str_Func</rule>
    <ruleTitle><![CDATA[문자를 다루는 함수들의 인수를 unsigned char 로 전달 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : <ctype.h> 헤더 파일에서 제공하는 유용한 여러 함수들(문자 분류, 매핑 관련)의 인수는 반드시 unsigned char로 전달되어야 한다.<br><br>

C표준에 따르면 <ctype.h> 헤더는 문자를 분류하거나 매핑하는데 유용한 여러 함수를 제공한다. 이런 함수들의 인수는 정수형 타입이며 값은 unsigned char로 표현될 수 있거나 매크로 EOF의 값과 같아야 한다. 만약 인수가 이러한 규칙을 따르지 않으면, 정의되지 않은 동작을 야기할 수 있다. 이 규칙은 char 데이터 유형이 signed char와 동일한 범위, 표현 및 동작을 가지도록 정의된 플랫폼에서 실행되는 코드에만 적용된다. 다음은 이 규칙이 다루는 함수이다.
isalnum() isalpha() isascii()-XSI isblank()
iscntrl() isdigit() isgraph() islower()
isprint() ispunct() isspace() isupper()
isxdigit() toascii()-XSI toupper() tolower()]]></ruleDesc>
    <ruleSeverity>Trivial</ruleSeverity>
    <ruleType>Potential Error</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Use_Valid_Grammer_Declaring_Dyn_Arr</rule>
    <ruleTitle><![CDATA[가변 배열 선언 시 올바른 문법 사용 필요]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : C언어에서는 가변 배열 멤버를 선언할 때, 올바른 구문을 사용해야 한다.
<br><br>
- 가변 배열 멤버는 하나 이상의 멤버가 있는 구조체에서 마지막 요소에 불완전한 배열 타입이 있는 형태이다. 즉, 배열의 크기가 구조체 내에서 명시적으로 지정되지 않는다. 이러한 구조는 실제로 많이 사용되고 있으며 다양한 컴파일러에 의해 지원되고 있다. 이때, 가변 배열 멤버를 선언할 때는 유효한 구문을 사용해야 한다. 가변 배열 멤버를 갖는 구조체는 다음과 같은 요구 조건을 따라야 한다.
1. 완전하지 않은 배열 타입은 구조체의 맨 마지막에 선언되어야 한다.
2. 가변 배열 멤버를 갖는 구조체가 배열로써 사용되면 안 된다.
3. 가변 배열 멤버를 포함하는 구조체는 다른 구조체의 멤버로서 사용될 수 없다.
4. 구조체는 가변 배열 멤버를 제외하고 하나 이상의 이름이 있는 멤버를 가지고 있어야 한다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <ruleInfo>
    <ruleSetName>Suresoft_C_Secure_Coding</ruleSetName>
    <ruleSetDesc><![CDATA[Ruleset for C Secure Coding by Suresoft.]]></ruleSetDesc>
    <rule>SC_Use_Valid_Range_Arg_For_Dyn_Arr</rule>
    <ruleTitle><![CDATA[가변 길이 배열의 크기 인수가 유효한 범위 내에 있다는 것을 보장]]></ruleTitle>
    <ruleDesc><![CDATA[요약 : 가변 길이의 크기 인수가 양의 정수 값이 아니거나 인수의 크기가 매우 커지면 정의되지 않은 동작을 야기할 수 있다.<br><br>

가변 길이 배열(VLA)은 정수형 표현으로 배열의 크기를 결정하지 않는 것을 제외하면 본질적으로 기존 C 배열과 동일하다. 가변 길이 배열은 정수 표현식 크기와 가변 길이 배열의 선언이 런타임 시에 결정된다. 만약 가변 길이에 해당하는 크기 인수가 양의 정수 값이 아니면 정의되지 않은 동작을 야기한다. 또한 인수의 크기가 매우 커지는 경우, 정의되지 않은 동작을 야기할 수 있다. 공격자는 이러한 동작들을 이용하여 프로그램의 중요한 데이터를 덮어 쓸 수 있다. 프로그래머는 가변 길이 배열에 대한 크기 인수, 특히 신뢰할 수 없는 데이터에서 파행된 인수가 유효한 범위 내에 있는지 확인해야 한다. 가변 길이 배열은 C11에서 조건적으로 지원되는 기능이므로 이식 가능한 코드에서 사용할 때는 _STDC_NO_VLA_ 매크로로 테스트해야 한다. 구현 환경이 가변 길이 배열을 지원하는지 여부를 판단하는 방법은 _STDC_NO_VLA_ 매크로가 상수 정수 1로 세팅되어 있는지 확인하여 알 수 있다.]]></ruleDesc>
    <ruleSeverity>Critical</ruleSeverity>
    <ruleType>Others</ruleType>
    <kindScope>CODING_RULE</kindScope>
  </ruleInfo>
  <bug>
    <violationHash>297969500945368511015888082778474880646</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>5</startLine>
    <endLine>5</endLine>
    <rule>MSC34_C</rule>
    <ruleTitle><![CDATA[사용이 권장되지 않거나 구형의 함수 사용 금지 ]]></ruleTitle>
    <level>Other</level>
    <content><![CDATA[함수 printf 대신 printf_s의 사용을 권장함]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>248</templateId>
  </bug>
  <bug>
    <violationHash>160406149086029518055312029406538443884</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function/>
    <startLine>1</startLine>
    <endLine>1</endLine>
    <rule>MISRA_C_2012_DIR_01_01</rule>
    <ruleTitle><![CDATA[프로그램의 산출 결과와 관련된 implementation-defined behavior는 문서화되고 이해할 수 있어야 함]]></ruleTitle>
    <level>Other</level>
    <content><![CDATA[implementation-defined behavior 항목(Floating-point 타입의 값의 범위, 정확도)에 대해 문서화가 되어있는지 확인해야 함]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>802</templateId>
  </bug>
  <bug>
    <violationHash>977574819414489368217381390013624696090</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>3</startLine>
    <endLine>3</endLine>
    <rule>KEPCO_NUREG_050</rule>
    <ruleTitle><![CDATA[Basic numerical type 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
    <level>Major</level>
    <content><![CDATA[int basic type 이 사용되었음 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>17</templateId>
  </bug>
  <bug>
    <violationHash>364764202792032242815958371990125409068</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function/>
    <startLine>1</startLine>
    <endLine>1</endLine>
    <rule>MISRA_C_2012_DIR_01_01</rule>
    <ruleTitle><![CDATA[프로그램의 산출 결과와 관련된 implementation-defined behavior는 문서화되고 이해할 수 있어야 함]]></ruleTitle>
    <level>Other</level>
    <content><![CDATA[implementation-defined behavior 항목(언더플로우, 오버플로우, NaNs에서의 동작)에 대해 문서화가 되어있는지 확인해야 함]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>802</templateId>
  </bug>
  <bug>
    <violationHash>61291616474285794571636455178605022263</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>3</startLine>
    <endLine>3</endLine>
    <rule>MISRA_CPP_07_01_01</rule>
    <ruleTitle><![CDATA[값이 변경되지 않는 변수는 const로 선언되어야 함 ]]></ruleTitle>
    <level>Major</level>
    <content><![CDATA[변수 argv의 값이 변경되지 않음에도 const로 선언되어 있지 않음 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>559</templateId>
  </bug>
  <bug>
    <violationHash>148662065379052659715262717082529906968</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function/>
    <startLine>1</startLine>
    <endLine>1</endLine>
    <rule>MISRA_C_2012_21_06</rule>
    <ruleTitle><![CDATA[표준 입출력 함수 사용 금지]]></ruleTitle>
    <level>Major</level>
    <content><![CDATA[stdio.h는 include가 금지된 파일임 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>136;137;748</templateId>
  </bug>
  <bug>
    <violationHash>1671359185606186531013212005078485168822</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>3</startLine>
    <endLine>3</endLine>
    <rule>KEPCO_NUREG_050</rule>
    <ruleTitle><![CDATA[Basic numerical type 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
    <level>Major</level>
    <content><![CDATA[char basic type 이 사용되었음 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>17</templateId>
  </bug>
  <bug>
    <violationHash>714845838712607249916257233921442137539</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>5</startLine>
    <endLine>5</endLine>
    <rule>KEPCO_KCWE_04_03</rule>
    <ruleTitle><![CDATA[적절하지 않은 예외처리 ]]></ruleTitle>
    <level>Major</level>
    <content><![CDATA[반환 타입이 void가 아닌 함수 printf의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>102;182;248;175</templateId>
  </bug>
  <bug>
    <violationHash>22808349122367923538482939551233042460</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>5</startLine>
    <endLine>5</endLine>
    <rule>KEPCO_CWE-391</rule>
    <ruleTitle><![CDATA[오류 검증 여부 검사 ]]></ruleTitle>
    <level>Trivial</level>
    <content><![CDATA[함수 printf의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주 안 함) ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>182</templateId>
  </bug>
  <bug>
    <violationHash>75440345557937433158668518147990998321</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>5</startLine>
    <endLine>5</endLine>
    <rule>CWE-391</rule>
    <ruleTitle><![CDATA[오류 검증 여부 검사 ]]></ruleTitle>
    <level>Trivial</level>
    <content><![CDATA[함수 printf의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주 안 함) ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>182</templateId>
  </bug>
  <bug>
    <violationHash>5071053503539182212030214506668957995</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>5</startLine>
    <endLine>5</endLine>
    <rule>KEPCO_EXP12_C</rule>
    <ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
    <level>Major</level>
    <content><![CDATA[반환 타입이 void가 아닌 함수 printf 호출의 결과값이 사용되지 않았음 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>175</templateId>
  </bug>
  <bug>
    <violationHash>119855870319050227048262288763456510965</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>3</startLine>
    <endLine>3</endLine>
    <rule>IEC61508_C.2.9_03</rule>
    <ruleTitle><![CDATA[함수의 파라미터는 함수와 연관된 것만 선언되었는지 검사 ]]></ruleTitle>
    <level>Minor</level>
    <content><![CDATA[파라미터 argc 가 함수 안에서 사용되지 않았음 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>296</templateId>
  </bug>
  <bug>
    <violationHash>147450239980615057082840115936870384864</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>5</startLine>
    <endLine>5</endLine>
    <rule>KEPCO_MSC34_C</rule>
    <ruleTitle><![CDATA[사용이 권장되지 않거나 구형의 함수 사용 금지 ]]></ruleTitle>
    <level>Other</level>
    <content><![CDATA[함수 printf 대신 printf_s의 사용을 권장함]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>248</templateId>
  </bug>
  <bug>
    <violationHash>32945550129797812373426850757007053663</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>3</startLine>
    <endLine>3</endLine>
    <rule>MISRA_CPP_07_01_02</rule>
    <ruleTitle><![CDATA[포인터, 참조형 파라미터는 그 객체의 값이 변경되지 않는 경우 const 타입 객체를 가리켜야 함 ]]></ruleTitle>
    <level>Major</level>
    <content><![CDATA[참조형 변수 argv의 **argv 값이 변경되지 않음에도 const로 선언되어 있지 않음 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>560</templateId>
  </bug>
  <bug>
    <violationHash>1764392739676889866410164953227713036734</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>3</startLine>
    <endLine>3</endLine>
    <rule>IEC62279_B.15_02</rule>
    <ruleTitle><![CDATA[함수의 모든 파라메터가 읽기 전용인지 검사 ]]></ruleTitle>
    <level>Trivial</level>
    <content><![CDATA[함수의 parameter가 const 가 아님 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>309;302</templateId>
  </bug>
  <bug>
    <violationHash>65576019511167847415502573524930467763</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function/>
    <startLine>1</startLine>
    <endLine>1</endLine>
    <rule>MISRA_C_2012_DIR_01_01</rule>
    <ruleTitle><![CDATA[프로그램의 산출 결과와 관련된 implementation-defined behavior는 문서화되고 이해할 수 있어야 함]]></ruleTitle>
    <level>Other</level>
    <content><![CDATA[implementation-defined behavior 항목(특정 표준라이브러리가 사용될 때 errno로의 값 할당 여부)에 대해 문서화가 되어있는지 확인해야 함]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>802</templateId>
  </bug>
  <bug>
    <violationHash>1043085771450531702017832921097275873160</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function/>
    <startLine>1</startLine>
    <endLine>1</endLine>
    <rule>MISRA_20_09</rule>
    <ruleTitle><![CDATA[입/출력 라이브러리인 stdio.h 는 제품 코드에서 사용 금지 ]]></ruleTitle>
    <level>Major</level>
    <content><![CDATA[stdio.h는 include가 금지된 파일임 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>136;137</templateId>
  </bug>
  <bug>
    <violationHash>16621894408810577327677346008204735792</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>5</startLine>
    <endLine>5</endLine>
    <rule>MISRA_C_2012_21_06</rule>
    <ruleTitle><![CDATA[표준 입출력 함수 사용 금지]]></ruleTitle>
    <level>Major</level>
    <content><![CDATA[printf는 사용이 금지된 함수임 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>136;137;748</templateId>
  </bug>
  <bug>
    <violationHash>1251424991107489139213992246573487581659</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>3</startLine>
    <endLine>3</endLine>
    <rule>MISRA_CPP_07_01_02</rule>
    <ruleTitle><![CDATA[포인터, 참조형 파라미터는 그 객체의 값이 변경되지 않는 경우 const 타입 객체를 가리켜야 함 ]]></ruleTitle>
    <level>Major</level>
    <content><![CDATA[참조형 변수 argv의 *argv 값이 변경되지 않음에도 const로 선언되어 있지 않음 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>560</templateId>
  </bug>
  <bug>
    <violationHash>69478992882973582827840404641414888305</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function/>
    <startLine>1</startLine>
    <endLine>1</endLine>
    <rule>MISRA_C_2012_DIR_01_01</rule>
    <ruleTitle><![CDATA[프로그램의 산출 결과와 관련된 implementation-defined behavior는 문서화되고 이해할 수 있어야 함]]></ruleTitle>
    <level>Other</level>
    <content><![CDATA[implementation-defined behavior 항목(어떤방식으로 #include가 파일 이름과 호스트 파일 시스템의 위치에 매핑되는가)에 대해 문서화가 되어있는지 확인해야 함]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>802</templateId>
  </bug>
  <bug>
    <violationHash>31560655684161747205300581509815554643</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>5</startLine>
    <endLine>5</endLine>
    <rule>EXP12_C</rule>
    <ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
    <level>Major</level>
    <content><![CDATA[반환 타입이 void가 아닌 함수 printf 호출의 결과값이 사용되지 않았음 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>175</templateId>
  </bug>
  <bug>
    <violationHash>127212485278751323622546714275286344518</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>3</startLine>
    <endLine>3</endLine>
    <rule>MISRA_06_03</rule>
    <ruleTitle><![CDATA[기본 타입 대신 typedef 로 재정의되어 크기와 부호를 알 수 있는 타입을 사용해야 함]]></ruleTitle>
    <level>Minor</level>
    <content><![CDATA[int basic type 이 사용되었음 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>144;17</templateId>
  </bug>
  <bug>
    <violationHash>182804266642393342624522142256060686621</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>5</startLine>
    <endLine>5</endLine>
    <rule>KEPCO_CWE-754</rule>
    <ruleTitle><![CDATA[비정상적이거나 예외적인 조건에 대해 잘못된 검증이 발생하는지 검사 ]]></ruleTitle>
    <level>Minor</level>
    <content><![CDATA[반환 타입이 void가 아닌 함수 printf 호출의 결과값이 사용되지 않았음 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>182;248;175</templateId>
  </bug>
  <bug>
    <violationHash>512772492376503085011956757528345811747</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function/>
    <startLine>1</startLine>
    <endLine>1</endLine>
    <rule>MISRA_C_2012_DIR_01_01</rule>
    <ruleTitle><![CDATA[프로그램의 산출 결과와 관련된 implementation-defined behavior는 문서화되고 이해할 수 있어야 함]]></ruleTitle>
    <level>Other</level>
    <content><![CDATA[implementation-defined behavior 항목(확장여부(_Pragma 연산자 또는 새로운 키워드))에 대해 문서화가 되어있는지 확인해야 함]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>802</templateId>
  </bug>
  <bug>
    <violationHash>1448937066495697773380406326250318502</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>5</startLine>
    <endLine>5</endLine>
    <rule>MISRA_16_10</rule>
    <ruleTitle><![CDATA[만약 함수가 에러 정보를 반환한다면, 반환된 에러 정보는 검사되어야 함 ]]></ruleTitle>
    <level>Major</level>
    <content><![CDATA[반환 타입이 void가 아닌 함수 printf의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>102</templateId>
  </bug>
  <bug>
    <violationHash>885206630075037873715927659166859104837</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>3</startLine>
    <endLine>3</endLine>
    <rule>MISRA_CPP_00_01_11</rule>
    <ruleTitle><![CDATA[가상 함수가 아닌 함수에서 미사용 파라미터 선언 금지 ]]></ruleTitle>
    <level>Major</level>
    <content><![CDATA[파라미터 argc 가 함수 안에서 사용되지 않았음 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>296</templateId>
  </bug>
  <bug>
    <violationHash>57226803186140910242081009538703311749</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function/>
    <startLine>1</startLine>
    <endLine>1</endLine>
    <rule>MISRA_C_2012_DIR_01_01</rule>
    <ruleTitle><![CDATA[프로그램의 산출 결과와 관련된 implementation-defined behavior는 문서화되고 이해할 수 있어야 함]]></ruleTitle>
    <level>Other</level>
    <content><![CDATA[implementation-defined behavior 항목(Floating-point 연산 시 도메인 및 범위 오류 발생한 경우, 라이브러리 함수의 동작)에 대해 문서화가 되어있는지 확인해야 함]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>802</templateId>
  </bug>
  <bug>
    <violationHash>28876888395502357557136672952867981695</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>3</startLine>
    <endLine>3</endLine>
    <rule>MISRA_C_2012_02_07</rule>
    <ruleTitle><![CDATA[함수에서 사용되지 않은 파라미터는 없어야 함]]></ruleTitle>
    <level>Minor</level>
    <content><![CDATA[파라미터 argc 가 함수 안에서 사용되지 않았음 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>296</templateId>
  </bug>
  <bug>
    <violationHash>8801954540290066117759371109401932977</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>5</startLine>
    <endLine>5</endLine>
    <rule>IEC62279_B.15_04</rule>
    <ruleTitle><![CDATA[함수의 반환값이 검증되었는지 검사 (함수 호출 인자로 사용된 경우 검증으로 간주 안함) ]]></ruleTitle>
    <level>Trivial</level>
    <content><![CDATA[함수 printf의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주 안함) ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>323</templateId>
  </bug>
  <bug>
    <violationHash>660992542448627068215249197111720106880</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function/>
    <startLine>1</startLine>
    <endLine>1</endLine>
    <rule>MISRA_C_2012_DIR_01_01</rule>
    <ruleTitle><![CDATA[프로그램의 산출 결과와 관련된 implementation-defined behavior는 문서화되고 이해할 수 있어야 함]]></ruleTitle>
    <level>Other</level>
    <content><![CDATA[implementation-defined behavior 항목(main 함수의 타입)에 대해 문서화가 되어있는지 확인해야 함]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>802</templateId>
  </bug>
  <bug>
    <violationHash>17409884594244102113377833567151663857</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>3</startLine>
    <endLine>3</endLine>
    <rule>MISRA_CPP_03_09_02</rule>
    <ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
    <level>Minor</level>
    <content><![CDATA[int basic type 이 사용되었음 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>144;17</templateId>
  </bug>
  <bug>
    <violationHash>39499052635633465711334780277554645037</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function/>
    <startLine>1</startLine>
    <endLine>1</endLine>
    <rule>MISRA_C_2012_DIR_01_01</rule>
    <ruleTitle><![CDATA[프로그램의 산출 결과와 관련된 implementation-defined behavior는 문서화되고 이해할 수 있어야 함]]></ruleTitle>
    <level>Other</level>
    <content><![CDATA[implementation-defined behavior 항목(소스문자집합(Source Character Set)과 실행문자집합(Execution Character Set))에 대해 문서화가 되어있는지 확인해야 함]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>802</templateId>
  </bug>
  <bug>
    <violationHash>49769339589166069882253987499468410322</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>3</startLine>
    <endLine>3</endLine>
    <rule>MISRA_06_03</rule>
    <ruleTitle><![CDATA[기본 타입 대신 typedef 로 재정의되어 크기와 부호를 알 수 있는 타입을 사용해야 함]]></ruleTitle>
    <level>Minor</level>
    <content><![CDATA[char basic type 이 사용되었음 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>144;17</templateId>
  </bug>
  <bug>
    <violationHash>1455680184075763524517754432537536103868</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function/>
    <startLine>1</startLine>
    <endLine>1</endLine>
    <rule>MISRA_C_2012_DIR_01_01</rule>
    <ruleTitle><![CDATA[프로그램의 산출 결과와 관련된 implementation-defined behavior는 문서화되고 이해할 수 있어야 함]]></ruleTitle>
    <level>Other</level>
    <content><![CDATA[implementation-defined behavior 항목(Floating-point 소수점 연산 시 반올림의 방향)에 대해 문서화가 되어있는지 확인해야 함]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>802</templateId>
  </bug>
  <bug>
    <violationHash>1228471896820181440713388646717475879161</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function/>
    <startLine>1</startLine>
    <endLine>1</endLine>
    <rule>CSC_ETC_04</rule>
    <ruleTitle><![CDATA[파일의 제일 앞에는 comment가 있어야 함 ]]></ruleTitle>
    <level>Minor</level>
    <content><![CDATA[파일의 제일 앞이 지정된 형식의 comment 가 아님 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>306</templateId>
  </bug>
  <bug>
    <violationHash>1502788191892892275710764318586968821244</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function/>
    <startLine>1</startLine>
    <endLine>1</endLine>
    <rule>MISRA_C_2012_DIR_01_01</rule>
    <ruleTitle><![CDATA[프로그램의 산출 결과와 관련된 implementation-defined behavior는 문서화되고 이해할 수 있어야 함]]></ruleTitle>
    <level>Other</level>
    <content><![CDATA[implementation-defined behavior 항목(코드 번역 시 출력된 진단 메세지의 식별방법)에 대해 문서화가 되어있는지 확인해야 함]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>802</templateId>
  </bug>
  <bug>
    <violationHash>145541964518982736143276811541394783379</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>3</startLine>
    <endLine>3</endLine>
    <rule>MISRA_CPP_03_09_02</rule>
    <ruleTitle><![CDATA[기본 숫자 타입 대신 크기와 부호를 나타내는 typedef를 사용해야 함 ]]></ruleTitle>
    <level>Minor</level>
    <content><![CDATA[char basic type 이 사용되었음 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>144;17</templateId>
  </bug>
  <bug>
    <violationHash>1059289664616719960216161887612628165737</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>5</startLine>
    <endLine>5</endLine>
    <rule>KEPCO_FIO04_C</rule>
    <ruleTitle><![CDATA[입출력 함수의 성공 또는 실패 여부를 나타내는 반환값이 검증되었는지 검사 ]]></ruleTitle>
    <level>Other</level>
    <content><![CDATA[함수 printf의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주 안 함) ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>182</templateId>
  </bug>
  <bug>
    <violationHash>1631328885309815711811353768352201360777</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>5</startLine>
    <endLine>5</endLine>
    <rule>MISRA_C_2012_17_07</rule>
    <ruleTitle><![CDATA[리턴 타입이 void가 아닌 함수의 리턴 값은 필히 사용해야 함]]></ruleTitle>
    <level>Major</level>
    <content><![CDATA[반환 타입이 void가 아닌 함수 printf의 호출 결과 값이 사용 또는 저장되지 않았음. ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>102</templateId>
  </bug>
  <bug>
    <violationHash>964403011334189930114014944013330023968</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function/>
    <startLine>1</startLine>
    <endLine>1</endLine>
    <rule>MISRA_C_2012_DIR_01_01</rule>
    <ruleTitle><![CDATA[프로그램의 산출 결과와 관련된 implementation-defined behavior는 문서화되고 이해할 수 있어야 함]]></ruleTitle>
    <level>Other</level>
    <content><![CDATA[implementation-defined behavior 항목(integer 타입의 크기)에 대해 문서화가 되어있는지 확인해야 함]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>802</templateId>
  </bug>
  <bug>
    <violationHash>114020849152179470889600708509353409161</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>5</startLine>
    <endLine>5</endLine>
    <rule>FIO04_C</rule>
    <ruleTitle><![CDATA[입출력 함수의 성공 또는 실패 여부를 나타내는 반환값이 검증되었는지 검사 ]]></ruleTitle>
    <level>Other</level>
    <content><![CDATA[함수 printf의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주 안 함) ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>182</templateId>
  </bug>
  <bug>
    <violationHash>68877933169918059307453726097234841764</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>5</startLine>
    <endLine>5</endLine>
    <rule>MISRA_CPP_00_03_02</rule>
    <ruleTitle><![CDATA[함수의 에러 정보 확인 필요 ]]></ruleTitle>
    <level>Major</level>
    <content><![CDATA[함수 printf의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주) ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>274</templateId>
  </bug>
  <bug>
    <violationHash>1836832307679231166613802263686675609142</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>5</startLine>
    <endLine>5</endLine>
    <rule>MISRA_CPP_00_01_07</rule>
    <ruleTitle><![CDATA[함수 반환 값 미사용 금지 ]]></ruleTitle>
    <level>Major</level>
    <content><![CDATA[반환 타입이 void가 아닌 함수 printf 호출의 결과값이 사용되지 않았음 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>175</templateId>
  </bug>
  <bug>
    <violationHash>38492815518931583053486122346267142901</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>5</startLine>
    <endLine>5</endLine>
    <rule>KEPCO_NUREG_081</rule>
    <ruleTitle><![CDATA[indentation 규칙 ]]></ruleTitle>
    <level>Minor</level>
    <content><![CDATA[문장의 의미적인 depth에 따른 들여쓰기(indentation)를 준수하지 않았음. ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>368</templateId>
  </bug>
  <bug>
    <violationHash>100788678070245939625891428744935360010</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>3</startLine>
    <endLine>3</endLine>
    <rule>MISRA_CPP_00_01_11</rule>
    <ruleTitle><![CDATA[가상 함수가 아닌 함수에서 미사용 파라미터 선언 금지 ]]></ruleTitle>
    <level>Major</level>
    <content><![CDATA[파라미터 argv 가 함수 안에서 사용되지 않았음 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>296</templateId>
  </bug>
  <bug>
    <violationHash>519012149317102647714830323736649688309</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>3</startLine>
    <endLine>3</endLine>
    <rule>MISRA_C_2012_02_07</rule>
    <ruleTitle><![CDATA[함수에서 사용되지 않은 파라미터는 없어야 함]]></ruleTitle>
    <level>Minor</level>
    <content><![CDATA[파라미터 argv 가 함수 안에서 사용되지 않았음 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>296</templateId>
  </bug>
  <bug>
    <violationHash>1101734516308963311015028598393975487863</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>5</startLine>
    <endLine>5</endLine>
    <rule>CWE-754</rule>
    <ruleTitle><![CDATA[비정상적이거나 예외적인 조건에 대해 잘못된 검증이 발생하는지 검사 ]]></ruleTitle>
    <level>Minor</level>
    <content><![CDATA[반환 타입이 void가 아닌 함수 printf 호출의 결과값이 사용되지 않았음 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>182;248;175</templateId>
  </bug>
  <bug>
    <violationHash>671853097474174414113814205464980926176</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>5</startLine>
    <endLine>5</endLine>
    <rule>MISRA_20_09</rule>
    <ruleTitle><![CDATA[입/출력 라이브러리인 stdio.h 는 제품 코드에서 사용 금지 ]]></ruleTitle>
    <level>Major</level>
    <content><![CDATA[printf는 사용이 금지된 함수임 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>136;137</templateId>
  </bug>
  <bug>
    <violationHash>597390354315689871015471917080110068498</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function/>
    <startLine>1</startLine>
    <endLine>1</endLine>
    <rule>MISRA_C_2012_DIR_01_01</rule>
    <ruleTitle><![CDATA[프로그램의 산출 결과와 관련된 implementation-defined behavior는 문서화되고 이해할 수 있어야 함]]></ruleTitle>
    <level>Other</level>
    <content><![CDATA[implementation-defined behavior 항목(정수 나눗셈 수행 시 나머지연산의 반올림 방향(올림, 내림, 반올림))에 대해 문서화가 되어있는지 확인해야 함]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>802</templateId>
  </bug>
  <bug>
    <violationHash>78644481261025060625745859397325869699</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>5</startLine>
    <endLine>5</endLine>
    <rule>KEPCO_KCWE_04_03</rule>
    <ruleTitle><![CDATA[적절하지 않은 예외처리 ]]></ruleTitle>
    <level>Major</level>
    <content><![CDATA[반환 타입이 void가 아닌 함수 printf 호출의 결과값이 사용되지 않았음 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>102;182;248;175</templateId>
  </bug>
  <bug>
    <violationHash>158908033403164691407141458193356245918</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <startLine>3</startLine>
    <endLine>3</endLine>
    <rule>IEC61508_C.2.9_03</rule>
    <ruleTitle><![CDATA[함수의 파라미터는 함수와 연관된 것만 선언되었는지 검사 ]]></ruleTitle>
    <level>Minor</level>
    <content><![CDATA[파라미터 argv 가 함수 안에서 사용되지 않았음 ]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>296</templateId>
  </bug>
  <bug>
    <violationHash>614690536230009924212641353315245374661</violationHash>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function/>
    <startLine>1</startLine>
    <endLine>1</endLine>
    <rule>MISRA_C_2012_DIR_01_01</rule>
    <ruleTitle><![CDATA[프로그램의 산출 결과와 관련된 implementation-defined behavior는 문서화되고 이해할 수 있어야 함]]></ruleTitle>
    <level>Other</level>
    <content><![CDATA[implementation-defined behavior 항목(식별자에서 구분 가능한 character의 개수)에 대해 문서화가 되어있는지 확인해야 함]]></content>
    <suppression>false</suppression>
    <suppressionDesc/>
    <confidence>None</confidence>
    <status>Open</status>
    <templateId>802</templateId>
  </bug>
  <functionMetric>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <function><![CDATA[main(signed int, char **)]]></function>
    <functionStartLine>3</functionStartLine>
    <functionEndLine>7</functionEndLine>
    <FUNST>2.0</FUNST>
    <FUNST_suppression>false</FUNST_suppression>
    <FUNST_suppressionDesc/>
    <FUCYC>1.0</FUCYC>
    <FUCYC_suppression>false</FUCYC_suppression>
    <FUCYC_suppressionDesc/>
    <FUMCYC>1.0</FUMCYC>
    <FUMCYC_suppression>false</FUMCYC_suppression>
    <FUMCYC_suppressionDesc/>
    <FUMNC>0.0</FUMNC>
    <FUMNC_suppression>false</FUMNC_suppression>
    <FUMNC_suppressionDesc/>
    <FUMIV>0.0</FUMIV>
    <FUMIV_suppression>false</FUMIV_suppression>
    <FUMIV_suppressionDesc/>
    <FUNSP>1.0</FUNSP>
    <FUNSP_suppression>false</FUNSP_suppression>
    <FUNSP_suppressionDesc/>
    <FUNCR>NaN</FUNCR>
    <FUNCR_suppression>false</FUNCR_suppression>
    <FUNCR_suppressionDesc/>
    <FUNDC>1.0</FUNDC>
    <FUNDC_suppression>false</FUNDC_suppression>
    <FUNDC_suppressionDesc/>
    <FUNCE>1.0</FUNCE>
    <FUNCE_suppression>false</FUNCE_suppression>
    <FUNCE_suppressionDesc/>
    <FUNPA>2.0</FUNPA>
    <FUNPA_suppression>false</FUNPA_suppression>
    <FUNPA_suppressionDesc/>
    <FUNGS>0.0</FUNGS>
    <FUNGS_suppression>false</FUNGS_suppression>
    <FUNGS_suppressionDesc/>
    <FUNRP>1.0</FUNRP>
    <FUNRP_suppression>false</FUNRP_suppression>
    <FUNRP_suppressionDesc/>
    <FUNDM>0.0</FUNDM>
    <FUNDM_suppression>false</FUNDM_suppression>
    <FUNDM_suppressionDesc/>
    <FUNBM>0.0</FUNBM>
    <FUNBM_suppression>false</FUNBM_suppression>
    <FUNBM_suppressionDesc/>
    <FUEDM>NaN</FUEDM>
    <FUEDM_suppression>false</FUEDM_suppression>
    <FUEDM_suppressionDesc/>
  </functionMetric>
  <fileMetric>
    <fileName>C:/USERS/MAC1/DOWNLOADS/MAKE/EXAMPLE.C</fileName>
    <PLOC>7.0</PLOC>
    <LOC>6.0</LOC>
    <FICRO>0.0</FICRO>
  </fileMetric>
  <moduleMetric>
    <moduleName>example</moduleName>
    <MONFI>10.0</MONFI>
    <MONFI-source>1.0</MONFI-source>
    <MONFI-header>9.0</MONFI-header>
    <MONFU>1.0</MONFU>
    <MONRC>0.0</MONRC>
  </moduleMetric>
</static.StaticResult>
